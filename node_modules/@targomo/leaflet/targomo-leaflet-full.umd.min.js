(function () {
'use strict';

function __$strToBlobUri(str, mime, isBinary) {try {return window.URL.createObjectURL(new Blob([Uint8Array.from(str.split('').map(function(c) {return c.charCodeAt(0)}))], {type: mime}));} catch (e) {return "data:" + mime + (isBinary ? ";base64," : ",") + str;}}
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    };

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue+','+value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    var this$1 = this;

    for (var name in this.map) {
      if (this$1.map.hasOwnProperty(name)) {
        callback.call(thisArg, this$1.map[name], name, this$1);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) { items.push(name); });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) { items.push(value); });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) { items.push([name, value]); });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    rawHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = 'status' in options ? options.status : 200;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);
      var xhr = new XMLHttpRequest();

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  };
  self.fetch.polyfill = true;
})(typeof self !== 'undefined' ? self : undefined);

var read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
};

var write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

var index$1 = {
	read: read,
	write: write
};

var index = Pbf;

var ieee754 = index$1;

function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        var this$1 = this;

        end = end || this.length;

        while (this.pos < end) {
            var val = this$1.readVarint(),
                tag = val >> 3,
                startPos = this$1.pos;

            this$1.type = val & 0x7;
            readField(tag, result, this$1);

            if (this$1.pos === startPos) { this$1.skip(val); }
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function(isSigned) {
        var buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) { return val; }
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) { return val; }
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) { return val; }
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) { return val; }
        b = buf[this.pos];   val |= (b & 0x0f) << 28;

        return readVarintRemainder(val, isSigned, this);
    },

    readVarint64: function() { // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = readUtf8(this.buf, this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function(arr, isSigned) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readVarint(isSigned)); }
        return arr;
    },
    readPackedSVarint: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readSVarint()); }
        return arr;
    },
    readPackedBoolean: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readBoolean()); }
        return arr;
    },
    readPackedFloat: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readFloat()); }
        return arr;
    },
    readPackedDouble: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readDouble()); }
        return arr;
    },
    readPackedFixed32: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readFixed32()); }
        return arr;
    },
    readPackedSFixed32: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readSFixed32()); }
        return arr;
    },
    readPackedFixed64: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readFixed64()); }
        return arr;
    },
    readPackedSFixed64: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readSFixed64()); }
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) { while (this.buf[this.pos++] > 0x7f) {} }
        else if (type === Pbf.Bytes) { this.pos = this.readVarint() + this.pos; }
        else if (type === Pbf.Fixed32) { this.pos += 4; }
        else if (type === Pbf.Fixed64) { this.pos += 8; }
        else { throw new Error('Unimplemented type: ' + type); }
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) { length *= 2; }

        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) { return; }
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) { return; }
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) { return; }
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;

        if (len >= 0x80) { makeRoomForExtraLength(startPos, len, this); }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var this$1 = this;

        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) { this$1.buf[this$1.pos++] = buffer[i]; }
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) { makeRoomForExtraLength(startPos, len, this); }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(l, s, p) {
    var buf = p.buf,
        h, b;

    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) { return toNum(l, h, s); }

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ?
        pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return ((high >>> 0) * 0x100000000) + (low >>> 0);
}

function writeBigVarint(val, pbf) {
    var low, high;

    if (val >= 0) {
        low  = (val % 0x100000000) | 0;
        high = (val / 0x100000000) | 0;
    } else {
        low  = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = (low + 1) | 0;
        } else {
            low = 0;
            high = (high + 1) | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos]   = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen =
        len <= 0x3fff ? 1 :
        len <= 0x1fffff ? 2 :
        len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) { pbf.buf[i + extraLen] = pbf.buf[i]; }
}

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) { pbf.writeVarint(arr[i]); }   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) { pbf.writeSVarint(arr[i]); }  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) { pbf.writeFloat(arr[i]); }    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) { pbf.writeDouble(arr[i]); }   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) { pbf.writeBoolean(arr[i]); }  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) { pbf.writeFixed32(arr[i]); }  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) { pbf.writeSFixed32(arr[i]); } }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) { pbf.writeFixed64(arr[i]); }  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) { pbf.writeSFixed64(arr[i]); } }

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] * 0x1000000);
}

function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = (val >>> 8);
    buf[pos + 2] = (val >>> 16);
    buf[pos + 3] = (val >>> 24);
}

function readInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
    var str = '';
    var i = pos;

    while (i < end) {
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence =
            b0 > 0xEF ? 4 :
            b0 > 0xDF ? 3 :
            b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) { break; }

        var b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;

        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || (i + 1 === str.length)) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}

var index$5 = Point$1;

function Point$1(x, y) {
    this.x = x;
    this.y = y;
}

Point$1.prototype = {
    clone: function() { return new Point$1(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point$1.convert = function (a) {
    if (a instanceof Point$1) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point$1(a[0], a[1]);
    }
    return a;
};

var Point = index$5;

var vectortilefeature = VectorTileFeature$2;

function VectorTileFeature$2(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) { feature.id = pbf.readVarint(); }
    else if (tag == 2) { readTag(pbf, feature); }
    else if (tag == 3) { feature.type = pbf.readVarint(); }
    else if (tag == 4) { feature._geometry = pbf.pos; }
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature$2.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature$2.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) { lines.push(line); }
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {

            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
            if (line) {
                line.push(line[0].clone()); // closePolygon
            }

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) { lines.push(line); }

    return lines;
};

VectorTileFeature$2.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) { x1 = x; }
            if (x > x2) { x2 = x; }
            if (y < y1) { y1 = y; }
            if (y > y2) { y2 = y; }

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature$2.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature$2.types[this.type],
        i, j;

    function project(line) {
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    switch (this.type) {
    case 1:
        var points = [];
        for (i = 0; i < coords.length; i++) {
            points[i] = coords[i][0];
        }
        coords = points;
        project(coords);
        break;

    case 2:
        for (i = 0; i < coords.length; i++) {
            project(coords[i]);
        }
        break;

    case 3:
        coords = classifyRings(coords);
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                project(coords[i][j]);
            }
        }
        break;
    }

    if (coords.length === 1) {
        coords = coords[0];
    } else {
        type = 'Multi' + type;
    }

    var result = {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };

    if ('id' in this) {
        result.id = this.id;
    }

    return result;
};

// classifies an array of rings into polygons with outer rings and holes

function classifyRings(rings) {
    var len = rings.length;

    if (len <= 1) { return [rings]; }

    var polygons = [],
        polygon,
        ccw;

    for (var i = 0; i < len; i++) {
        var area = signedArea(rings[i]);
        if (area === 0) { continue; }

        if (ccw === undefined) { ccw = area < 0; }

        if (ccw === area < 0) {
            if (polygon) { polygons.push(polygon); }
            polygon = [rings[i]];

        } else {
            polygon.push(rings[i]);
        }
    }
    if (polygon) { polygons.push(polygon); }

    return polygons;
}

function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2.x - p1.x) * (p1.y + p2.y);
    }
    return sum;
}

var VectorTileFeature$1 = vectortilefeature;

var vectortilelayer = VectorTileLayer$2;

function VectorTileLayer$2(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) { layer.version = pbf.readVarint(); }
    else if (tag === 1) { layer.name = pbf.readString(); }
    else if (tag === 5) { layer.extent = pbf.readVarint(); }
    else if (tag === 2) { layer._features.push(pbf.pos); }
    else if (tag === 3) { layer._keys.push(pbf.readString()); }
    else if (tag === 4) { layer._values.push(readValueMessage(pbf)); }
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer$2.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) { throw new Error('feature index out of bounds'); }

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature$1(this._pbf, end, this.extent, this._keys, this._values);
};

var VectorTileLayer$1 = vectortilelayer;

var vectortile = VectorTile$1;

function VectorTile$1(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer$1(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) { layers[layer.name] = layer; }
    }
}

var VectorTile = vectortile;

L.SVG.Tile = L.SVG.extend({

	initialize: function (tileCoord, tileSize, options) {
		L.SVG.prototype.initialize.call(this, options);
		this._tileCoord = tileCoord;
		this._size = tileSize;

		this._initContainer();
		this._container.setAttribute('width', this._size.x);
		this._container.setAttribute('height', this._size.y);
		this._container.setAttribute('viewBox', [0, 0, this._size.x, this._size.y].join(' '));

		this._layers = {};
	},

	getCoord: function() {
		return this._tileCoord;
	},

	getContainer: function() {
		return this._container;
	},

	onAdd: L.Util.falseFn,

	addTo: function(map) {
		this._map = map;
		if (this.options.interactive) {
			for (var i in this._layers) {
				var layer = this._layers[i];
				// By default, Leaflet tiles do not have pointer events.
				layer._path.style.pointerEvents = 'auto';
				this._map._targets[L.stamp(layer._path)] = layer;
			}
		}
	},

	removeFrom: function (map) {
		if (this.options.interactive) {
			for (var i in this._layers) {
				var layer = this._layers[i];
				delete this._map._targets[L.stamp(layer._path)];
			}
		}
		delete this._map;
	},

	_initContainer: function() {
		L.SVG.prototype._initContainer.call(this);
		var rect =  L.SVG.create('rect');
	},

	/// TODO: Modify _initPath to include an extra parameter, a group name
	/// to order symbolizers by z-index

	_addPath: function (layer) {
		this._rootGroup.appendChild(layer._path);
		this._layers[L.stamp(layer)] = layer;
	},

	_updateIcon: function (layer) {
		var path = layer._path = L.SVG.create('image'),
		    icon = layer.options.icon,
		    options = icon.options,
		    size = L.point(options.iconSize),
		    anchor = options.iconAnchor ||
		        	 size && size.divideBy(2, true),
		    p = layer._point.subtract(anchor);
		path.setAttribute('x', p.x);
		path.setAttribute('y', p.y);
		path.setAttribute('width', size.x + 'px');
		path.setAttribute('height', size.y + 'px');
		path.setAttribute('href', options.iconUrl);
	}
});


L.svg.tile = function(tileCoord, tileSize, opts){
	return new L.SVG.Tile(tileCoord, tileSize, opts);
};

// 🍂class Symbolizer
// 🍂inherits Class
// The abstract Symbolizer class is mostly equivalent in concept to a `L.Path` - it's an interface for
// polylines, polygons and circles. But instead of representing leaflet Layers,
// it represents things that have to be drawn inside a vector tile.

// A vector tile *data layer* might have zero, one, or more *symbolizer definitions*
// A vector tile *feature* might have zero, one, or more *symbolizers*.
// The actual symbolizers applied will depend on filters and the symbolizer functions.

var Symbolizer = L.Class.extend({
	// 🍂method initialize(feature: GeoJSON, pxPerExtent: Number)
	// Initializes a new Line Symbolizer given a GeoJSON feature and the
	// pixel-to-coordinate-units ratio. Internal use only.

	// 🍂method render(renderer, style)
	// Renders this symbolizer in the given tiled renderer, with the given
	// `L.Path` options.  Internal use only.
	render: function(renderer, style) {
		this._renderer = renderer;
		this.options = style;
		renderer._initPath(this);
		renderer._updateStyle(this);
	},

	// 🍂method render(renderer, style)
	// Updates the `L.Path` options used to style this symbolizer, and re-renders it.
	// Internal use only.
	updateStyle: function(renderer, style) {
		this.options = style;
		renderer._updateStyle(this);
	},

	_getPixelBounds: function() {
		var parts = this._parts;
		var bounds = L.bounds([]);
		for (var i = 0; i < parts.length; i++) {
			var part = parts[i];
			for (var j = 0; j < part.length; j++) {
				bounds.extend(part[j]);
			}
		}

		var w = this._clickTolerance(),
		    p = new L.Point(w, w);

		bounds.min._subtract(p);
		bounds.max._add(p);

		return bounds;
	},
	_clickTolerance: L.Path.prototype._clickTolerance,
});

// Contains mixins which are common to the Line Symbolizer and the Fill Symbolizer.

var PolyBase = {
	_makeFeatureParts: function(feat, pxPerExtent) {
		var rings = feat.geometry;
		var coord;

		this._parts = [];
		for (var i = 0; i < rings.length; i++) {
			var ring = rings[i];
			var part = [];
			for (var j = 0; j < ring.length; j++) {
				coord = ring[j];
				// Protobuf vector tiles return {x: , y:}
				// Geojson-vt returns [,]
				part.push(L.point(coord).scaleBy(pxPerExtent));
			}
			this._parts.push(part);
		}
	},

	makeInteractive: function() {
		this._pxBounds = this._getPixelBounds();
	}
};

// 🍂class PointSymbolizer
// 🍂inherits CircleMarker
// A symbolizer for points.

var PointSymbolizer = L.CircleMarker.extend({
	includes: Symbolizer.prototype,

	statics: {
		iconCache: {}
	},

	initialize: function(feature, pxPerExtent) {
		this.properties = feature.properties;
		this._makeFeatureParts(feature, pxPerExtent);
	},

	render: function(renderer, style) {
		Symbolizer.prototype.render.call(this, renderer, style);
		this._radius = style.radius || L.CircleMarker.prototype.options.radius;
		this._updatePath();
	},

	_makeFeatureParts: function(feat, pxPerExtent) {
		var coord = feat.geometry[0];
		if (typeof coord[0] === 'object' && 'x' in coord[0]) {
			// Protobuf vector tiles return [{x: , y:}]
			this._point = L.point(coord[0]).scaleBy(pxPerExtent);
			this._empty = L.Util.falseFn;
		} else {
			// Geojson-vt returns [,]
			this._point = L.point(coord).scaleBy(pxPerExtent);
			this._empty = L.Util.falseFn;
		}
	},

	makeInteractive: function() {
		this._updateBounds();
	},

	updateStyle: function(renderer, style) {
		this._radius = style.radius || this._radius;
		this._updateBounds();
		return Symbolizer.prototype.updateStyle.call(this, renderer, style);
	},

	_updateBounds: function() {
		var icon = this.options.icon;
		if (icon) {
			var size = L.point(icon.options.iconSize),
			    anchor = icon.options.iconAnchor ||
			             size && size.divideBy(2, true),
			    p = this._point.subtract(anchor);
			this._pxBounds = new L.Bounds(p, p.add(icon.options.iconSize));
		} else {
			L.CircleMarker.prototype._updateBounds.call(this);
		}
	},

	_updatePath: function() {
		if (this.options.icon) {
			this._renderer._updateIcon(this);
		} else {
			L.CircleMarker.prototype._updatePath.call(this);
		}
	},

	_getImage: function () {
		if (this.options.icon) {
			var url = this.options.icon.options.iconUrl,
			    img = PointSymbolizer.iconCache[url];
			if (!img) {
				var icon = this.options.icon;
				img = PointSymbolizer.iconCache[url] = icon.createIcon();
			}
			return img;
		} else {
			return null;
		}

	},

	_containsPoint: function(p) {
		var icon = this.options.icon;
		if (icon) {
			return this._pxBounds.contains(p);
		} else {
			return L.CircleMarker.prototype._containsPoint.call(this, p);
		}
	}
});

// 🍂class LineSymbolizer
// 🍂inherits Polyline
// A symbolizer for lines. Can be applied to line and polygon features.

var LineSymbolizer = L.Polyline.extend({
	includes: [Symbolizer.prototype, PolyBase],

	initialize: function(feature, pxPerExtent) {
		this.properties = feature.properties;
		this._makeFeatureParts(feature, pxPerExtent);
	},

	render: function(renderer, style) {
		style.fill = false;
		Symbolizer.prototype.render.call(this, renderer, style);
		this._updatePath();
	},

	updateStyle: function(renderer, style) {
		style.fill = false;
		Symbolizer.prototype.updateStyle.call(this, renderer, style);
	},
});

// 🍂class FillSymbolizer
// 🍂inherits Polyline
// A symbolizer for filled areas. Applies only to polygon features.

var FillSymbolizer = L.Polygon.extend({
	includes: [Symbolizer.prototype, PolyBase],

	initialize: function(feature, pxPerExtent) {
		this.properties = feature.properties;
		this._makeFeatureParts(feature, pxPerExtent);
	},

	render: function(renderer, style) {
		Symbolizer.prototype.render.call(this, renderer, style);
		this._updatePath();
	}
});

/* 🍂class VectorGrid
 * 🍂inherits GridLayer
 *
 * A `VectorGrid` is a generic, abstract class for displaying tiled vector data.
 * it provides facilities for symbolizing and rendering the data in the vector
 * tiles, but lacks the functionality to fetch the vector tiles from wherever
 * they are.
 *
 * Extends Leaflet's `L.GridLayer`.
 */

L.VectorGrid = L.GridLayer.extend({

	options: {
		// 🍂option rendererFactory = L.svg.tile
		// A factory method which will be used to instantiate the per-tile renderers.
		rendererFactory: L.svg.tile,

		// 🍂option vectorTileLayerStyles: Object = {}
		// A data structure holding initial symbolizer definitions for the vector features.
		vectorTileLayerStyles: {},

		// 🍂option interactive: Boolean = false
		// Whether this `VectorGrid` fires `Interactive Layer` events.
		interactive: false,

		// 🍂option getFeatureId: Function = undefined
		// A function that, given a vector feature, returns an unique identifier for it, e.g.
		// `function(feat) { return feat.properties.uniqueIdField; }`.
		// Must be defined for `setFeatureStyle` to work.
	},

	initialize: function(options) {
		L.setOptions(this, options);
		L.GridLayer.prototype.initialize.apply(this, arguments);
		if (this.options.getFeatureId) {
			this._vectorTiles = {};
			this._overriddenStyles = {};
			this.on('tileunload', function(e) {
				var key = this._tileCoordsToKey(e.coords),
				    tile = this._vectorTiles[key];

				if (tile && this._map) {
					tile.removeFrom(this._map);
				}
				delete this._vectorTiles[key];
			}, this);
		}
		this._dataLayerNames = {};
	},

	createTile: function(coords, done) {
		var storeFeatures = this.options.getFeatureId;

		var tileSize = this.getTileSize();
		var renderer = this.options.rendererFactory(coords, tileSize, this.options);

		var vectorTilePromise = this._getVectorTilePromise(coords);

		if (storeFeatures) {
			this._vectorTiles[this._tileCoordsToKey(coords)] = renderer;
			renderer._features = {};
		}

		vectorTilePromise.then( function renderTile(vectorTile) {
			for (var layerName in vectorTile.layers) {
				this._dataLayerNames[layerName] = true;
				var layer = vectorTile.layers[layerName];

				var pxPerExtent = this.getTileSize().divideBy(layer.extent);

				var layerStyle = this.options.vectorTileLayerStyles[ layerName ] ||
				L.Path.prototype.options;

				for (var i = 0; i < layer.features.length; i++) {
					var feat = layer.features[i];
					var id;

					var styleOptions = layerStyle;
					if (storeFeatures) {
						id = this.options.getFeatureId(feat);
						var styleOverride = this._overriddenStyles[id];
						if (styleOverride) {
							if (styleOverride[layerName]) {
								styleOptions = styleOverride[layerName];
							} else {
								styleOptions = styleOverride;
							}
						}
					}

					if (styleOptions instanceof Function) {
						styleOptions = styleOptions(feat.properties, coords.z);
					}

					if (!(styleOptions instanceof Array)) {
						styleOptions = [styleOptions];
					}

					if (!styleOptions.length) {
						continue;
					}

					var featureLayer = this._createLayer(feat, pxPerExtent);

					for (var j = 0; j < styleOptions.length; j++) {
						var style = L.extend({}, L.Path.prototype.options, styleOptions[j]);
						featureLayer.render(renderer, style);
						renderer._addPath(featureLayer);
					}

					if (this.options.interactive) {
						featureLayer.makeInteractive();
					}

					if (storeFeatures) {
						renderer._features[id] = {
							layerName: layerName,
							feature: featureLayer
						};
					}
				}

			}
			if (this._map != null) {
				renderer.addTo(this._map);
			}
			L.Util.requestAnimFrame(done.bind(coords, null, null));
		}.bind(this));

		return renderer.getContainer();
	},

	// 🍂method setFeatureStyle(id: Number, layerStyle: L.Path Options): this
	// Given the unique ID for a vector features (as per the `getFeatureId` option),
	// re-symbolizes that feature across all tiles it appears in.
	setFeatureStyle: function(id, layerStyle) {
		this._overriddenStyles[id] = layerStyle;

		for (var tileKey in this._vectorTiles) {
			var tile = this._vectorTiles[tileKey];
			var features = tile._features;
			var data = features[id];
			if (data) {
				var feat = data.feature;

				var styleOptions = layerStyle;
				if (layerStyle[data.layerName]) {
					styleOptions = layerStyle[data.layerName];
				}

				this._updateStyles(feat, tile, styleOptions);
			}
		}
		return this;
	},

	// 🍂method setFeatureStyle(id: Number): this
	// Reverts the effects of a previous `setFeatureStyle` call.
	resetFeatureStyle: function(id) {
		delete this._overriddenStyles[id];

		for (var tileKey in this._vectorTiles) {
			var tile = this._vectorTiles[tileKey];
			var features = tile._features;
			var data = features[id];
			if (data) {
				var feat = data.feature;
				var styleOptions = this.options.vectorTileLayerStyles[ data.layerName ] ||
				L.Path.prototype.options;
				this._updateStyles(feat, tile, styleOptions);
			}
		}
		return this;
	},

	// 🍂method getDataLayerNames(): Array
	// Returns an array of strings, with all the known names of data layers in
	// the vector tiles displayed. Useful for introspection.
	getDataLayerNames: function() {
		return Object.keys(this._dataLayerNames);
	},

	_updateStyles: function(feat, renderer, styleOptions) {
		styleOptions = (styleOptions instanceof Function) ?
			styleOptions(feat.properties, renderer.getCoord().z) :
			styleOptions;

		if (!(styleOptions instanceof Array)) {
			styleOptions = [styleOptions];
		}

		for (var j = 0; j < styleOptions.length; j++) {
			var style = L.extend({}, L.Path.prototype.options, styleOptions[j]);
			feat.updateStyle(renderer, style);
		}
	},

	_createLayer: function(feat, pxPerExtent, layerStyle) {
		var layer;
		switch (feat.type) {
		case 1:
			layer = new PointSymbolizer(feat, pxPerExtent);
			break;
		case 2:
			layer = new LineSymbolizer(feat, pxPerExtent);
			break;
		case 3:
			layer = new FillSymbolizer(feat, pxPerExtent);
			break;
		}

		if (this.options.interactive) {
			layer.addEventParent(this);
		}

		return layer;
	},
});

/*
 * 🍂section Extension methods
 *
 * Classes inheriting from `VectorGrid` **must** define the `_getVectorTilePromise` private method.
 *
 * 🍂method getVectorTilePromise(coords: Object): Promise
 * Given a `coords` object in the form of `{x: Number, y: Number, z: Number}`,
 * this function must return a `Promise` for a vector tile.
 *
 */
L.vectorGrid = function (options) {
	return new L.VectorGrid(options);
};

/*
 * 🍂class VectorGrid.Protobuf
 * 🍂extends VectorGrid
 *
 * A `VectorGrid` for vector tiles fetched from the internet.
 * Tiles are supposed to be protobufs (AKA "protobuffer" or "Protocol Buffers"),
 * containing data which complies with the
 * [MapBox Vector Tile Specification](https://github.com/mapbox/vector-tile-spec/tree/master/2.1).
 *
 * This is the format used by:
 * - Mapbox Vector Tiles
 * - Mapzen Vector Tiles
 * - ESRI Vector Tiles
 * - [OpenMapTiles hosted Vector Tiles](https://openmaptiles.com/hosting/)
 *
 * 🍂example
 *
 * You must initialize a `VectorGrid.Protobuf` with a URL template, just like in
 * `L.TileLayer`s. The difference is that the template must point to vector tiles
 * (usually `.pbf` or `.mvt`) instead of raster (`.png` or `.jpg`) tiles, and that
 * you should define the styling for all the features.
 *
 * <br><br>
 *
 * For OpenMapTiles, with a key from [https://openmaptiles.org/docs/host/use-cdn/](https://openmaptiles.org/docs/host/use-cdn/),
 * initialization looks like this:
 *
 * ```
 * L.vectorGrid.protobuf("https://free-{s}.tilehosting.com/data/v3/{z}/{x}/{y}.pbf.pict?key={key}", {
 * 	vectorTileLayerStyles: { ... },
 * 	subdomains: "0123",
 * 	key: 'abcdefghi01234567890',
 * 	maxNativeZoom: 14
 * }).addTo(map);
 * ```
 *
 * And for Mapbox vector tiles, it looks like this:
 *
 * ```
 * L.vectorGrid.protobuf("https://{s}.tiles.mapbox.com/v4/mapbox.mapbox-streets-v6/{z}/{x}/{y}.vector.pbf?access_token={token}", {
 * 	vectorTileLayerStyles: { ... },
 * 	subdomains: "abcd",
 * 	token: "pk.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRTS.TUVWXTZ0123456789abcde"
 * }).addTo(map);
 * ```
 */
L.VectorGrid.Protobuf = L.VectorGrid.extend({

	options: {
		// 🍂section
		// As with `L.TileLayer`, the URL template might contain a reference to
		// any option (see the example above and note the `{key}` or `token` in the URL
		// template, and the corresponding option).
		//
		// 🍂option subdomains: String = 'abc'
		// Akin to the `subdomains` option for `L.TileLayer`.
		subdomains: 'abc',	// Like L.TileLayer
		//
		// 🍂option fetchOptions: Object = {}
		// options passed to `fetch`, e.g. {credentials: 'same-origin'} to send cookie for the current domain
		fetchOptions: {}
	},

	initialize: function(url, options) {
		// Inherits options from geojson-vt!
// 		this._slicer = geojsonvt(geojson, options);
		this._url = url;
		L.VectorGrid.prototype.initialize.call(this, options);
	},

	// 🍂method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	setUrl: function(url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	},

	_getSubdomain: L.TileLayer.prototype._getSubdomain,

	_getVectorTilePromise: function(coords) {
		var data = {
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: coords.z
// 			z: this._getZoomForUrl()	/// TODO: Maybe replicate TileLayer's maxNativeZoom
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) { // Should this option be available in Leaflet.VectorGrid?
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		var tileUrl = L.Util.template(this._url, L.extend(data, this.options));

		return fetch(tileUrl, this.options.fetchOptions).then(function(response){

			if (!response.ok) {
				return {layers:[]};
			}

			return response.blob().then( function (blob) {
// 				console.log(blob);

				var reader = new FileReader();
				return new Promise(function(resolve){
					reader.addEventListener("loadend", function() {
						// reader.result contains the contents of blob as a typed array

						// blob.type === 'application/x-protobuf'
						var pbf = new index( reader.result );
// 						console.log(pbf);
						return resolve(new VectorTile( pbf ));

					});
					reader.readAsArrayBuffer(blob);
				});
			});
		}).then(function(json){

// 			console.log('Vector tile:', json.layers);
// 			console.log('Vector tile water:', json.layers.water);	// Instance of VectorTileLayer

			// Normalize feature getters into actual instanced features
			for (var layerName in json.layers) {
				var feats = [];

				for (var i=0; i<json.layers[layerName].length; i++) {
					var feat = json.layers[layerName].feature(i);
					feat.geometry = feat.loadGeometry();
					feats.push(feat);
				}

				json.layers[layerName].features = feats;
			}

			return json;
		});
	}
});


// 🍂factory L.vectorGrid.protobuf(url: String, options)
// Instantiates a new protobuf VectorGrid with the given URL template and options
L.vectorGrid.protobuf = function (url, options) {
	return new L.VectorGrid.Protobuf(url, options);
};

var workerCode = __$strToBlobUri("'use strict';\n\nvar simplify_1 = simplify$1;\n\n// calculate simplification data using optimized Douglas-Peucker algorithm\n\nfunction simplify$1(points, tolerance) {\n\n    var sqTolerance = tolerance * tolerance,\n        len = points.length,\n        first = 0,\n        last = len - 1,\n        stack = [],\n        i, maxSqDist, sqDist, index;\n\n    // always retain the endpoints (1 is the max value)\n    points[first][2] = 1;\n    points[last][2] = 1;\n\n    // avoid recursion by using a stack\n    while (last) {\n\n        maxSqDist = 0;\n\n        for (i = first + 1; i < last; i++) {\n            sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n            if (sqDist > maxSqDist) {\n                index = i;\n                maxSqDist = sqDist;\n            }\n        }\n\n        if (maxSqDist > sqTolerance) {\n            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate\n            stack.push(first);\n            stack.push(index);\n            first = index;\n\n        } else {\n            last = stack.pop();\n            first = stack.pop();\n        }\n    }\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, a, b) {\n\n    var x = a[0], y = a[1],\n        bx = b[0], by = b[1],\n        px = p[0], py = p[1],\n        dx = bx - x,\n        dy = by - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = bx;\n            y = by;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n\nvar convert_1 = convert$1;\n\nvar simplify = simplify_1;\n\n// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data\n\nfunction convert$1(data, tolerance) {\n    var features = [];\n\n    if (data.type === 'FeatureCollection') {\n        for (var i = 0; i < data.features.length; i++) {\n            convertFeature(features, data.features[i], tolerance);\n        }\n    } else if (data.type === 'Feature') {\n        convertFeature(features, data, tolerance);\n\n    } else {\n        // single geometry or a geometry collection\n        convertFeature(features, {geometry: data}, tolerance);\n    }\n    return features;\n}\n\nfunction convertFeature(features, feature, tolerance) {\n    if (feature.geometry === null) {\n        // ignore features with null geometry\n        return;\n    }\n\n    var geom = feature.geometry,\n        type = geom.type,\n        coords = geom.coordinates,\n        tags = feature.properties,\n        i, j, rings, projectedRing;\n\n    if (type === 'Point') {\n        features.push(create(tags, 1, [projectPoint(coords)]));\n\n    } else if (type === 'MultiPoint') {\n        features.push(create(tags, 1, project(coords)));\n\n    } else if (type === 'LineString') {\n        features.push(create(tags, 2, [project(coords, tolerance)]));\n\n    } else if (type === 'MultiLineString' || type === 'Polygon') {\n        rings = [];\n        for (i = 0; i < coords.length; i++) {\n            projectedRing = project(coords[i], tolerance);\n            if (type === 'Polygon') { projectedRing.outer = (i === 0); }\n            rings.push(projectedRing);\n        }\n        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));\n\n    } else if (type === 'MultiPolygon') {\n        rings = [];\n        for (i = 0; i < coords.length; i++) {\n            for (j = 0; j < coords[i].length; j++) {\n                projectedRing = project(coords[i][j], tolerance);\n                projectedRing.outer = (j === 0);\n                rings.push(projectedRing);\n            }\n        }\n        features.push(create(tags, 3, rings));\n\n    } else if (type === 'GeometryCollection') {\n        for (i = 0; i < geom.geometries.length; i++) {\n            convertFeature(features, {\n                geometry: geom.geometries[i],\n                properties: tags\n            }, tolerance);\n        }\n\n    } else {\n        throw new Error('Input data is not a valid GeoJSON object.');\n    }\n}\n\nfunction create(tags, type, geometry) {\n    var feature = {\n        geometry: geometry,\n        type: type,\n        tags: tags || null,\n        min: [2, 1], // initial bbox values;\n        max: [-1, 0]  // note that coords are usually in [0..1] range\n    };\n    calcBBox(feature);\n    return feature;\n}\n\nfunction project(lonlats, tolerance) {\n    var projected = [];\n    for (var i = 0; i < lonlats.length; i++) {\n        projected.push(projectPoint(lonlats[i]));\n    }\n    if (tolerance) {\n        simplify(projected, tolerance);\n        calcSize(projected);\n    }\n    return projected;\n}\n\nfunction projectPoint(p) {\n    var sin = Math.sin(p[1] * Math.PI / 180),\n        x = (p[0] / 360 + 0.5),\n        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n\n    y = y < 0 ? 0 :\n        y > 1 ? 1 : y;\n\n    return [x, y, 0];\n}\n\n// calculate area and length of the poly\nfunction calcSize(points) {\n    var area = 0,\n        dist = 0;\n\n    for (var i = 0, a, b; i < points.length - 1; i++) {\n        a = b || points[i];\n        b = points[i + 1];\n\n        area += a[0] * b[1] - b[0] * a[1];\n\n        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation\n        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);\n    }\n    points.area = Math.abs(area / 2);\n    points.dist = dist;\n}\n\n// calculate the feature bounding box for faster clipping later\nfunction calcBBox(feature) {\n    var geometry = feature.geometry,\n        min = feature.min,\n        max = feature.max;\n\n    if (feature.type === 1) { calcRingBBox(min, max, geometry); }\n    else { for (var i = 0; i < geometry.length; i++) { calcRingBBox(min, max, geometry[i]); } }\n\n    return feature;\n}\n\nfunction calcRingBBox(min, max, points) {\n    for (var i = 0, p; i < points.length; i++) {\n        p = points[i];\n        min[0] = Math.min(p[0], min[0]);\n        max[0] = Math.max(p[0], max[0]);\n        min[1] = Math.min(p[1], min[1]);\n        max[1] = Math.max(p[1], max[1]);\n    }\n}\n\nvar tile = transformTile;\nvar point = transformPoint;\n\n// Transforms the coordinates of each feature in the given tile from\n// mercator-projected space into (extent x extent) tile space.\nfunction transformTile(tile, extent) {\n    if (tile.transformed) { return tile; }\n\n    var z2 = tile.z2,\n        tx = tile.x,\n        ty = tile.y,\n        i, j, k;\n\n    for (i = 0; i < tile.features.length; i++) {\n        var feature = tile.features[i],\n            geom = feature.geometry,\n            type = feature.type;\n\n        if (type === 1) {\n            for (j = 0; j < geom.length; j++) { geom[j] = transformPoint(geom[j], extent, z2, tx, ty); }\n\n        } else {\n            for (j = 0; j < geom.length; j++) {\n                var ring = geom[j];\n                for (k = 0; k < ring.length; k++) { ring[k] = transformPoint(ring[k], extent, z2, tx, ty); }\n            }\n        }\n    }\n\n    tile.transformed = true;\n\n    return tile;\n}\n\nfunction transformPoint(p, extent, z2, tx, ty) {\n    var x = Math.round(extent * (p[0] * z2 - tx)),\n        y = Math.round(extent * (p[1] * z2 - ty));\n    return [x, y];\n}\n\nvar transform$1 = {\n	tile: tile,\n	point: point\n};\n\nvar clip_1 = clip$1;\n\n/* clip features between two axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   \____|____/\n *     |        |\n */\n\nfunction clip$1(features, scale, k1, k2, axis, intersect, minAll, maxAll) {\n\n    k1 /= scale;\n    k2 /= scale;\n\n    if (minAll >= k1 && maxAll <= k2) { return features; } // trivial accept\n    else if (minAll > k2 || maxAll < k1) { return null; } // trivial reject\n\n    var clipped = [];\n\n    for (var i = 0; i < features.length; i++) {\n\n        var feature = features[i],\n            geometry = feature.geometry,\n            type = feature.type,\n            min, max;\n\n        min = feature.min[axis];\n        max = feature.max[axis];\n\n        if (min >= k1 && max <= k2) { // trivial accept\n            clipped.push(feature);\n            continue;\n        } else if (min > k2 || max < k1) { continue; } // trivial reject\n\n        var slices = type === 1 ?\n                clipPoints(geometry, k1, k2, axis) :\n                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);\n\n        if (slices.length) {\n            // if a feature got clipped, it will likely get clipped on the next zoom level as well,\n            // so there's no need to recalculate bboxes\n            clipped.push({\n                geometry: slices,\n                type: type,\n                tags: features[i].tags || null,\n                min: feature.min,\n                max: feature.max\n            });\n        }\n    }\n\n    return clipped.length ? clipped : null;\n}\n\nfunction clipPoints(geometry, k1, k2, axis) {\n    var slice = [];\n\n    for (var i = 0; i < geometry.length; i++) {\n        var a = geometry[i],\n            ak = a[axis];\n\n        if (ak >= k1 && ak <= k2) { slice.push(a); }\n    }\n    return slice;\n}\n\nfunction clipGeometry(geometry, k1, k2, axis, intersect, closed) {\n\n    var slices = [];\n\n    for (var i = 0; i < geometry.length; i++) {\n\n        var ak = 0,\n            bk = 0,\n            b = null,\n            points = geometry[i],\n            area = points.area,\n            dist = points.dist,\n            outer = points.outer,\n            len = points.length,\n            a, j, last;\n\n        var slice = [];\n\n        for (j = 0; j < len - 1; j++) {\n            a = b || points[j];\n            b = points[j + 1];\n            ak = bk || a[axis];\n            bk = b[axis];\n\n            if (ak < k1) {\n\n                if ((bk > k2)) { // ---|-----|-->\n                    slice.push(intersect(a, b, k1), intersect(a, b, k2));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n\n                } else if (bk >= k1) { slice.push(intersect(a, b, k1)); } // ---|-->  |\n\n            } else if (ak > k2) {\n\n                if ((bk < k1)) { // <--|-----|---\n                    slice.push(intersect(a, b, k2), intersect(a, b, k1));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n\n                } else if (bk <= k2) { slice.push(intersect(a, b, k2)); } // |  <--|---\n\n            } else {\n\n                slice.push(a);\n\n                if (bk < k1) { // <--|---  |\n                    slice.push(intersect(a, b, k1));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n\n                } else if (bk > k2) { // |  ---|-->\n                    slice.push(intersect(a, b, k2));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n                }\n                // | --> |\n            }\n        }\n\n        // add the last point\n        a = points[len - 1];\n        ak = a[axis];\n        if (ak >= k1 && ak <= k2) { slice.push(a); }\n\n        // close the polygon if its endpoints are not the same after clipping\n\n        last = slice[slice.length - 1];\n        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) { slice.push(slice[0]); }\n\n        // add the final slice\n        newSlice(slices, slice, area, dist, outer);\n    }\n\n    return slices;\n}\n\nfunction newSlice(slices, slice, area, dist, outer) {\n    if (slice.length) {\n        // we don't recalculate the area/length of the unclipped geometry because the case where it goes\n        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work\n        slice.area = area;\n        slice.dist = dist;\n        if (outer !== undefined) { slice.outer = outer; }\n\n        slices.push(slice);\n    }\n    return [];\n}\n\nvar clip$2 = clip_1;\n\nvar wrap_1 = wrap$1;\n\nfunction wrap$1(features, buffer, intersectX) {\n    var merged = features,\n        left  = clip$2(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy\n        right = clip$2(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy\n\n    if (left || right) {\n        merged = clip$2(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy\n\n        if (left) { merged = shiftFeatureCoords(left, 1).concat(merged); } // merge left into center\n        if (right) { merged = merged.concat(shiftFeatureCoords(right, -1)); } // merge right into center\n    }\n\n    return merged;\n}\n\nfunction shiftFeatureCoords(features, offset) {\n    var newFeatures = [];\n\n    for (var i = 0; i < features.length; i++) {\n        var feature = features[i],\n            type = feature.type;\n\n        var newGeometry;\n\n        if (type === 1) {\n            newGeometry = shiftCoords(feature.geometry, offset);\n        } else {\n            newGeometry = [];\n            for (var j = 0; j < feature.geometry.length; j++) {\n                newGeometry.push(shiftCoords(feature.geometry[j], offset));\n            }\n        }\n\n        newFeatures.push({\n            geometry: newGeometry,\n            type: type,\n            tags: feature.tags,\n            min: [feature.min[0] + offset, feature.min[1]],\n            max: [feature.max[0] + offset, feature.max[1]]\n        });\n    }\n\n    return newFeatures;\n}\n\nfunction shiftCoords(points, offset) {\n    var newPoints = [];\n    newPoints.area = points.area;\n    newPoints.dist = points.dist;\n\n    for (var i = 0; i < points.length; i++) {\n        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);\n    }\n    return newPoints;\n}\n\nvar tile$1 = createTile$1;\n\nfunction createTile$1(features, z2, tx, ty, tolerance, noSimplify) {\n    var tile = {\n        features: [],\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: 0,\n        source: null,\n        x: tx,\n        y: ty,\n        z2: z2,\n        transformed: false,\n        min: [2, 1],\n        max: [-1, 0]\n    };\n    for (var i = 0; i < features.length; i++) {\n        tile.numFeatures++;\n        addFeature(tile, features[i], tolerance, noSimplify);\n\n        var min = features[i].min,\n            max = features[i].max;\n\n        if (min[0] < tile.min[0]) { tile.min[0] = min[0]; }\n        if (min[1] < tile.min[1]) { tile.min[1] = min[1]; }\n        if (max[0] > tile.max[0]) { tile.max[0] = max[0]; }\n        if (max[1] > tile.max[1]) { tile.max[1] = max[1]; }\n    }\n    return tile;\n}\n\nfunction addFeature(tile, feature, tolerance, noSimplify) {\n\n    var geom = feature.geometry,\n        type = feature.type,\n        simplified = [],\n        sqTolerance = tolerance * tolerance,\n        i, j, ring, p;\n\n    if (type === 1) {\n        for (i = 0; i < geom.length; i++) {\n            simplified.push(geom[i]);\n            tile.numPoints++;\n            tile.numSimplified++;\n        }\n\n    } else {\n\n        // simplify and transform projected coordinates for tile geometry\n        for (i = 0; i < geom.length; i++) {\n            ring = geom[i];\n\n            // filter out tiny polylines & polygons\n            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||\n                                (type === 3 && ring.area < sqTolerance))) {\n                tile.numPoints += ring.length;\n                continue;\n            }\n\n            var simplifiedRing = [];\n\n            for (j = 0; j < ring.length; j++) {\n                p = ring[j];\n                // keep points with importance > tolerance\n                if (noSimplify || p[2] > sqTolerance) {\n                    simplifiedRing.push(p);\n                    tile.numSimplified++;\n                }\n                tile.numPoints++;\n            }\n\n            if (type === 3) { rewind(simplifiedRing, ring.outer); }\n\n            simplified.push(simplifiedRing);\n        }\n    }\n\n    if (simplified.length) {\n        tile.features.push({\n            geometry: simplified,\n            type: type,\n            tags: feature.tags || null\n        });\n    }\n}\n\nfunction rewind(ring, clockwise) {\n    var area = signedArea(ring);\n    if (area < 0 === clockwise) { ring.reverse(); }\n}\n\nfunction signedArea(ring) {\n    var sum = 0;\n    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);\n    }\n    return sum;\n}\n\nvar index = geojsonvt;\n\nvar convert = convert_1;\nvar transform = transform$1;\nvar clip = clip_1;\nvar wrap = wrap_1;\nvar createTile = tile$1;     // final simplified tile generation\n\n\nfunction geojsonvt(data, options) {\n    return new GeoJSONVT(data, options);\n}\n\nfunction GeoJSONVT(data, options) {\n    options = this.options = extend(Object.create(this.options), options);\n\n    var debug = options.debug;\n\n    if (debug) { console.time('preprocess data'); }\n\n    var z2 = 1 << options.maxZoom, // 2^z\n        features = convert(data, options.tolerance / (z2 * options.extent));\n\n    this.tiles = {};\n    this.tileCoords = [];\n\n    if (debug) {\n        console.timeEnd('preprocess data');\n        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);\n        console.time('generate tiles');\n        this.stats = {};\n        this.total = 0;\n    }\n\n    features = wrap(features, options.buffer / options.extent, intersectX);\n\n    // start slicing from the top tile down\n    if (features.length) { this.splitTile(features, 0, 0, 0); }\n\n    if (debug) {\n        if (features.length) { console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints); }\n        console.timeEnd('generate tiles');\n        console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n    }\n}\n\nGeoJSONVT.prototype.options = {\n    maxZoom: 14,            // max zoom to preserve detail on\n    indexMaxZoom: 5,        // max zoom in the tile index\n    indexMaxPoints: 100000, // max number of points per tile in the tile index\n    solidChildren: false,   // whether to tile solid square tiles further\n    tolerance: 3,           // simplification tolerance (higher means simpler)\n    extent: 4096,           // tile extent\n    buffer: 64,             // tile buffer on each side\n    debug: 0                // logging level (0, 1 or 2)\n};\n\nGeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {\n    var this$1 = this;\n\n\n    var stack = [features, z, x, y],\n        options = this.options,\n        debug = options.debug,\n        solid = null;\n\n    // avoid recursion by using a processing queue\n    while (stack.length) {\n        y = stack.pop();\n        x = stack.pop();\n        z = stack.pop();\n        features = stack.pop();\n\n        var z2 = 1 << z,\n            id = toID(z, x, y),\n            tile = this$1.tiles[id],\n            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);\n\n        if (!tile) {\n            if (debug > 1) { console.time('creation'); }\n\n            tile = this$1.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);\n            this$1.tileCoords.push({z: z, x: x, y: y});\n\n            if (debug) {\n                if (debug > 1) {\n                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',\n                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);\n                    console.timeEnd('creation');\n                }\n                var key = 'z' + z;\n                this$1.stats[key] = (this$1.stats[key] || 0) + 1;\n                this$1.total++;\n            }\n        }\n\n        // save reference to original geometry in tile so that we can drill down later if we stop now\n        tile.source = features;\n\n        // if it's the first-pass tiling\n        if (!cz) {\n            // stop tiling if we reached max zoom, or if the tile is too simple\n            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) { continue; }\n\n        // if a drilldown to a specific tile\n        } else {\n            // stop tiling if we reached base zoom or our target tile zoom\n            if (z === options.maxZoom || z === cz) { continue; }\n\n            // stop tiling if it's not an ancestor of the target tile\n            var m = 1 << (cz - z);\n            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) { continue; }\n        }\n\n        // stop tiling if the tile is solid clipped square\n        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) {\n            if (cz) { solid = z; } // and remember the zoom if we're drilling down\n            continue;\n        }\n\n        // if we slice further down, no need to keep source geometry\n        tile.source = null;\n\n        if (debug > 1) { console.time('clipping'); }\n\n        // values we'll use for clipping\n        var k1 = 0.5 * options.buffer / options.extent,\n            k2 = 0.5 - k1,\n            k3 = 0.5 + k1,\n            k4 = 1 + k1,\n            tl, bl, tr, br, left, right;\n\n        tl = bl = tr = br = null;\n\n        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);\n        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);\n\n        if (left) {\n            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);\n            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);\n        }\n\n        if (right) {\n            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);\n            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);\n        }\n\n        if (debug > 1) { console.timeEnd('clipping'); }\n\n        if (tl) { stack.push(tl, z + 1, x * 2,     y * 2); }\n        if (bl) { stack.push(bl, z + 1, x * 2,     y * 2 + 1); }\n        if (tr) { stack.push(tr, z + 1, x * 2 + 1, y * 2); }\n        if (br) { stack.push(br, z + 1, x * 2 + 1, y * 2 + 1); }\n    }\n\n    return solid;\n};\n\nGeoJSONVT.prototype.getTile = function (z, x, y) {\n    var this$1 = this;\n\n    var options = this.options,\n        extent = options.extent,\n        debug = options.debug;\n\n    var z2 = 1 << z;\n    x = ((x % z2) + z2) % z2; // wrap tile x coordinate\n\n    var id = toID(z, x, y);\n    if (this.tiles[id]) { return transform.tile(this.tiles[id], extent); }\n\n    if (debug > 1) { console.log('drilling down to z%d-%d-%d', z, x, y); }\n\n    var z0 = z,\n        x0 = x,\n        y0 = y,\n        parent;\n\n    while (!parent && z0 > 0) {\n        z0--;\n        x0 = Math.floor(x0 / 2);\n        y0 = Math.floor(y0 / 2);\n        parent = this$1.tiles[toID(z0, x0, y0)];\n    }\n\n    if (!parent || !parent.source) { return null; }\n\n    // if we found a parent tile containing the original geometry, we can drill down from it\n    if (debug > 1) { console.log('found parent tile z%d-%d-%d', z0, x0, y0); }\n\n    // it parent tile is a solid clipped square, return it instead since it's identical\n    if (isClippedSquare(parent, extent, options.buffer)) { return transform.tile(parent, extent); }\n\n    if (debug > 1) { console.time('drilling down'); }\n    var solid = this.splitTile(parent.source, z0, x0, y0, z, x, y);\n    if (debug > 1) { console.timeEnd('drilling down'); }\n\n    // one of the parent tiles was a solid clipped square\n    if (solid !== null) {\n        var m = 1 << (z - solid);\n        id = toID(solid, Math.floor(x / m), Math.floor(y / m));\n    }\n\n    return this.tiles[id] ? transform.tile(this.tiles[id], extent) : null;\n};\n\nfunction toID(z, x, y) {\n    return (((1 << z) * y + x) * 32) + z;\n}\n\nfunction intersectX(a, b, x) {\n    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];\n}\nfunction intersectY(a, b, y) {\n    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];\n}\n\nfunction extend(dest, src) {\n    for (var i in src) { dest[i] = src[i]; }\n    return dest;\n}\n\n// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further\nfunction isClippedSquare(tile, extent, buffer) {\n\n    var features = tile.source;\n    if (features.length !== 1) { return false; }\n\n    var feature = features[0];\n    if (feature.type !== 3 || feature.geometry.length > 1) { return false; }\n\n    var len = feature.geometry[0].length;\n    if (len !== 5) { return false; }\n\n    for (var i = 0; i < len; i++) {\n        var p = transform.point(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);\n        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||\n            (p[1] !== -buffer && p[1] !== extent + buffer)) { return false; }\n    }\n\n    return true;\n}\n\nvar identity = function(x) {\n  return x;\n};\n\nvar transform$3 = function(topology) {\n  if ((transform = topology.transform) == null) { return identity; }\n  var transform,\n      x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(point, i) {\n    if (!i) { x0 = y0 = 0; }\n    point[0] = (x0 += point[0]) * kx + dx;\n    point[1] = (y0 += point[1]) * ky + dy;\n    return point;\n  };\n};\n\nvar bbox = function(topology) {\n  var bbox = topology.bbox;\n\n  function bboxPoint(p0) {\n    p1[0] = p0[0], p1[1] = p0[1], t(p1);\n    if (p1[0] < x0) { x0 = p1[0]; }\n    if (p1[0] > x1) { x1 = p1[0]; }\n    if (p1[1] < y0) { y0 = p1[1]; }\n    if (p1[1] > y1) { y1 = p1[1]; }\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  if (!bbox) {\n    var t = transform$3(topology), p0, p1 = new Array(2), name,\n        x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n    topology.arcs.forEach(function(arc) {\n      var i = -1, n = arc.length;\n      while (++i < n) {\n        p0 = arc[i], p1[0] = p0[0], p1[1] = p0[1], t(p1, i);\n        if (p1[0] < x0) { x0 = p1[0]; }\n        if (p1[0] > x1) { x1 = p1[0]; }\n        if (p1[1] < y0) { y0 = p1[1]; }\n        if (p1[1] > y1) { y1 = p1[1]; }\n      }\n    });\n\n    for (name in topology.objects) {\n      bboxGeometry(topology.objects[name]);\n    }\n\n    bbox = topology.bbox = [x0, y0, x1, y1];\n  }\n\n  return bbox;\n};\n\nvar reverse = function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) { t = array[i], array[i++] = array[j], array[j] = t; }\n};\n\nvar feature = function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature$1(topology, o); })}\n      : feature$1(topology, o);\n};\n\nfunction feature$1(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nfunction object(topology, o) {\n  var transformPoint = transform$3(topology),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) { points.pop(); }\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k].slice(), k));\n    }\n    if (i < 0) { reverse(points, n); }\n  }\n\n  function point(p) {\n    return transformPoint(p.slice());\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) { arc(arcs[i], points); }\n    if (points.length < 2) { points.push(points[0].slice()); }\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) { points.push(points[0].slice()); }\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n\nvar stitch = function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) { p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; }); }\n    else { p1 = arc[arc.length - 1]; }\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) { fragments.push([i]); } });\n\n  return fragments;\n};\n\nfunction extractArcs(topology, object$$1, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object$$1);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) { arcs.push(geoms[0].i); } });\n\n  return arcs;\n}\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) { a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0]; }\n  return Math.abs(area); // Note: doubled area!\n}\n\nvar bisect = function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n};\n\nvar slicers = {};\nvar options;\n\nonmessage = function (e) {\n	if (e.data[0] === 'slice') {\n		// Given a blob of GeoJSON and some topojson/geojson-vt options, do the slicing.\n		var geojson = e.data[1];\n		options     = e.data[2];\n\n		if (geojson.type && geojson.type === 'Topology') {\n			for (var layerName in geojson.objects) {\n				slicers[layerName] = index(\n					feature(geojson, geojson.objects[layerName])\n				, options);\n			}\n		} else {\n			slicers[options.vectorTileLayerName] = index(geojson, options);\n		}\n\n	} else if (e.data[0] === 'get') {\n		// Gets the vector tile for the given coordinates, sends it back as a message\n		var coords = e.data[1];\n\n		var tileLayers = {};\n		for (var layerName in slicers) {\n			var slicedTileLayer = slicers[layerName].getTile(coords.z, coords.x, coords.y);\n\n			if (slicedTileLayer) {\n				var vectorTileLayer = {\n					features: [],\n					extent: options.extent,\n					name: options.vectorTileLayerName,\n					length: slicedTileLayer.features.length\n				};\n\n				for (var i in slicedTileLayer.features) {\n					var feat = {\n						geometry: slicedTileLayer.features[i].geometry,\n						properties: slicedTileLayer.features[i].tags,\n						type: slicedTileLayer.features[i].type	// 1 = point, 2 = line, 3 = polygon\n					};\n					vectorTileLayer.features.push(feat);\n				}\n				tileLayers[layerName] = vectorTileLayer;\n			}\n		}\n		postMessage({ layers: tileLayers, coords: coords });\n	}\n};\n//# sourceMap" + "pingURL=slicerWebWorker.js.worker.map\n", "text/plain; charset=us-ascii", false);

// The geojson/topojson is sliced into tiles via a web worker.
// This import statement depends on rollup-file-as-blob, so that the
// variable 'workerCode' is a blob URL.

/*
 * 🍂class VectorGrid.Slicer
 * 🍂extends VectorGrid
 *
 * A `VectorGrid` for slicing up big GeoJSON or TopoJSON documents in vector
 * tiles, leveraging [`geojson-vt`](https://github.com/mapbox/geojson-vt).
 *
 * 🍂example
 *
 * ```
 * var geoJsonDocument = {
 * 	type: 'FeatureCollection',
 * 	features: [ ... ]
 * };
 *
 * L.vectorGrid.slicer(geoJsonDocument, {
 * 	vectorTileLayerStyles: {
 * 		sliced: { ... }
 * 	}
 * }).addTo(map);
 *
 * ```
 *
 * `VectorGrid.Slicer` can also handle [TopoJSON](https://github.com/mbostock/topojson) transparently:
 * ```js
 * var layer = L.vectorGrid.slicer(topojson, options);
 * ```
 *
 * The TopoJSON format [implicitly groups features into "objects"](https://github.com/mbostock/topojson-specification/blob/master/README.md#215-objects).
 * These will be transformed into vector tile layer names when styling (the
 * `vectorTileLayerName` option is ignored when using TopoJSON).
 *
 */

L.VectorGrid.Slicer = L.VectorGrid.extend({

	options: {
		// 🍂section
		// Additionally to these options, `VectorGrid.Slicer` can take in any
		// of the [`geojson-vt` options](https://github.com/mapbox/geojson-vt#options).

		// 🍂option vectorTileLayerName: String = 'sliced'
		// Vector tiles contain a set of *data layers*, and those data layers
		// contain features. Thus, the slicer creates one data layer, with
		// the name given in this option. This is important for symbolizing the data.
		vectorTileLayerName: 'sliced',

		extent: 4096,	// Default for geojson-vt
		maxZoom: 14  	// Default for geojson-vt
	},

	initialize: function(geojson, options) {
		L.VectorGrid.prototype.initialize.call(this, options);

		// Create a shallow copy of this.options, excluding things that might
		// be functions - we only care about topojson/geojsonvt options
		var options = {};
		for (var i in this.options) {
			if (i !== 'rendererFactory' &&
				i !== 'vectorTileLayerStyles' &&
				typeof (this.options[i]) !== 'function'
			) {
				options[i] = this.options[i];
			}
		}

// 		this._worker = new Worker(window.URL.createObjectURL(new Blob([workerCode])));
		this._worker = new Worker(workerCode);

		// Send initial data to worker.
		this._worker.postMessage(['slice', geojson, options]);

	},


	_getVectorTilePromise: function(coords) {

		var _this = this;

		var p = new Promise( function waitForWorker(res) {
			_this._worker.addEventListener('message', function recv(m) {
				if (m.data.coords &&
				    m.data.coords.x === coords.x &&
				    m.data.coords.y === coords.y &&
				    m.data.coords.z === coords.z ) {

					res(m.data);
					_this._worker.removeEventListener('message', recv);
				}
			});
		});

		this._worker.postMessage(['get', coords]);

		return p;
	},

});


L.vectorGrid.slicer = function (geojson, options) {
	return new L.VectorGrid.Slicer(geojson, options);
};

L.Canvas.Tile = L.Canvas.extend({

	initialize: function (tileCoord, tileSize, options) {
		L.Canvas.prototype.initialize.call(this, options);
		this._tileCoord = tileCoord;
		this._size = tileSize;

		this._initContainer();
		this._container.setAttribute('width', this._size.x);
		this._container.setAttribute('height', this._size.y);
		this._layers = {};
		this._drawnLayers = {};
		this._drawing = true;

		if (options.interactive) {
			// By default, Leaflet tiles do not have pointer events
			this._container.style.pointerEvents = 'auto';
		}
	},

	getCoord: function() {
		return this._tileCoord;
	},

	getContainer: function() {
		return this._container;
	},

	getOffset: function() {
		return this._tileCoord.scaleBy(this._size).subtract(this._map.getPixelOrigin());
	},

	onAdd: L.Util.falseFn,

	addTo: function(map) {
		this._map = map;
	},

	removeFrom: function (map) {
		delete this._map;
	},

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e).subtract(this.getOffset()), layer, clickedLayer;

		for (var id in this._layers) {
			layer = this._layers[id];
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				clickedLayer = layer;
			}
		}
		if (clickedLayer)  {
			L.DomEvent.fakeStop(e);
			this._fireEvent([clickedLayer], e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e).subtract(this.getOffset());
		this._handleMouseHover(e, point);
	},

	/// TODO: Modify _initPath to include an extra parameter, a group name
	/// to order symbolizers by z-index

	_updateIcon: function (layer) {
		if (!this._drawing) { return; }

		var icon = layer.options.icon,
		    options = icon.options,
		    size = L.point(options.iconSize),
		    anchor = options.iconAnchor ||
		        	 size && size.divideBy(2, true),
		    p = layer._point.subtract(anchor),
		    ctx = this._ctx,
		    img = layer._getImage();

		if (img.complete) {
			ctx.drawImage(img, p.x, p.y, size.x, size.y);
		} else {
			L.DomEvent.on(img, 'load', function() {
				ctx.drawImage(img, p.x, p.y, size.x, size.y);
			});
		}

		this._drawnLayers[layer._leaflet_id] = layer;
	}
});


L.canvas.tile = function(tileCoord, tileSize, opts){
	return new L.Canvas.Tile(tileCoord, tileSize, opts);
};

// Aux file to bundle everything together, including the optional dependencies
// for protobuf tiles

}());
//# sourceMappingURL=Leaflet.VectorGrid.bundled.js.map



/** 
* @targomo/core "0.2.14" http://targomo.com
* The JavaScript (& TypeScript) API for Targomo's time-based access mapping services.
* (c) 2019 Targomo
*/
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(t.tgm={})}(this,function(l){"use strict";!function(t){if(!t.fetch){var e="URLSearchParams"in t,i="Symbol"in t&&"iterator"in Symbol,o="FileReader"in t&&"Blob"in t&&function(){try{return new Blob,!0}catch(t){return!1}}(),n="FormData"in t,r="ArrayBuffer"in t;if(r)var s=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],a=function(t){return t&&DataView.prototype.isPrototypeOf(t)},c=ArrayBuffer.isView||function(t){return t&&-1<s.indexOf(Object.prototype.toString.call(t))};d.prototype.append=function(t,e){t=h(t),e=f(e);var i=this.map[t];this.map[t]=i?i+","+e:e},d.prototype.delete=function(t){delete this.map[h(t)]},d.prototype.get=function(t){return t=h(t),this.has(t)?this.map[t]:null},d.prototype.has=function(t){return this.map.hasOwnProperty(h(t))},d.prototype.set=function(t,e){this.map[h(t)]=f(e)},d.prototype.forEach=function(t,e){for(var i in this.map)this.map.hasOwnProperty(i)&&t.call(e,this.map[i],i,this)},d.prototype.keys=function(){var i=[];return this.forEach(function(t,e){i.push(e)}),p(i)},d.prototype.values=function(){var e=[];return this.forEach(function(t){e.push(t)}),p(e)},d.prototype.entries=function(){var i=[];return this.forEach(function(t,e){i.push([e,t])}),p(i)},i&&(d.prototype[Symbol.iterator]=d.prototype.entries);var u=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];S.prototype.clone=function(){return new S(this,{body:this._bodyInit})},b.call(S.prototype),b.call(w.prototype),w.prototype.clone=function(){return new w(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new d(this.headers),url:this.url})},w.error=function(){var t=new w(null,{status:0,statusText:""});return t.type="error",t};var l=[301,302,303,307,308];w.redirect=function(t,e){if(-1===l.indexOf(e))throw new RangeError("Invalid status code");return new w(null,{status:e,headers:{location:t}})},t.Headers=d,t.Request=S,t.Response=w,t.fetch=function(i,r){return new Promise(function(n,t){var e=new S(i,r),s=new XMLHttpRequest;s.onload=function(){var t,r,e={status:s.status,statusText:s.statusText,headers:(t=s.getAllResponseHeaders()||"",r=new d,t.replace(/\r?\n[\t ]+/g," ").split(/\r?\n/).forEach(function(t){var e=t.split(":"),i=e.shift().trim();if(i){var n=e.join(":").trim();r.append(i,n)}}),r)};e.url="responseURL"in s?s.responseURL:e.headers.get("X-Request-URL");var i="response"in s?s.response:s.responseText;n(new w(i,e))},s.onerror=function(){t(new TypeError("Network request failed"))},s.ontimeout=function(){t(new TypeError("Network request failed"))},s.open(e.method,e.url,!0),"include"===e.credentials?s.withCredentials=!0:"omit"===e.credentials&&(s.withCredentials=!1),"responseType"in s&&o&&(s.responseType="blob"),e.headers.forEach(function(t,e){s.setRequestHeader(e,t)}),s.send(void 0===e._bodyInit?null:e._bodyInit)})},t.fetch.polyfill=!0}function h(t){if("string"!=typeof t&&(t=String(t)),/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(t))throw new TypeError("Invalid character in header field name");return t.toLowerCase()}function f(t){return"string"!=typeof t&&(t=String(t)),t}function p(e){var t={next:function(){var t=e.shift();return{done:void 0===t,value:t}}};return i&&(t[Symbol.iterator]=function(){return t}),t}function d(e){this.map={},e instanceof d?e.forEach(function(t,e){this.append(e,t)},this):Array.isArray(e)?e.forEach(function(t){this.append(t[0],t[1])},this):e&&Object.getOwnPropertyNames(e).forEach(function(t){this.append(t,e[t])},this)}function g(t){if(t.bodyUsed)return Promise.reject(new TypeError("Already read"));t.bodyUsed=!0}function m(i){return new Promise(function(t,e){i.onload=function(){t(i.result)},i.onerror=function(){e(i.error)}})}function v(t){var e=new FileReader,i=m(e);return e.readAsArrayBuffer(t),i}function y(t){if(t.slice)return t.slice(0);var e=new Uint8Array(t.byteLength);return e.set(new Uint8Array(t)),e.buffer}function b(){return this.bodyUsed=!1,this._initBody=function(t){if(this._bodyInit=t)if("string"==typeof t)this._bodyText=t;else if(o&&Blob.prototype.isPrototypeOf(t))this._bodyBlob=t;else if(n&&FormData.prototype.isPrototypeOf(t))this._bodyFormData=t;else if(e&&URLSearchParams.prototype.isPrototypeOf(t))this._bodyText=t.toString();else if(r&&o&&a(t))this._bodyArrayBuffer=y(t.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer]);else{if(!r||!ArrayBuffer.prototype.isPrototypeOf(t)&&!c(t))throw new Error("unsupported BodyInit type");this._bodyArrayBuffer=y(t)}else this._bodyText="";this.headers.get("content-type")||("string"==typeof t?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):e&&URLSearchParams.prototype.isPrototypeOf(t)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"))},o&&(this.blob=function(){var t=g(this);if(t)return t;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?g(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(v)}),this.text=function(){var t,e,i,n=g(this);if(n)return n;if(this._bodyBlob)return t=this._bodyBlob,e=new FileReader,i=m(e),e.readAsText(t),i;if(this._bodyArrayBuffer)return Promise.resolve(function(t){for(var e=new Uint8Array(t),i=new Array(e.length),n=0;n<e.length;n++)i[n]=String.fromCharCode(e[n]);return i.join("")}(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},n&&(this.formData=function(){return this.text().then(T)}),this.json=function(){return this.text().then(JSON.parse)},this}function S(t,e){var i,n,r=(e=e||{}).body;if(t instanceof S){if(t.bodyUsed)throw new TypeError("Already read");this.url=t.url,this.credentials=t.credentials,e.headers||(this.headers=new d(t.headers)),this.method=t.method,this.mode=t.mode,r||null==t._bodyInit||(r=t._bodyInit,t.bodyUsed=!0)}else this.url=String(t);if(this.credentials=e.credentials||this.credentials||"omit",!e.headers&&this.headers||(this.headers=new d(e.headers)),this.method=(i=e.method||this.method||"GET",n=i.toUpperCase(),-1<u.indexOf(n)?n:i),this.mode=e.mode||this.mode||null,this.referrer=null,("GET"===this.method||"HEAD"===this.method)&&r)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(r)}function T(t){var r=new FormData;return t.trim().split("&").forEach(function(t){if(t){var e=t.split("="),i=e.shift().replace(/\+/g," "),n=e.join("=").replace(/\+/g," ");r.append(decodeURIComponent(i),decodeURIComponent(n))}}),r}function w(t,e){e||(e={}),this.type="default",this.status=void 0===e.status?200:e.status,this.ok=200<=this.status&&this.status<300,this.statusText="statusText"in e?e.statusText:"OK",this.headers=new d(e.headers),this.url=e.url||"",this._initBody(t)}}("undefined"!=typeof self?self:window);var n=function(t){this.serverUrl="https://api.targomo.com/",this.statisticsUrl="https://api.targomo.com/statistics/",this.tilesUrl="https://api.targomo.com/vector-statistics/",this.poiUrl="https://api.targomo.com/pointofinterest/",this.mapTilesUrl="https://maps.targomo.com/",this.photonGeocoderUrl="https://api.targomo.com/geocode/",this.overpassUrl="https://api.targomo.com/overpass/",this.fleetsUrl="https://api.targomo.com/fleetplanner/",this.basemapsUrl="https://maps.targomo.com/styles/",this.version=1,this.debug=!1,Object.assign(this,t)},r=function(t,e){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)};function i(t,e){function i(){this.constructor=t}r(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}var s=function(){return(s=Object.assign||function(t){for(var e,i=1,n=arguments.length;i<n;i++)for(var r in e=arguments[i])Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t}).apply(this,arguments)};function h(s,o,a,c){return new(a||(a=Promise))(function(t,e){function i(t){try{r(c.next(t))}catch(t){e(t)}}function n(t){try{r(c.throw(t))}catch(t){e(t)}}function r(e){e.done?t(e.value):new a(function(t){t(e.value)}).then(i,n)}r((c=c.apply(s,o||[])).next())})}function y(i,n){var r,s,o,t,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return t={next:e(0),throw:e(1),return:e(2)},"function"==typeof Symbol&&(t[Symbol.iterator]=function(){return this}),t;function e(e){return function(t){return function(e){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,s&&(o=2&e[0]?s.return:e[0]?s.throw||((o=s.return)&&o.call(s),0):s.next)&&!(o=o.call(s,e[1])).done)return o;switch(s=0,o&&(e=[2&e[0],o.value]),e[0]){case 0:case 1:o=e;break;case 4:return a.label++,{value:e[1],done:!1};case 5:a.label++,s=e[1],e=[0];continue;case 7:e=a.ops.pop(),a.trys.pop();continue;default:if(!(o=0<(o=a.trys).length&&o[o.length-1])&&(6===e[0]||2===e[0])){a=0;continue}if(3===e[0]&&(!o||e[1]>o[0]&&e[1]<o[3])){a.label=e[1];break}if(6===e[0]&&a.label<o[1]){a.label=o[1],o=e;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(e);break}o[2]&&a.ops.pop(),a.trys.pop();continue}e=n.call(i,a)}catch(t){e=[6,t],s=0}finally{r=o=0}if(5&e[0])throw e[1];return{value:e[0]?e[1]:void 0,done:!0}}([e,t])}}}var c=function(t,e,i,n){this.value=t,this.key=e,this.previous=i,this.next=n},e=function(){function t(t){void 0===t&&(t=0),this.capacity=t,this.map={},this.size=0}return t.prototype.get=function(o,a){return h(this,void 0,void 0,function(){var e,i,n,r,s;return y(this,function(t){switch(t.label){case 0:if(void 0===(e=this.map[o]))return[3,5];this.oldest==e&&e.next&&(this.oldest=e.next),e.next&&(e.next.previous=e.previous),e.previous&&(e.previous.next=e.next),e.previous=this.newest,e.next=null,this.newest=e,t.label=1;case 1:return t.trys.push([1,3,,4]),[4,e.value];case 2:return[2,t.sent()];case 3:return t.sent(),this.map[o]=void 0,[2,this.get(o,a)];case 4:return[3,8];case 5:return a?(i=a(),n=this.map[o]=new c(i,o,this.newest,null),[4,i]):[3,7];case 6:return r=t.sent(),this.newest&&(this.newest.next=n),this.newest=n,this.capacity&&(this.size>=this.capacity?(s=this.oldest)&&(this.oldest=s.next,delete this.map[s.key]):this.size++),this.oldest||(this.oldest=this.newest),[2,r];case 7:return[2,void 0];case 8:return[2]}})})},t}(),t=function(){function t(){this.map={}}return t.prototype.get=function(n,r){return h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return e="string"==typeof n?n:JSON.stringify(n),null==this.map[e]?[3,1]:[2,this.map[e]];case 1:return[4,r()];case 2:return i=t.sent(),[2,this.map[e]=i]}})})},t}(),a=new t;function b(t){t instanceof String||"string"==typeof t?console.log(t):console.log(JSON.stringify(t,null,2))}var o=function(){function t(t){this.options=t}return t.prototype.fetch=function(d,g,m,v){return void 0===g&&(g="GET"),void 0===v&&(v={}),h(this,void 0,void 0,function(){var e,i,n,r,s,o,a,c,u,l,h,f,p;return y(this,function(t){switch(t.label){case 0:return"JSONP"!==(e=g)?v.Accept=v.Accept?v.Accept:"application/json":e="GET","POST-RAW"===g&&(e="POST"),"PUT"!==e&&"POST"!==e||(v["Content-Type"]="application/json"),i=new Headers(v),n={method:e,headers:i},"POST-RAW"===g?n.body=m:"GET"!==g&&"JSONP"!==g&&(n.body=JSON.stringify(m)),[4,fetch(d,n)];case 1:return r=t.sent(),(this.options&&this.options.debug||400<=r.status)&&(console.log("[TargomoClient Begin]"),console.log("[Request]",n.method,d),console.log("  [Headers]"),i.forEach(function(t,e){console.log("    "+e+" = "+t)}),n.body&&(console.log("  [Body]"),console.log(n.body)),console.log("[Response]"),console.log("    status = ",r.status),console.log("    statusText = ",r.statusText),console.log("  [Headers]"),r.headers.forEach(function(t,e){console.log("    "+e+" = "+t)})),400<=r.status?(console.log("  [Body]"),"application/json"!==r.headers.get("content-type")?[3,3]:(c=(a=JSON).stringify,[4,r.text()])):[3,6];case 2:return o=c.apply(a,[t.sent(),null,2]),[3,5];case 3:return[4,r.text()];case 4:o=t.sent(),t.label=5;case 5:throw b(s=o),console.log("[TargomoClient End]"),new Error(s);case 6:return u=null,"JSONP"!==g?[3,8]:[4,r.text()];case 7:return l=t.sent(),h=l.indexOf("("),f=l.lastIndexOf(")"),u=-1<h&&-1<f?JSON.parse(l.substring(h+1,f)):JSON.parse(l),[3,9];case 8:u=r.json(),t.label=9;case 9:return this.options&&this.options.debug?(console.log("  [Body]"),p=b,[4,u]):[3,11];case 10:p.apply(void 0,[t.sent()]),console.log("[TargomoClient End]"),t.label=11;case 11:return[2,u]}})})},t.prototype.fetchData=function(i,n,r,s){return void 0===n&&(n="GET"),h(this,void 0,void 0,function(){var e;return y(this,function(t){switch(t.label){case 0:return[4,this.fetch(i,n,r,s)];case 1:return(e=t.sent()).data?[2,e.data]:(console.warn("No data object was transmitted by "+i+" \nReturning raw response"),[2,e])}})})},t.prototype.fetchCached=function(t,e,i,n,r){var s=this;if(void 0===i&&(i="GET"),!1===t)return this.fetch(e,i,n,r);!0!==t&&t||(t=a);var o=JSON.stringify({url:e,method:i,payload:n});return t.get(o,function(){return s.fetch(e,i,n,r)})},t.prototype.fetchCachedData=function(t,e,i,n,r){var s=this;if(void 0===i&&(i="GET"),!1===t)return this.fetchData(e,i,n,r);!0!==t&&t||(t=a);var o=JSON.stringify({url:e,method:i,payload:n});return t.get(o,function(){return s.fetchData(e,i,n,r)})},t}();function f(t,e){return new o({debug:t&&t.config&&t.config.debug})}var u,p,d=function(){function t(t){this.client=t}return t.prototype.fetch=function(r,s,o){return h(this,void 0,void 0,function(){var e,i,n;return y(this,function(t){switch(t.label){case 0:return e={west:o.southWest.lng,south:o.southWest.lat,east:o.northEast.lng,north:o.northEast.lat},i={bounds:e,benchmarks:s.map(function(t){return{source:t.source,minEnd:t.minEnd,minStart:t.minStart,factor:t.factor}})},n=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.tilesUrl).part("benchmarks/scores_cumulative/").version().part("/"+encodeURIComponent(""+r)).key().toString(),[4,f(this.client).fetch(n,"POST",i)];case 1:return[2,t.sent()]}})})},t.prototype.metadata=function(i){return h(this,void 0,void 0,function(){var e;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.tilesUrl).part("benchmarks/meta/").version().part("/"+encodeURIComponent(""+i)).key().toString(),[4,f(this.client).fetch(e)];case 1:return[2,t.sent()]}})})},t}();u=l.UrlUtil||(l.UrlUtil={}),p=function(){function t(t){this.client=t,this.url="",this.firstParamPlaced=!1}return t.prototype.host=function(t){return 0===this.url.length&&"/"!==t[t.length-1]&&(t+="/"),this.part(t)},t.prototype.part=function(t){return this.url+=t,this},t.prototype.version=function(){return null!==this.client.config.version&&void 0!==this.client.config.version?this.part("v"+this.client.config.version):"/"===this.url[this.url.length-1]&&(this.url=this.url.substr(0,this.url.length-1)),this},t.prototype.params=function(t){var i=this;return Object.keys(t).forEach(function(e){t[e]instanceof Array?t[e].forEach(function(t){i.param(e,t)}):i.param(e,t[e])}),this},t.prototype.param=function(t,e){this.firstParamPlaced?this.url+="&"+t+"="+e:(this.firstParamPlaced=!0,this.url+="?"+t+"="+e)},t.prototype.key=function(){return this.params({key:this.client.serviceKey})},t.prototype.toString=function(){return this.url},t}(),u.TargomoUrl=p;var g=function(){function t(){}return t.prototype.geocode=function(r,s,t,o,a){return h(this,void 0,void 0,function(){var e,i,n;return y(this,function(t){switch(t.label){case 0:return e={singleLine:r,f:"json",countryCode:o,maxLocations:5},s&&(e.location=s.lng+","+s.lat),a&&(e.magicKey=a),i=(new l.UrlUtil.TargomoUrl).part("https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates").params(e).toString(),[4,f().fetch(i)];case 1:return n=t.sent(),[2,n.candidates.map(function(t){return{lat:t.location.y,lng:t.location.x,description:t.address}})]}})})},t.prototype.suggest=function(n,r,t,s,o){return void 0===o&&(o=5),h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return e={text:n,f:"json",countryCode:s,maxSuggestions:o},r&&(e.location=r.lng+","+r.lat),i=(new l.UrlUtil.TargomoUrl).part("https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/suggest").params(e).toString(),[4,f().fetch(i)];case 1:return[2,t.sent().suggestions]}})})},t.prototype.reverseGeocode=function(r,t){return h(this,void 0,void 0,function(){var e,i,n;return y(this,function(t){switch(t.label){case 0:return(e={f:"json"}).location=r.lng+","+r.lat,i=(new l.UrlUtil.TargomoUrl).part("https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode").params(e).toString(),[4,f().fetch(i)];case 1:return(n=t.sent())&&n.address?[2,{address:n.address.Match_addr,city:n.address.City,countryCode:n.address.CountryCode,location:n.address.Loc_name,region:n.address.Region,subregion:n.address.Subregion,zip:n.address.Postal}]:[2,{}]}})})},t}(),m=function(){function t(t){this.client=t}return t.prototype.geocode=function(r,s,o){return h(this,void 0,void 0,function(){var e,i,n=this;return y(this,function(t){switch(t.label){case 0:return e=(new l.UrlUtil.TargomoUrl).host(this.client.config.photonGeocoderUrl).part("api").params({q:encodeURIComponent(r),limit:5}).toString(),s&&(e+="&lat="+s.lat+"&lon="+s.lng),o&&(e+="&lang="+encodeURIComponent(o)),[4,f().fetch(e)];case 1:return(i=t.sent()).features.forEach(function(t,e,i){"boundary"==t.properties.osm_key&&i.splice(e,1)}),[2,i.features.map(function(t){return t.value=t.properties.osm_id,t.description=n.buildPlaceDescription(t.properties),t})]}})})},t.prototype.buildPlaceDescription=function(i){var n=function(t,e){return void 0===e&&(e=" "),t.filter(function(t){return!!t}).join(e).trim()},t=function(t,e){return n(t.map(function(t){return i[t]}),e)},e=t(["street","housenumber"]," "),r=n([t(["postcode","city"]," "),i.country],", "),s={title:"",meta1:"",meta2:"",full:""};return void 0!==i.name?(s.title=i.name,s.meta1=e,s.meta2=r):(s.title=e,s.meta1=r),i.name!==e&&(s.full=s.title),s.meta1&&i.name!==e&&(s.full+=", "+s.meta1),s.meta1&&i.name===e&&(s.full+=s.meta1),s.full=n([s.full,s.meta2],", "),s},t}(),v=function(){},S=function(){this.edgeWeight="time"},T=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.transitFrameDuration=void 0,t.transitFrameDate=20170801,t.transitFrameTime=39600,t.transitMaxTransfers=-1,t.transitAvoidTransitRouteTypes=[],t.walkSpeed={},t.bikeSpeed={},t}return i(t,e),t}(S),w=function(s){function t(t){var e=s.call(this)||this;if(Object.assign(e,t),null!=t.transitFrameDateTime){var i=void 0,n=(i=t.transitFrameDateTime instanceof Date?t.transitFrameDateTime:new Date(t.transitFrameDateTime))?1e4*i.getFullYear()+100*(i.getMonth()+1)+i.getDate():void 0,r=i?3600*i.getHours()+60*i.getMinutes():void 0;e.transitFrameDate=n||e.transitFrameDate,e.transitFrameTime=r||e.transitFrameTime}return e}return i(t,s),t.prototype.buildTargetsCfg=function(t){return t.map(function(t){return{lat:t.lat,lng:t.lng,id:t.id}})},t.prototype.buildSourcesCfg=function(t){var i=this;return t.map(function(t){var e={lat:t.lat,lng:t.lng,id:t.id,tm:t.tm};if(!e.tm)switch(i.travelType){case"car":e.tm={car:i.rushHour?{rushHour:i.rushHour}:{}};break;case"walk":e.tm={walk:i.walkSpeed};break;case"bike":e.tm={bike:i.bikeSpeed};break;case"transit":e.tm={transit:{frame:{date:i.transitFrameDate,time:i.transitFrameTime,duration:i.transitFrameDuration},maxTransfers:i.transitMaxTransfers}}}return e})},t}(T),U=function(r){function t(t,e,i){var n=r.call(this,e)||this;return n.sources=n.buildSourcesCfg(t),i&&(n.targets=n.buildTargetsCfg(i)),n.multigraph=e.multigraph,n}return i(t,r),t}(w),E=function(){function t(t){this.client=t}return t.prototype.fetch=function(n,r,s){return h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).part(this.client.serviceUrl).version().part("/multigraph").key().toString(),i=new U(n,r,s),[4,f(this.client).fetch(e,"POST",i)];case 1:return[2,t.sent()]}})})},t.prototype.fetchOverview=function(n,r,s){return h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).part(this.client.serviceUrl).version().part("/multigraph/overview").key().toString(),i=new U(n,r,s),[4,f(this.client).fetch(e,"POST",i)];case 1:return[2,t.sent()]}})})},t.prototype.getTiledMultigraphUrl=function(r,s,o,a){return h(this,void 0,void 0,function(){var e,i,n;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).part(this.client.serviceUrl).version().part("/objectcache/add").key().toString(),i=new U(r,s,a),[4,f(this.client).fetch(e,"POST",i)];case 1:return n=t.sent(),[2,new l.UrlUtil.TargomoUrl(this.client).part(this.client.serviceUrl).version().part("/multigraph/{z}/{x}/{y}."+o).key().params({cfgUuid:n.uuid}).toString()]}})})},t}(),x=function(t,e,i,n){this.description=n.description||"",this.serviceUrl=t,this.serviceKey=e,this.email=n.email||"developers@targomo.com",this.sendMail=!1,this.callbackUrl=n.callbackUrl||"https://localhost/",this.pointsPerSolution=n.pointsPerSolution,this.maxSolutions=n.maxSolutions||1,this.travelType=n.travelType,this.edgeWeight=n.edgeWeight,this.maxEdgeWeight=n.maxEdgeWeight,this.statisticGroupId=n.statisticGroup,n.statistic instanceof Number||"number"==typeof n.statistic?this.statisticId=+n.statistic:this.statisticId=n.statistic.id;var r={};i.forEach(function(t){r[t.id]={id:t.id,x:t.lng,y:t.lat}}),this.sources.push(r)},A=function(t){this.raw=t,this.id=t.id,this.maxPossibleValue=t.maxPossibleValue,this.solutions=t.simulationResults.map(function(t){var e={};return t.sourcePoints.forEach(function(t){e[t.id]=t.optimal}),{id:t.id,startTime:t.startTime,endTime:t.endTime,maxValue:t.maxValue,numberOfDesiredPoints:t.numberOfDesiredPoints,sources:e}})},C=function(){function t(t){this.client=t}return t.prototype.create=function(r,s){return h(this,void 0,void 0,function(){var e,i,n;return y(this,function(t){switch(t.label){case 0:return r.length?(e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.statisticsUrl).part("simulation/start/").key().params({serviceUrl:encodeURIComponent(this.client.serviceUrl)}).toString(),i=new x(this.client.serviceUrl,this.client.serviceKey,r,s),[4,f(this.client).fetch(e,"POST",i)]):[2,null];case 1:return[2,(n=t.sent())&&+n.id]}})})},t.prototype.ready=function(i){return h(this,void 0,void 0,function(){var e;return y(this,function(t){return i instanceof Array||(i=[i]),e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.statisticsUrl).part("simulation/ready/").key().params({serviceUrl:encodeURIComponent(this.client.serviceUrl),simulationId:i}).toString(),[2,f(this.client).fetch(e)]})})},t.prototype.fetch=function(n){return h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.statisticsUrl).part("simulation/"+n+"/").key().params({serviceUrl:encodeURIComponent(this.client.serviceUrl)}).toString(),i=A.bind,[4,f(this.client).fetch(e)];case 1:return[2,new(i.apply(A,[void 0,t.sent()]))]}})})},t}(),O=function(r){function t(t,e,i){var n=r.call(this,i)||this;return n.osmTypes=[],n.sources=n.buildSourcesCfg([e]),n.osmTypes=i.osmTypes,n.format=i.format,n.serviceKey=t.serviceKey,n.serviceUrl=t.serviceUrl,n}return i(t,r),t}(w),R=function(){function i(t,e,i,n){this.id=t,this.lng=e,this.lat=i,this.properties=n,this.properties&&(this.properties["marker-size"]=1)}return i.prototype.toString=function(){return this.properties?this.properties.name:""},i.prototype.copy=function(){var t=new i(this.id,this.lat,this.lng,s({},this.properties));for(var e in this)"properties"!=e&&(t[e]=this[e]);return t},i}();function _(t){var e=t.lat,i=t.lon;return void 0===e&&t.center&&(e=t.center.lat,i=t.center.lon),new R(t.id,i,e,t.tags)}var I,P=function(){function t(t){this.client=t}return t.prototype.queryRaw=function(e){return h(this,void 0,void 0,function(){return y(this,function(t){switch(t.label){case 0:return[4,f(this.client).fetch(this.client.config.overpassUrl+"/api/interpreter","POST-RAW",e)];case 1:return[2,t.sent().elements.filter(function(t){return!!t.tags}).map(function(t){return _(t)})]}})})},t.prototype.query=function(t,i){function n(t){if("*"===t.tag||null==t.tag)return'"'+t.type+'"';if(t.type&&t.tag)return'"'+t.type+'"="'+t.tag+'"';throw new Error("invalid query"+JSON.stringify(t))}var r=[];t.forEach(function(e){i.forEach(function(t){r.push("\n      way["+n(e)+"]\n        ("+t.southWest.lat+","+t.southWest.lng+","+t.northEast.lat+","+t.northEast.lng+");\n      node["+n(e)+"]\n        ("+t.southWest.lat+","+t.southWest.lng+","+t.northEast.lat+","+t.northEast.lng+");\n        ")})});var e="\n      [out:json];\n      (\n      "+r.join("")+"\n      );\n      out center;\n    ";return this.queryRaw(e)},t.prototype.queryGetCustom=function(e){return h(this,void 0,void 0,function(){return y(this,function(t){switch(t.label){case 0:return[4,f(this.client).fetch(e)];case 1:return[2,t.sent().elements.map(function(t){return _(t)})]}})})},t.prototype.reachable=function(i,n){return h(this,void 0,void 0,function(){var e;return y(this,function(t){switch(t.label){case 0:return e=this.client.config.poiUrl+"/reachability",[4,f(this.client).fetch(e,"POST",new O(this.client,i,n))];case 1:return[2,t.sent()]}})})},t}(),M=function(){},N=function(){};(I=l.StatisticsGroups||(l.StatisticsGroups={}))[I.GERMANY_ZENSUS_100M_STATISTICS=9]="GERMANY_ZENSUS_100M_STATISTICS",I[I.GERMANY_ZENSUS_200M_STATISTICS=2]="GERMANY_ZENSUS_200M_STATISTICS",I[I.GERMANY_ZENSUS_500M_STATISTICS=11]="GERMANY_ZENSUS_500M_STATISTICS",I[I.GERMANY_ZENSUS_1000M_STATISTICS=3]="GERMANY_ZENSUS_1000M_STATISTICS",I[I.GERMANY_ZENSUS_2000M_STATISTICS=10]="GERMANY_ZENSUS_2000M_STATISTICS",I[I.NORWAY_STATISTICS=4]="NORWAY_STATISTICS",I[I.CENSUS_BRANDENBURG_POPULATION=12]="CENSUS_BRANDENBURG_POPULATION",I[I.CANADA_BLOCK_STATISTICS=8]="CANADA_BLOCK_STATISTICS",I[I.CANADA_AREA_STATISTICS=5]="CANADA_AREA_STATISTICS",I[I.BERLIN_STATISTICS=6]="BERLIN_STATISTICS";var D,k,W,G=function(){},B=function(t){for(var e in this.values=t,this.total=0,this.values)this.total+=this.values[e]};(D=l.SRID||(l.SRID={}))[D.SRID_3857=3857]="SRID_3857",D[D.SRID_4326=4326]="SRID_4326",(k=l.MultigraphRequestAggregation||(l.MultigraphRequestAggregation={})).NONE="none",k.SUM="sum",k.MAX="max",k.MIN="min",k.MEAN="mean",k.MEDIAN="median",k.NEAREST="nearest",k.UNION="routing_union",(W=l.MultigraphRequestLayer||(l.MultigraphRequestLayer={})).EDGE="edge",W.NODE="node",W.TILE="tile",W.HEXAGON="hexagon",W.TILE_NODE="tile_node",W.HEXAGON_NODE="hexagon_node";var F=new(function(){function t(){this.R=6378137}return t.prototype.project=function(t){var e=Math.PI/180,i=Math.max(Math.min(Math.sin(t.lat*e),1-1e-15),-(1-1e-15));return{x:this.R*t.lng*e,y:this.R*Math.log((1+i)/(1-i))/2}},t.prototype.unproject=function(t){var e=180/Math.PI;return{lat:(2*Math.atan(Math.exp(t.y/this.R))-Math.PI/2)*e,lng:t.x*e/this.R}},t}()),j=6371.01,L=Math.PI/180;function H(t,e){var i=L*t.lat,n=L*t.lng,r=L*e.lat,s=L*e.lng;return Math.acos(Math.sin(i)*Math.sin(r)+Math.cos(i)*Math.cos(r)*Math.cos(n-s))*j}function z(t,e){e*=1e3;var i=t.lat,n=t.lng,r=i*L,s=e/1e3/110.574235,o=e/1e3/(110.572833*Math.cos(r));return{northEast:{lat:i+s,lng:n+o},southWest:{lat:i-s,lng:n-o}}}function q(t){switch(t.travelType){case"walk":return 10;case"bike":return 25;case"transit":return 150;default:return 120}}function K(t){return t.reduce(function(t,e){return t.northEast.lat=e.lat>t.northEast.lat?e.lat:t.northEast.lat,t.northEast.lng=e.lng>t.northEast.lng?e.lng:t.northEast.lng,t.southWest.lat=e.lat<t.southWest.lat?e.lat:t.southWest.lat,t.southWest.lng=e.lng<t.southWest.lng?e.lng:t.southWest.lng,t},{northEast:{lat:t[0].lat,lng:t[0].lng},southWest:{lat:t[0].lat,lng:t[0].lng}})}function V(t,i,e){return i instanceof Array?J(t,i,e).filter(function(e){return!i.some(function(t){return t==e})}):J(t,i,e).filter(function(t){return i!=t})}function J(t,i,n){return i instanceof Array?t.filter(function(e){return i.some(function(t){return H(e,t)<=n})}):t.filter(function(t){return H(t,i)<=n})}function Y(t,e){var i=F.unproject(t);return null!=e?{lat:i.lat,lng:i.lng,elevation:e}:i}var Z,X=Object.freeze({contains:function(t,e){return e.lat>=t.southWest.lat&&e.lat<=t.northEast.lat&&e.lng>=t.southWest.lng&&e.lng<=t.northEast.lng},calculateDistance:H,boundingBox:z,locationsWithinTravelOptions:function(t,e,i){var n,r=i.maxEdgeWeight;switch(i.travelType){case"walk":n=10;break;case"bike":n=25;break;case"transit":n=150;break;default:n=120}return V(t,e,"distance"===i.edgeWeight?Math.round(r/1e3):n*r/3600)},boundingBoxWithinTravelOptions:function(t,e){var i=e.maxEdgeWeight,n=q(e);return z(t,"distance"===e.edgeWeight?Math.round(i/1e3):n*i/3600)},boundingBoxFromLocationArray:K,boundingBoxListWithinTravelOptions:function(t,e){var i=e.maxEdgeWeight,n=q(e),r="distance"===e.edgeWeight?Math.round(i/1e3):n*i/3600,s={northEast:{lat:-1/0,lng:-1/0},southWest:{lat:1/0,lng:1/0}};return t.forEach(function(t){var e=z(t,r);s.northEast.lat=Math.max(s.northEast.lat,e.northEast.lat),s.northEast.lng=Math.max(s.northEast.lng,e.northEast.lng),s.southWest.lat=Math.min(s.southWest.lat,e.southWest.lat),s.southWest.lng=Math.min(s.southWest.lng,e.southWest.lng)}),s},locationsWithinDistance:V,locationsWithinDistanceInclusive:J,webMercatorToLatLng:Y,latLngToWebMercator:function(t){return F.project(t)}}),$=function(t,e){var i=this;this.points=[],this.type=e.type,this.travelTime=e.travelTime,this.distance=e.length/1e3,this.warning=e.warning,this.elevationGain=e.elevationGain,this.transitSegment=!1,this.startName=e.startname,this.endName=e.endname,e.points.forEach(function(t){i.points.push(Y({x:t[1],y:t[0]},t[2]))}),e.isTransit&&(this.transitSegment=!0,this.routeType=e.routeType,this.routeShortName=e.routeShortName,this.startName=e.startname,this.endName=e.endname,this.departureTime=e.departureTime,this.arrivalTime=e.arrivalTime,this.tripHeadSign=e.tripHeadSign)},Q=function(){function t(i,t,e,n){var r=this;this.travelTime=t,this.routeSegments=[],this.targetHeight=void 0,this.sourceHeight=void 0,this.sourceId=void 0,this.targetId=void 0,this.length=void 0;var s=0,o=[];e.reverse().forEach(function(t){var e=new $(i,t);r.routeSegments.push(e),"TRANSFER"===e.type&&s++,o=o.concat(e.points.reverse())}),this.points=o,this.transfers=s,void 0!==n&&(this.sourceId=n.source_id,this.targetId=n.target_id,this.length=n.length);var a=this.calculateElevationDifferences(this.points);this.targetHeight=a.targetHeight,this.sourceHeight=a.sourceHeight,this.uphillMeter=a.uphillMeter,this.downhillMeter=a.downhillMeter,this.totalElevationDifference=Math.abs(this.sourceHeight-this.targetHeight),this.departureTime=this.calculateDepartureTime(),this.arrivalTime=this.calculateArrivalTime(),this.distance=this.calculateDistance(),this.elevationGain=this.calculateElevationGain()}return t.prototype.calculateDistance=function(){for(var t=0,e=0;e<this.routeSegments.length;e++)t+=this.routeSegments[e].distance;return t},t.prototype.calculateElevationGain=function(){for(var t=void 0,e=0;e<this.routeSegments.length;e++)isFinite(this.routeSegments[e].elevationGain)&&(t=(t||0)+this.routeSegments[e].elevationGain);return t},t.prototype.calculateElevationDifferences=function(t){for(var e=void 0,i=void 0,n=void 0,r=0,s=0,o=this.points.length-1;0<=o;o--)0==o&&(i=this.points[o].elevation),o==this.points.length-1&&(n=this.points[o].elevation),void 0!==e&&(e>this.points[o].elevation?r+=e-this.points[o].elevation:e<this.points[o].elevation&&(s+=this.points[o].elevation-e)),e=this.points[o].elevation;return{targetHeight:i,sourceHeight:n,uphillMeter:r,downhillMeter:s}},t.prototype.calculateDepartureTime=function(){for(var t=0,e=0;e<this.routeSegments.length;e++){var i=this.routeSegments[e];if(null!=i.departureTime)return i.departureTime-t;t+=i.travelTime||0}},t.prototype.calculateArrivalTime=function(){for(var t=0,e=this.routeSegments.length-1;0<=e;e--){var i=this.routeSegments[e];if(null!=i.arrivalTime)return i.arrivalTime-t;t+=i.travelTime||0}},t}(),tt=function(t,s){function e(t){for(var e={},i=0,n=s;i<n.length;i++){var r=n[i];e[r.name]=new B(t[r.id])}return e}var i={};if(t.individualStatistics)for(var n in t.individualStatistics)t.individualStatistics[n]&&t.individualStatistics[n].statistics&&(i[n]=e(t.individualStatistics[n].statistics));this.statistics=e(t.statistics),this.individualStatistics=i,this.raw=t};(Z=l.MultigraphStatus||(l.MultigraphStatus={})).CREATED="CREATED",Z.ROUTING="ROUTING",Z.MERGING="MERGING",Z.AGGREGATING="AGGREGATING",Z.COMPLETED="COMPLETED",Z.FAILED="FAILED";var et=function(){},it=function(t,e){this.values={};var i={};e.forEach(function(t){i[t.id]=t.name}),this.raw=t;var n=this.values;for(var r in t){var s=t[r],o=(s.aggregation||"").toLowerCase();n[o]=n[o]||{};var a=i[s.statisticId];n[o][a]={value:s.value}}},nt=function(){this.minPolygonHoleSize=1e7,this.buffer=50,this.simplify=50,this.srid=l.SRID.SRID_4326,this.quadrantSegments=2,this.intersectionMode="union",this.decimalPrecision=6},rt=function(r){function t(t,e,i){var n=r.call(this,i)||this;return n.polygon=new nt,n.sources=n.buildSourcesCfg(e),n.polygon.values=i.travelEdgeWeights,n.polygon.serializer=i.serializer,n.polygon.simplify=i.simplify,n.polygon.srid=i.srid,n.polygon.buffer=i.buffer,n.polygon.minPolygonHoleSize=i.minPolygonHoleSize,n.polygon.quadrantSegments=i.quadrantSegments,n.polygon.intersectionMode=i.intersectionMode,n.polygon.decimalPrecision=i.decimalPrecision,n}return i(t,r),t}(w),st=function(){function t(t){this.southWest=new ot(1/0,1/0),this.northEast=new ot(-1/0,-1/0),t&&(this.southWest=new ot(t.southWest.x,t.southWest.y),this.northEast=new ot(t.northEast.x,t.northEast.y))}return t.prototype.expandPoint=function(t,e){this.southWest.x=Math.min(this.southWest.x,t),this.northEast.x=Math.max(this.northEast.x,t),this.southWest.y=Math.min(this.southWest.y,e),this.northEast.y=Math.max(this.northEast.y,e)},t.prototype.expand=function(t){this.expandPoint(t.northEast.x,t.northEast.y),this.expandPoint(t.southWest.x,t.southWest.y)},t}(),ot=function(t,e){this.x=t,this.y=e},at=function(t){var i=this;this.bounds3857=new st,this.points=t.map(function(t){i.bounds3857.expandPoint(t[0],t[1]);var e=F.project({lat:t[0],lng:t[1]});return new ot(e.x,e.y)})},ct=function(t){var i=this;this.bounds3857=new st,this.travelTime=t.travelTime,this.area=t.area,this.lineStrings=[new at(t.outerBoundary)],this.bounds3857.expand(this.lineStrings[0].bounds3857),t.innerBoundary&&t.innerBoundary.forEach(function(t){var e=new at(t);i.lineStrings.push(e),i.bounds3857.expand(e.bounds3857)})},ut=function(){function t(t){this.client=t}return t.prototype.fetch=function(n,r){return h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return e=new rt(this.client,n,r),[4,this._executeFetch(n,r,e)];case 1:return i=t.sent(),"json"===r.serializer?[2,lt.create(i,i.metadata)]:"geojson"===r.serializer?[2,i]:[2]}})})},t.prototype._executeFetch=function(t,n,r){return h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).part(this.client.serviceUrl).version().part("/polygon").key().toString(),[4,f(this.client).fetchCachedData(n.useClientCache,e,"POST",r)];case 1:return(i=t.sent()).metadata=n,[2,i]}})})},t}(),lt=function(e){function n(t){return e.apply(this,t)||this}return i(n,e),n.create=function(t,e){var i=Object.create(n.prototype);return t.forEach(function(t){return i.push(t)}),e&&(i.metadata=e),i},n.prototype.getMaxBounds=function(){var e=[];return this.forEach(function(t){var i;t.polygons.forEach(function(t){var e=new ct(t);i?i.expand(e.bounds3857):i=e.bounds3857}),e.push(Y(i.northEast,null)),e.push(Y(i.southWest,null))}),K(e)},n}(Array),ht=function(s){function t(t,e,i,n){var r=s.call(this,n)||this;return r.sources=r.buildSourcesCfg(e),r.targets=r.buildTargetsCfg(i),r}return i(t,s),t}(w),ft=function(){function t(t){this.client=t}return t.prototype.individual=function(n,r,s){return h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).part(this.client.serviceUrl).version().part("/time").key().toString(),i=new ht(this.client,n,r,s),[4,f(this.client).fetchCachedData(s.useClientCache,e,"POST",i)];case 1:return[2,t.sent()]}})})},t.prototype.combined=function(n,r,s){return h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).part(this.client.serviceUrl).version().part("/reachability").key().toString(),i=new ht(this.client,n,r,s),[4,f(this.client).fetchCachedData(s.useClientCache,e,"POST",i)];case 1:return[2,t.sent()]}})})},t.prototype.count=function(e,i,n){return h(this,void 0,void 0,function(){return y(this,function(t){switch(t.label){case 0:return[4,this.locations(e,i,n)];case 1:return[2,t.sent().length]}})})},t.prototype.locations=function(e,n,r){return h(this,void 0,void 0,function(){var i;return y(this,function(t){switch(t.label){case 0:return i={},n.forEach(function(t){return i[String(t.id)]=-1}),[4,this.combined(e,n,r)];case 1:return t.sent().forEach(function(t){var e=String(t.id);i[e]?-1<t.travelTime&&(-1<i[e]?i[e]=Math.min(i[e],t.travelTime):i[e]=t.travelTime):console.warn("NOT FOUND",String(t.id))}),[2,n.filter(function(t){var e=String(t.id);return t.travelTime=i[e],-1<i[e]})]}})})},t}(),pt=function(s){function t(t,e,i,n){var r=s.call(this,n)||this;return r.sources=r.buildSourcesCfg(e),r.targets=r.buildTargetsCfg(i),r.pathSerializer=n.pathSerializer,"boolean"==typeof n.recommendations&&(n.recommendations=n.recommendations?1:0),Number.isInteger(n.recommendations)&&r.sources&&r.sources.forEach(function(t){if(null!=t.tm)for(var e in t.tm)t.tm[e].recommendations=n.recommendations}),r}return i(t,s),t}(w),dt=function(){function t(t){this.client=t}return t.prototype.fetch=function(r,s,o){return h(this,void 0,void 0,function(){var e,i,n=this;return y(this,function(t){switch(t.label){case 0:return e=new pt(this.client,r,s,o),[4,this._executeFetch(r,s,o,e)];case 1:return i=t.sent(),o.pathSerializer&&"compact"!==o.pathSerializer?"geojson"===o.pathSerializer?[2,i.routes]:[2]:[2,i.routes.map(function(t){return new Q(n.client,t.travelTime,t.segments,t)})]}})})},t.prototype._executeFetch=function(t,e,i,n){return h(this,void 0,void 0,function(){var e;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).part(this.client.serviceUrl).version().part("/route").key().toString(),[4,f(this.client).fetchCachedData(i.useClientCache,e,"POST",n,{Accept:"application/json,application/javascript,*/*"})];case 1:return[2,t.sent()]}})})},t}(),gt=function(){function t(t){this.client=t}return t.prototype.metadata=function(i){return h(this,void 0,void 0,function(){var e;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.tilesUrl).part("similarity/meta/").version().part("/"+encodeURIComponent(""+i)).key().toString(),[4,f(this.client).fetch(e)];case 1:return[2,t.sent()]}})})},t.prototype.fetch=function(s,o,a,c,u){return h(this,void 0,void 0,function(){var e,i,n,r;return y(this,function(t){switch(t.label){case 0:return e={west:c.southWest.lng,south:c.southWest.lat,east:c.northEast.lng,north:c.northEast.lat},i={bounds:e,refCellId:o,scores:a.map(function(t){return{source:t.source,minutes:t.minutes,factor:t.factor||1}})},n=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.tilesUrl).part("similarity/scores_cumulative/").version().part("/"+encodeURIComponent(""+s)).key(),r=u?n.params({normalizeOnViewport:!!u}).toString():n.toString(),[4,f(this.client).fetch(r,"POST",i)];case 1:return[2,t.sent()]}})})},t}();var mt=function(t,e,i){this.inactiveSources=[],this.getClosestSources=!1,this.serviceUrl=t.serviceUrl,this.serviceKey=t.serviceKey,this.useCache=null==i.useCache||i.useCache,this.sources=e.map(function(t){return{id:t.id,y:t.lat,x:t.lng}}),this.iFeelLucky=i.iFeelLucky,this.travelType=i.travelType,this.edgeWeight=i.edgeWeight,this.maxEdgeWeight=i.maxEdgeWeight,this.frame=i.transitFrameDuration,this.time=i.transitFrameTime,this.date=i.transitFrameDate,this.maxTransfers=i.transitMaxTransfers,this.maxWalkingTimeFromSource=i.transitMaxWalkingTimeFromSource,this.avoidTransitRouteTypes=i.transitAvoidTransitRouteTypes,this.rushHour=i.rushHour,i.inactiveSources&&(this.inactiveSources=i.inactiveSources.map(function(t){return{id:t.id,y:t.lat,x:t.lng}}));var n=[];i.statistics&&(this.omitIndividualStatistics=i.omitIndividualStatistics,n=i.statistics.map(function(t){return t instanceof Number||"number"==typeof t?+t:t.id})),this.statisticGroupId=+i.statisticsGroup,this.statisticIds=n,i.closestSources&&(this.getClosestSources=!0)},vt=function(t,e,i){var n=i.statistics.map(function(t){return t instanceof Number||"number"==typeof t?+t:t.id});this.statisticGroupId=+i.statisticsGroup,this.statisticIds=n,this.intersectionGeometry={data:e,crs:i.crs||4326}},yt=function(){function t(t){this.client=t,this.statisticsMetadataCache=new e(200),this.statisticsEnsemblesCache=new e(200)}return t.prototype.combined=function(i,n){return h(this,void 0,void 0,function(){var e;return y(this,function(t){switch(t.label){case 0:return[4,this.dependent(i,n)];case 1:return[2,(e=t.sent())&&e.statistics]}})})},t.prototype.individual=function(i,n){return h(this,void 0,void 0,function(){var e;return y(this,function(t){switch(t.label){case 0:return[4,this.dependent(i,n)];case 1:return[2,(e=t.sent())&&e.individualStatistics]}})})},t.prototype.travelTimes=function(i,n){return h(this,void 0,void 0,function(){var e;return y(this,function(t){switch(t.label){case 0:return i.length?(e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.statisticsUrl).part("traveltimes").params({serviceUrl:this.client.serviceUrl}).toString(),[4,f(this.client).fetch(e,"POST",new mt(this.client,i,n))]):[2,null];case 1:return[2,t.sent()]}})})},t.prototype.dependent=function(n,r){return h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return n.length?(e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.statisticsUrl).part("charts/dependent").params({serviceUrl:this.client.serviceUrl}).toString(),[4,f(this.client).fetch(e,"POST",new mt(this.client,n,r))]):[2,null];case 1:return i=t.sent(),[2,new tt(i,r.statistics)]}})})},t.prototype.geometry=function(n,r){return h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return n?(e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.statisticsUrl).part("values/geometry").params({serviceUrl:this.client.serviceUrl}).toString(),[4,f(this.client).fetch(e,"POST",new vt(this.client,n,r))]):[2,null];case 1:return i=t.sent(),[2,new it(i,r.statistics)]}})})},t.prototype.metadata=function(s){return h(this,void 0,void 0,function(){var e,n,i,r=this;return y(this,function(t){switch(t.label){case 0:return e=this.client.config.tilesUrl,n="number"==typeof s?s:s.id,i=e+"-"+n,[4,this.statisticsMetadataCache.get(i,function(){return h(r,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.tilesUrl).part("statistics/meta/").version().part("/"+n).key().toString(),[4,f(this.client).fetch(e)];case 1:return!(i=t.sent()).name&&i.names&&i.names.en&&(i.name=i.names.en),i.stats&&i.stats.length&&i.stats.forEach(function(t){!t.name&&t.names&&t.names.en&&(t.name=t.names.en)}),[2,i]}})})})];case 1:return[2,t.sent()]}})})},t.prototype.metadataKey=function(s,o){return h(this,void 0,void 0,function(){var e,i,n,r;return y(this,function(t){switch(t.label){case 0:return[4,this.metadata(s)];case 1:for(e=t.sent(),i=0,n=e.stats;i<n.length;i++)if(r=n[i],o.id==r.statistic_id||r.names&&r.names.en==o.name)return[2,r];return[2,null]}})})},t.prototype.tileRoute=function(t,e){var i="number"==typeof t?t:t.id,n=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.tilesUrl).part("statistics/tiles/").version().part("/"+i+"/{z}/{x}/{y}.mvt").key();return e&&0<e.length?n.params({columns:encodeURIComponent(e.map(function(t){return+t.id}).join(","))}).toString():n.toString()},t.prototype.ensembles=function(){return h(this,void 0,void 0,function(){var e,i=this;return y(this,function(t){switch(t.label){case 0:return e=this.client.config.tilesUrl,[4,this.statisticsEnsemblesCache.get(e,function(){return h(i,void 0,void 0,function(){var e,i,n,r;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.tilesUrl).part("ensemble/list/").version().key().toString(),[4,f(this.client).fetch(e,"GET")];case 1:for(n in i=t.sent())i[n]&&((r=i[n]).id=+r.id,r.groups&&r.groups.length&&r.groups.forEach(function(t){t.hierarchy=+t.hierarchy,t.id=+t.id}));return[2,i]}})})})];case 1:return[2,t.sent()]}})})},t}(),bt=function(r){function t(t,e,i){var n=r.call(this,t,e,i)||this;return delete n.inactiveSources,delete n.statisticGroupId,delete n.statisticIds,delete n.getClosestSources,delete n.useCache,i&&(n.multiGraphSerializationType=i.multigraph.serialization.format,n.multiGraphSerializationDecimalPrecision=i.multigraph.serialization.decimalPrecision,i.multigraph.aggregation&&(n.multiGraphAggregationType=i.multigraph.aggregation.type||null,n.multiGraphAggregationIgnoreOutlier=i.multigraph.aggregation.ignoreOutliers||null,n.multiGraphAggregationMinSourcesRatio=i.multigraph.aggregation.minSourcesRatio||null,n.multiGraphAggregationMinSourcesCount=i.multigraph.aggregation.minSourcesCount||null,n.multiGraphAggregationMaxResultValueRatio=i.multigraph.aggregation.maxResultValueRatio||null,n.multiGraphAggregationMaxResultValue=i.multigraph.aggregation.maxResultValue||null)),n}return i(t,r),t}(mt),St=function(){function t(t){this.client=t}return t.prototype.create=function(n,r){return h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.statisticsUrl).part("multigraph").key().toString(),i=new bt(this.client,n,r),[4,f(this.client).fetchCachedData(r.useClientCache,e,"POST",i,{Accept:"text/plain"})];case 1:return[2,t.sent()]}})})},t.prototype.info=function(n){return h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.statisticsUrl).part("multigraph/"+n).key().toString(),[4,f(this.client).fetch(e,"GET")];case 1:return(i=t.sent()).boundingBoxNorthEast&&i.boundingBoxSouthWest&&(i.boundingBox={northEast:{lat:i.boundingBoxNorthEast.y,lng:i.boundingBoxNorthEast.x},southWest:{lat:i.boundingBoxSouthWest.y,lng:i.boundingBoxSouthWest.x}},delete i.boundingBoxNorthEast,delete i.boundingBoxSouthWest),[2,i]}})})},t.prototype.redo=function(i){return h(this,void 0,void 0,function(){var e;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.statisticsUrl).part("multigraph/"+i+"/update").key().toString(),[4,f(this.client).fetch(e,"PATCH")];case 1:return[2,t.sent()]}})})},t}(),Tt=function(){function t(t){this.client=t}return t.prototype.fetch=function(n,r,s,o){return h(this,void 0,void 0,function(){var e,i;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.fleetsUrl).version().part("/api/key-auth/optimizations").key().toString(),i=this._createPayload(this.client,n,r,s,o),[4,f(this.client).fetch(e,"POST",i)];case 1:return[2,t.sent()]}})})},t.prototype._createPayload=function(t,e,i,n,r){return{optimizationTime:r.optimizationTime,optimizationAlgorithm:r.optimizationAlgorithm,optimizationMetadata:{costMatrixSource:r.costMatrixSource,geojsonCreation:r.geojsonCreation,unimprovedWaitingTime:r.unimprovedWaitingTime,filterOrdersWithMissedDeadline:r.filterOrdersWithMissedDeadline,filterOrdersOutsideOfValidWorkingHours:r.filterOrdersOutsideOfValidWorkingHours,prohibitFilteringOfOrdersWithDeadlinesEarlierEqualsThan:r.prohibitFilteringOfOrdersWithDeadlinesEarlierEqualsThan,secondsToPenaltyRatioForDeadlineMissed:r.secondsToPenaltyRatioForDeadlineMissed,secondsToPenaltyRatioForOutOfWorkingHours:r.secondsToPenaltyRatioForOutOfWorkingHours,timeConstraintPenaltyToTravelCostRatio:r.timeConstraintPenaltyToTravelCostRatio,longestTourPenaltyFactor:r.longestTourPenaltyFactor,nonParallelOrdersByTags:r.nonParallelOrdersByTags,travelOptions:{travelType:r.travelType,serviceKey:t.serviceKey,serviceUrl:t.serviceUrl,travelTimeFactors:r.travelTimeFactors,fallbackServiceUrl:"",edgeWeight:r.edgeWeight,maxEdgeWeight:r.maxEdgeWeight,elevation:r.elevation,rushHour:r.rushHour}},stores:e,transports:n,orders:i}},t}(),wt=function(){function t(t){this.client=t,this.basemapsLookup={Bright:"osm-bright-gl-style",Light:"positron-gl-style","Light No-Labels":"positron-nolabels-gl-style",Dark:"dark-matter-gl-style","Dark No-Labels":"dark-matter-nolabels-gl-style",Gray:"gray-gl-style","Gray No-Labels":"gray-nolabels-gl-style","Light blue":"blueberry-gl-style","Dark blue":"fiord-color-gl-style","Dark blue No-Labels":"fiord-color-nolabels-gl-style",Basic:"klokantech-basic-gl-style",Toner:"toner-gl-style"}}return Object.defineProperty(t.prototype,"basemapNames",{get:function(){return Object.keys(this.basemapsLookup)},enumerable:!0,configurable:!0}),t.prototype.getGLStyleURL=function(t){if(!t||!this.basemapsLookup[t])throw new Error("valid style name required to access Targomo basemap");return new l.UrlUtil.TargomoUrl(this.client).host(this.client.config.basemapsUrl).part(this.basemapsLookup[t]+".json").params({key:this.client.serviceKey}).toString()},t}(),Ut=function(t,e){this.esri=t,this.photon=e},Et=function(){function t(t,e,i){if(this.serviceKey=e,!t)throw new TypeError("Region parameter is missing");this.config=new n(i),t.includes("http")||t.includes("localhost")||t.includes("/")?this.serviceUrl=t:this.serviceUrl="https://api.targomo.com/"+t+"/",this.pois=new P(this),this.statistics=new yt(this),this.reachability=new ft(this),this.optimizations=new C(this),this.geocoding=new Ut(new g,new m(this)),this.polygons=new ut(this),this.routes=new dt(this),this.similarity=new gt(this),this.benchmarks=new d(this),this.statefulMultigraph=new St(this),this.multigraph=new E(this),this.basemaps=new wt(this),this.fleets=new Tt(this)}return Object.defineProperty(t.prototype,"endpoint",{get:function(){var t=this.serviceUrl.split("/").filter(function(t){return!!t});return t[t.length-1]},enumerable:!0,configurable:!0}),t.prototype.metadata=function(){return h(this,void 0,void 0,function(){var e;return y(this,function(t){switch(t.label){case 0:return e=new l.UrlUtil.TargomoUrl(this).part(this.serviceUrl).version().part("/metadata/network").key().toString(),[4,f(this).fetch(e)];case 1:return[2,t.sent()]}})})},t}(),xt=X;l.geometry=xt,l.PointsOfInterestClient=P,l.ClientConfig=n,l.BenchmarksClient=d,l.GeocodeEsriClient=g,l.GeocodePhotonClient=m,l.MultigraphClient=E,l.OptimizationsClient=C,l.PolygonsClient=ut,l.PolygonArray=lt,l.ReachabilityClient=ft,l.RoutesClient=dt,l.SimilarityClient=gt,l.StatisticsClient=yt,l.GeocodingClients=Ut,l.TargomoClient=Et,l.FleetsClient=Tt,l.LatLng=M,l.BoundingBox=N,l.TravelSpeedValues=G,l.StatisticValues=B,l.UseCacheRequestOptions=v,l.BaseRequestOptions=S,l.TravelRequestOptions=T,l.Route=Q,l.RouteSegment=$,l.StatisticsResult=tt,l.FpResult=et,l.OptimizationResult=A,l.StatisticsGeometryResult=it,l.RequestsUtil=o,l.requests=f,l.SimpleLRU=e,l.SimpleCache=t,Object.defineProperty(l,"__esModule",{value:!0})});
//# sourceMappingURL=targomo-core.umd.min.js.map



/**
* @targomo/js-extensions "0.0.9" http://targomo.com
* Google and Leaflet JavaScript (& TypeScript) extensions for Targomo's time-based access mapping services.
* (c) 2020 Targomo
*/
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("leaflet"),require("@targomo/core"),require("leaflet.vectorgrid/dist/Leaflet.VectorGrid.bundled.js")):"function"==typeof define&&define.amd?define(["exports","leaflet","@targomo/core","leaflet.vectorgrid/dist/Leaflet.VectorGrid.bundled.js"],e):e((t.tgm=t.tgm||{},t.tgm.leaflet={}),t.L,t.tgm)}(this,function(t,y,d){"use strict";var o=function(t,e){return(o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(t,e)};function i(t,e){function n(){this.constructor=t}o(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}var E=function(){return(E=Object.assign||function(t){for(var e,n=1,o=arguments.length;n<o;n++)for(var s in e=arguments[n])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t}).apply(this,arguments)};function s(i,r,h,a){return new(h||(h=Promise))(function(t,e){function n(t){try{s(a.next(t))}catch(t){e(t)}}function o(t){try{s(a.throw(t))}catch(t){e(t)}}function s(e){e.done?t(e.value):new h(function(t){t(e.value)}).then(n,o)}s((a=a.apply(i,r||[])).next())})}function r(n,o){var s,i,r,t,h={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return t={next:e(0),throw:e(1),return:e(2)},"function"==typeof Symbol&&(t[Symbol.iterator]=function(){return this}),t;function e(e){return function(t){return function(e){if(s)throw new TypeError("Generator is already executing.");for(;h;)try{if(s=1,i&&(r=2&e[0]?i.return:e[0]?i.throw||((r=i.return)&&r.call(i),0):i.next)&&!(r=r.call(i,e[1])).done)return r;switch(i=0,r&&(e=[2&e[0],r.value]),e[0]){case 0:case 1:r=e;break;case 4:return h.label++,{value:e[1],done:!1};case 5:h.label++,i=e[1],e=[0];continue;case 7:e=h.ops.pop(),h.trys.pop();continue;default:if(!(r=0<(r=h.trys).length&&r[r.length-1])&&(6===e[0]||2===e[0])){h=0;continue}if(3===e[0]&&(!r||e[1]>r[0]&&e[1]<r[3])){h.label=e[1];break}if(6===e[0]&&h.label<r[1]){h.label=r[1],r=e;break}if(r&&h.label<r[2]){h.label=r[2],h.ops.push(e);break}r[2]&&h.ops.pop(),h.trys.pop();continue}e=o.call(n,h)}catch(t){e=[6,t],i=0}finally{s=r=0}if(5&e[0])throw e[1];return{value:e[0]?e[1]:void 0,done:!0}}([e,t])}}}var h,a,u=(h=.5/Math.PI,a=-.5/Math.PI,function(t,e,n){return void 0===n&&(n=1),{x:t=n*(h*t+.5),y:e=n*(a*e+.5)}});function b(t,e,n){return void 0===n&&(n=1),u(t/6378137,e/6378137,n)}var W=function(){function e(t){this.southWest=new T(1/0,1/0),this.northEast=new T(-1/0,-1/0),t&&(this.southWest=new T(t.southWest.x,t.southWest.y),this.northEast=new T(t.northEast.x,t.northEast.y))}return e.prototype.expandPoint=function(t,e){this.southWest.x=Math.min(this.southWest.x,t),this.northEast.x=Math.max(this.northEast.x,t),this.southWest.y=Math.min(this.southWest.y,e),this.northEast.y=Math.max(this.northEast.y,e)},e.prototype.expand=function(t){this.expandPoint(t.northEast.x,t.northEast.y),this.expandPoint(t.southWest.x,t.southWest.y)},e.prototype.modifyIntersect=function(t){return this.southWest.x=Math.max(this.southWest.x,t.southWest.x),this.northEast.x=Math.min(this.northEast.x,t.northEast.x),this.southWest.y=Math.max(this.southWest.y,t.southWest.y),this.northEast.y=Math.min(this.northEast.y,t.northEast.y),this},e.prototype.contains=function(t){return this.northEast.x>=t.northEast.x&&this.northEast.y>=t.northEast.y&&this.southWest.x<=t.southWest.x&&this.southWest.y<=t.southWest.y},e.prototype.intersects=function(t){return!(this.northEast.x<t.southWest.x||this.northEast.y<t.southWest.y||this.southWest.x>t.northEast.x||this.southWest.y>t.northEast.y)},e.prototype.growOutwardsFactor=function(t){void 0===t&&(t=1);var e=(this.northEast.x-this.southWest.x)*t,n=(this.northEast.y-this.southWest.y)*t;return this.northEast.x+=e,this.northEast.y+=n,this.southWest.x-=e,this.southWest.y-=n,this},e.prototype.growOutwardsAmount=function(t){return this.northEast.x+=t,this.northEast.y+=t,this.southWest.x-=t,this.southWest.y-=t,this},e.prototype.toLineString=function(){return[new T(this.southWest.x,this.northEast.y),new T(this.northEast.x,this.northEast.y),new T(this.northEast.x,this.southWest.y),new T(this.southWest.x,this.southWest.y)]},e.prototype.reproject=function(t){return new e({northEast:t(this.northEast.x,this.northEast.y),southWest:t(this.southWest.x,this.southWest.y)})},e.prototype.width=function(){return this.northEast.x-this.southWest.x},e.prototype.height=function(){return this.southWest.y-this.northEast.y},e.prototype.left=function(){return this.southWest.x},e.prototype.top=function(){return this.northEast.y},e}(),T=function(){function t(t,e){this.x=t,this.y=e}return t.prototype.isCollinear=function(t,e,n){if(t.x==e.x&&t.y==e.y)return!1;if(t.x==this.x&&this.x==e.x)return!0;if(t.y==this.y&&this.y==e.y)return!0;var o=t.x*(this.y-e.y)+this.x*(e.y-t.y)+e.x*(t.y-this.y);return o<n&&-n<o&&t.x!=e.x&&t.y!=e.y},t.prototype.euclideanDistance=function(t){return Math.sqrt(Math.pow(this.x-t.x,2)+Math.pow(this.y-t.y,2))},t}(),l=function(t){var n=this;this.bounds3857=new W,this.points=t.map(function(t){n.bounds3857.expandPoint(t[0],t[1]);var e=b(t[0],t[1],1);return new T(e.x,e.y)})},c=function(){function t(t){var n=this;this.bounds3857=new W,this.travelTime=t.travelTime,this.area=t.area,this.lineStrings=[new l(t.outerBoundary)],this.bounds3857.expand(this.lineStrings[0].bounds3857),t.innerBoundary&&t.innerBoundary.forEach(function(t){var e=new l(t);n.lineStrings.push(e),n.bounds3857.expand(e.bounds3857)})}return t.prototype.getOuterBoundary=function(){return this.lineStrings[0]},t.prototype.getInnerBoundary=function(){return this.lineStrings.slice(1)},t}(),e=function(){function t(t){var n=this;this.polygons={},this.bounds3857=new W,t.forEach(function(t){t.polygons.forEach(function(t){var e=new c(t);n.polygons[e.travelTime]=n.polygons[e.travelTime]||[],n.polygons[e.travelTime].push(e),n.bounds3857.expand(e.bounds3857)})})}return t.prototype.forEach=function(n){var o=this;Object.keys(this.polygons).map(function(t){return+t}).sort(function(t,e){return e-t}).forEach(function(t,e){return n(+t,o.polygons[t],e)})},t}();var n={};["#006837","#39B54A","#8CC63F","#F7931E","#F15A24","#C1272D"].forEach(function(t,e){n[300*(e+1)]=t});var p=function(){this.inverse=!1,this.colors=n,this.opacity=.5,this.strokeWidth=5},f=function(n){function t(t){var e=n.call(this)||this;return Object.assign(e,t),e}return i(t,n),t.prototype.getColorOpacity=function(t,e){var n,o=null;return o=this.colors instanceof Array?this.colors[e]:this.colors[t],(n=o)&&null!=n.color?{color:o.color||"#ccc",opacity:o.opacity||1}:{color:o||"#ccc",opacity:1}},t}(p),L=0;function m(h,t,s,e,a){var n,o=b(t.southWest.x,t.southWest.y,s),i=b(t.northEast.x,t.northEast.y,s);i.y<o.y&&(n=[o.y,i.y],i.y=n[0],o.y=n[1]);var r=Math.floor(o.x),u=Math.floor(o.y),l=Math.ceil(i.x),c=Math.ceil(i.y),p=new W(h).reproject(b).toLineString();function y(o,t){return(t=function(t,e){var i,r,h,a,n=function(t){return(r.x-i.x)*(t.y-i.y)>(r.y-i.y)*(t.x-i.x)},o=function(){var t=new T(i.x-r.x,i.y-r.y),e=new T(h.x-a.x,h.y-a.y),n=i.x*r.y-i.y*r.x,o=h.x*a.y-h.y*a.x,s=1/(t.x*e.y-t.y*e.x);return new T((n*e.x-o*t.x)*s,(n*e.y-o*t.y)*s)},s=t;for(var u in i=e[e.length-1],e){r=e[u];var l=s;for(var c in s=[],h=l[l.length-1],l)n(a=l[c])?(n(h)||s.push(o()),s.push(a)):n(h)&&s.push(o()),h=a;i=r}return s}(t,p)).forEach(function(t,e){var n=(0<e?"L":"M")+" "+(Math.round(t.x*s)-r)+" "+(Math.round(t.y*s)-u);o.push(n)}),0<o.length&&o.push("z"),o}var d=[];e.forEach(function(t,e,n){var o,s,i=e.map(function(t){return(e=t,n=[],h.intersects(e.bounds3857)&&(y(n,e.getOuterBoundary().points),e.getInnerBoundary().forEach(function(t){h.intersects(t.bounds3857)&&y(n,t.points)})),n).join(" ");var e,n}).join(" ");if(0!=i.length){var r=a.getColorOpacity(t,n);d.push((o=i,"\n    <g style='opacity: "+(s=E({},r,{strokeWidth:a.strokeWidth,color:a.inverse?"black":r.color})).opacity+"'>\n      <path style='stroke: "+s.color+";\n            fill: "+s.color+";\n            stroke-opacity: "+s.opacity+";\n            stroke-width: "+s.strokeWidth+";\n            fill-opacity: "+s.opacity+"'\n\n            d='"+o+"'/>\n    </g>\n  "))}});var f,m,g,v,x=Math.ceil(Math.abs(l-r)),w=Math.ceil(Math.abs(c-u));return{content:a.inverse?(g="tgm:inverse:"+L++,'\n    <svg  height="100%" width="100%" viewbox="0 0 '+(f=x)+" "+(m=w)+"\"\n          style='opacity: 1; stroke-linejoin:round; stroke-linecap:round; fill-rule: evenodd'\n          xmlns='http://www.w3.org/2000/svg'>\n          <path style='mask: url(#mask_"+g+")' d='"+(v="M 0 0 L "+f+" 0 L "+f+" "+m+" L 0 "+m+" z")+"'/>\n          \n    <defs>\n      <mask id='mask_"+g+"'>\n          <path style='fill-opacity:1; stroke: white; fill:white;' d='"+v+"'/>\"\n          "+d.join("\n")+"\n      </mask>\n    </defs>\n  \n    </svg>"):'\n    <svg  height="100%" width="100%" viewbox="0 0 '+x+" "+w+"\"\n          style='opacity: 1; stroke-linejoin:round; stroke-linecap:round; fill-rule: evenodd'\n          xmlns='http://www.w3.org/2000/svg'>\n          "+d.join("\n")+"\n    </svg>",width:x,height:w}}var g=function(){function t(t,e){void 0===t&&(t=200),void 0===e&&(e=700),this.min=t,this.max=e}return t.prototype.schedule=function(t){var e=this,n=function(){clearTimeout(e.longTimeout),clearTimeout(e.shortTimeout),e.longTimeout=null,e.shortTimeout=null,t()};this.longTimeout||(this.longTimeout=setTimeout(n,this.max)),clearTimeout(this.shortTimeout),this.shortTimeout=setTimeout(n,this.min)},t.prototype.scheduleMaximum=function(t){var e=this;this.longTimeout||(this.longTimeout=setTimeout(function(){clearTimeout(e.longTimeout),e.longTimeout=null,t()},this.max)),clearTimeout(this.shortTimeout)},t}(),v=function(){function t(t,e){this.plugin=t,this.options=e,this.renderTimeout=new g(300,3e3)}return t.prototype.getElement=function(){return this.divElement},t.prototype.draw=function(t){var e=this;if(void 0===t&&(t=!1),t)this.resize(),this.render(),this.divElement.style.transform=null;else{if(this.divElement&&this.bounds){var n=new W(this.plugin.getElementPixels(this.bounds)),o=this.divElement,s=Math.round(n.left()-this.currentPixelBounds.left()),i=Math.round(n.top()-this.currentPixelBounds.top()),r=n.width()/this.currentPixelBounds.width(),h=n.height()/this.currentPixelBounds.height();1!==h||1!==r?o.style.transform="translate3d("+s+"px, "+i+"px, 0) scale3d("+r+", "+h+", 1)":0===s&&0===i||(o.style.transform="translate3d("+s+"px, "+i+"px, 0)")}this.renderTimeout.scheduleMaximum(function(){e.render(),e.divElement.style.transform=null})}},t.prototype.resize=function(){if(this.divElement&&this.bounds){var t=this.currentPixelBounds=new W(this.plugin.getElementPixels(this.bounds)),e=this.divElement;e.style.left=t.left()+"px",e.style.top=t.top()+"px",e.style.width=t.width()+"px",e.style.height=t.height()+"px",e.style.transform=null}},t.prototype.initElement=function(){var t=document.createElement("div");return t.style.borderStyle="none",t.style.borderWidth="0px",t.style.position="absolute",t.style.opacity=""+this.options.opacity||"0.5",t.style["backface-visibility"]="hidden",t.style.perspective=1e3,t.style["transform-origin"]="0 0 0",t.style["will-change"]="transform",this.divElement=t,this.divElement},t.prototype.onRemove=function(){this.divElement.parentNode.removeChild(this.divElement),this.divElement=null},t.prototype.setData=function(t){this.model=t?new e(t):null,this.render()},t.prototype.setInverse=function(t){this.options.inverse=t,this.render()},t.prototype.setColors=function(t){this.options.colors=t,this.render()},t.prototype.setOpacity=function(t){this.options.opacity=t,this.divElement&&(this.divElement.style.opacity=""+this.options.opacity||"0.5")},t.prototype.setStrokeWidth=function(t){this.options.strokeWidth=t,this.render()},t.prototype.boundsCalculation=function(t){var e=this.model,n=this.options.inverse,o=new W(this.plugin.getViewPort()),s=new W(o),i=new W(s).growOutwardsFactor(t).modifyIntersect(e.bounds3857);n&&(i.expand(o),i.growOutwardsFactor(t)),s.growOutwardsFactor(t);var r=d.geometry.webMercatorToLatLng(o.southWest,void 0),h=d.geometry.webMercatorToLatLng(o.northEast,void 0),a=this.plugin.getElementPixels({southWest:r,northEast:h}),u=Math.abs((o.northEast.x-o.southWest.x)/a.northEast.x-a.southWest.x);return i.growOutwardsAmount(this.options&&u*this.options.strokeWidth||0),{bounds:s,newBounds:i}},t.prototype.render=function(t){if(void 0===t&&(t=!0),this.divElement)if(this.model){var e=this.plugin.getZoom(),n=256*Math.pow(2,e);n=Math.min(1e7,n);var o=this.boundsCalculation(.1),s=o.bounds,i=o.newBounds,r=m(s,i,n,this.model,new f(this.options)).content;this.divElement.innerHTML=r;var h=d.geometry.webMercatorToLatLng(i.southWest,void 0),a=d.geometry.webMercatorToLatLng(i.northEast,void 0);this.bounds={southWest:h,northEast:a},t&&this.resize()}else this.divElement.innerHTML=""},t}(),x=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return i(e,t),e}(p),w=function(n){function t(t){var e=n.call(this)||this;return e.readyPromise=new Promise(function(t){return e.readyResolve=t}),e.options=Object.assign(new x,t||{}),e}return i(t,n),t.prototype.setData=function(e){return s(this,void 0,void 0,function(){return r(this,function(t){switch(t.label){case 0:return[4,this.readyPromise];case 1:return t.sent(),this.element&&this.element.setData(e),[2]}})})},t.prototype.draw=function(){this.element&&(y.DomUtil.setTransform(this.element.getElement(),new y.Point(0,0),null),this.element.draw(!0))},t.prototype.onAdd=function(l){var c=this;this.element=new v({getZoom:function(){return l.getZoom()},getViewPort:function(){var t=l.getBounds();return new W({northEast:d.geometry.latLngToWebMercator({lng:t.getNorthEast().lng,lat:t.getNorthEast().lat}),southWest:d.geometry.latLngToWebMercator({lng:t.getSouthWest().lng,lat:t.getSouthWest().lat})})},getElementPixels:function(t){return{northEast:l.latLngToLayerPoint(t.northEast),southWest:l.latLngToLayerPoint(t.southWest)}}},this.options);var p=this.element.initElement();return p.style.transformOrigin="center",y.DomUtil.addClass(p,"leaflet-zoom-animated"),l.getPanes().overlayPane.appendChild(p),l.on("moveend",this.draw,this),l.on("resize",this.draw,this),l.on("zoomend",this.draw,this),this._map.options.zoomAnimation&&y.Browser.any3d&&l.on("zoomanim",function(t){if(c.element.bounds){var e=l.getZoomScale(t.zoom,l.getZoom()),n=l._latLngToNewLayerPoint(c.element.bounds.southWest,t.zoom,t.center).round(),o=l._latLngToNewLayerPoint(c.element.bounds.northEast,t.zoom,t.center).round(),s=l._latLngToNewLayerPoint(c.element.bounds.southWest,l.getZoom(),l.getCenter()).round(),i=l._latLngToNewLayerPoint(c.element.bounds.northEast,l.getZoom(),l.getCenter()).round(),r=(n.x+o.x)/2,h=(n.y+o.y)/2,a=(s.x+i.x)/2,u=(s.y+i.y)/2;y.DomUtil.setTransform(p,new y.Point(r-a,h-u),e)}}),this.readyResolve(),this.draw(),this},t.prototype.onRemove=function(){return this.element&&(this.element.onRemove(),this.element=null),this},t.prototype.setInverse=function(t){this.options.inverse=t,this.draw()},t.prototype.setColors=function(t){this.options.colors=t,this.draw()},t.prototype.setOpacity=function(t){(this.options.opacity=t,this.element)&&(this.element.getElement().style.opacity=null!=this.options.opacity?""+this.options.opacity:"0.5")},t.prototype.setStrokeWidth=function(t){this.options.strokeWidth=t,this.draw()},t}(y.Layer),M=function(s){function o(t,e,n){if(!e&&!t.basemaps.basemapsLookup[e])throw new Error("valid style name required to access Targomo basemap");var o="https://maps.targomo.com/styles/"+t.basemaps.basemapsLookup[e]+"/rendered/{z}/{x}/{y}.png?key="+t.serviceKey;return s.call(this,o,n)||this}return i(o,s),o.getTileLayerList=function(e){var n={};return e.basemaps.basemapNames.forEach(function(t){n[t]=new o(e,t,{})}),n},o}(y.TileLayer),P=function(){function t(t,e,n,o){this.tgmClient=t,this.update(n,o,e)}return t.prototype.addTo=function(e){return s(this,void 0,void 0,function(){return r(this,function(t){switch(t.label){case 0:return this.layer?[3,2]:[4,this.createLayer()];case 1:t.sent(),t.label=2;case 2:return this.map=e,this.layer.addTo(e),[2]}})})},t.prototype.update=function(t,e,n){return t&&(this.multigraphOptions=t),e&&(this.vectorTileoptions=e),n&&(this.sources=n),this.createLayer()},t.prototype.createLayer=function(){return s(this,void 0,void 0,function(){var e;return r(this,function(t){switch(t.label){case 0:return this.map&&this.layer&&this.map.removeLayer(this.layer),[4,this.tgmClient.multigraph.getTiledMultigraphUrl(this.sources,this.multigraphOptions,"mvt")];case 1:return e=t.sent(),this.layer=y.vectorGrid.protobuf(e,this.vectorTileoptions),this.map&&this.layer&&this.layer.addTo(this.map),[2]}})})},t}();t.LeafletPolygonOverlayOptions=x,t.TgmLeafletPolygonOverlay=w,t.TgmLeafletTileLayer=M,t.TgmLeafletMultigraphTileLayer=P,Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=targomo-leaflet.umd.min.js.map
