(function () {
'use strict';

function __$strToBlobUri(str, mime, isBinary) {try {return window.URL.createObjectURL(new Blob([Uint8Array.from(str.split('').map(function(c) {return c.charCodeAt(0)}))], {type: mime}));} catch (e) {return "data:" + mime + (isBinary ? ";base64," : ",") + str;}}
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    };

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue+','+value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    var this$1 = this;

    for (var name in this.map) {
      if (this$1.map.hasOwnProperty(name)) {
        callback.call(thisArg, this$1.map[name], name, this$1);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) { items.push(name); });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) { items.push(value); });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) { items.push([name, value]); });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    rawHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = 'status' in options ? options.status : 200;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);
      var xhr = new XMLHttpRequest();

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  };
  self.fetch.polyfill = true;
})(typeof self !== 'undefined' ? self : undefined);

var read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
};

var write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

var index$1 = {
	read: read,
	write: write
};

var index = Pbf;

var ieee754 = index$1;

function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        var this$1 = this;

        end = end || this.length;

        while (this.pos < end) {
            var val = this$1.readVarint(),
                tag = val >> 3,
                startPos = this$1.pos;

            this$1.type = val & 0x7;
            readField(tag, result, this$1);

            if (this$1.pos === startPos) { this$1.skip(val); }
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function(isSigned) {
        var buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) { return val; }
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) { return val; }
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) { return val; }
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) { return val; }
        b = buf[this.pos];   val |= (b & 0x0f) << 28;

        return readVarintRemainder(val, isSigned, this);
    },

    readVarint64: function() { // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = readUtf8(this.buf, this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function(arr, isSigned) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readVarint(isSigned)); }
        return arr;
    },
    readPackedSVarint: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readSVarint()); }
        return arr;
    },
    readPackedBoolean: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readBoolean()); }
        return arr;
    },
    readPackedFloat: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readFloat()); }
        return arr;
    },
    readPackedDouble: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readDouble()); }
        return arr;
    },
    readPackedFixed32: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readFixed32()); }
        return arr;
    },
    readPackedSFixed32: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readSFixed32()); }
        return arr;
    },
    readPackedFixed64: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readFixed64()); }
        return arr;
    },
    readPackedSFixed64: function(arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readSFixed64()); }
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) { while (this.buf[this.pos++] > 0x7f) {} }
        else if (type === Pbf.Bytes) { this.pos = this.readVarint() + this.pos; }
        else if (type === Pbf.Fixed32) { this.pos += 4; }
        else if (type === Pbf.Fixed64) { this.pos += 8; }
        else { throw new Error('Unimplemented type: ' + type); }
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) { length *= 2; }

        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) { return; }
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) { return; }
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) { return; }
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;

        if (len >= 0x80) { makeRoomForExtraLength(startPos, len, this); }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var this$1 = this;

        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) { this$1.buf[this$1.pos++] = buffer[i]; }
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) { makeRoomForExtraLength(startPos, len, this); }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(l, s, p) {
    var buf = p.buf,
        h, b;

    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) { return toNum(l, h, s); }

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ?
        pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return ((high >>> 0) * 0x100000000) + (low >>> 0);
}

function writeBigVarint(val, pbf) {
    var low, high;

    if (val >= 0) {
        low  = (val % 0x100000000) | 0;
        high = (val / 0x100000000) | 0;
    } else {
        low  = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = (low + 1) | 0;
        } else {
            low = 0;
            high = (high + 1) | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos]   = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen =
        len <= 0x3fff ? 1 :
        len <= 0x1fffff ? 2 :
        len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) { pbf.buf[i + extraLen] = pbf.buf[i]; }
}

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) { pbf.writeVarint(arr[i]); }   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) { pbf.writeSVarint(arr[i]); }  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) { pbf.writeFloat(arr[i]); }    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) { pbf.writeDouble(arr[i]); }   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) { pbf.writeBoolean(arr[i]); }  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) { pbf.writeFixed32(arr[i]); }  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) { pbf.writeSFixed32(arr[i]); } }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) { pbf.writeFixed64(arr[i]); }  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) { pbf.writeSFixed64(arr[i]); } }

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] * 0x1000000);
}

function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = (val >>> 8);
    buf[pos + 2] = (val >>> 16);
    buf[pos + 3] = (val >>> 24);
}

function readInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
    var str = '';
    var i = pos;

    while (i < end) {
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence =
            b0 > 0xEF ? 4 :
            b0 > 0xDF ? 3 :
            b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) { break; }

        var b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;

        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || (i + 1 === str.length)) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}

var index$5 = Point$1;

function Point$1(x, y) {
    this.x = x;
    this.y = y;
}

Point$1.prototype = {
    clone: function() { return new Point$1(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point$1.convert = function (a) {
    if (a instanceof Point$1) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point$1(a[0], a[1]);
    }
    return a;
};

var Point = index$5;

var vectortilefeature = VectorTileFeature$2;

function VectorTileFeature$2(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) { feature.id = pbf.readVarint(); }
    else if (tag == 2) { readTag(pbf, feature); }
    else if (tag == 3) { feature.type = pbf.readVarint(); }
    else if (tag == 4) { feature._geometry = pbf.pos; }
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature$2.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature$2.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) { lines.push(line); }
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {

            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
            if (line) {
                line.push(line[0].clone()); // closePolygon
            }

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) { lines.push(line); }

    return lines;
};

VectorTileFeature$2.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) { x1 = x; }
            if (x > x2) { x2 = x; }
            if (y < y1) { y1 = y; }
            if (y > y2) { y2 = y; }

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature$2.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature$2.types[this.type],
        i, j;

    function project(line) {
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    switch (this.type) {
    case 1:
        var points = [];
        for (i = 0; i < coords.length; i++) {
            points[i] = coords[i][0];
        }
        coords = points;
        project(coords);
        break;

    case 2:
        for (i = 0; i < coords.length; i++) {
            project(coords[i]);
        }
        break;

    case 3:
        coords = classifyRings(coords);
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                project(coords[i][j]);
            }
        }
        break;
    }

    if (coords.length === 1) {
        coords = coords[0];
    } else {
        type = 'Multi' + type;
    }

    var result = {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };

    if ('id' in this) {
        result.id = this.id;
    }

    return result;
};

// classifies an array of rings into polygons with outer rings and holes

function classifyRings(rings) {
    var len = rings.length;

    if (len <= 1) { return [rings]; }

    var polygons = [],
        polygon,
        ccw;

    for (var i = 0; i < len; i++) {
        var area = signedArea(rings[i]);
        if (area === 0) { continue; }

        if (ccw === undefined) { ccw = area < 0; }

        if (ccw === area < 0) {
            if (polygon) { polygons.push(polygon); }
            polygon = [rings[i]];

        } else {
            polygon.push(rings[i]);
        }
    }
    if (polygon) { polygons.push(polygon); }

    return polygons;
}

function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2.x - p1.x) * (p1.y + p2.y);
    }
    return sum;
}

var VectorTileFeature$1 = vectortilefeature;

var vectortilelayer = VectorTileLayer$2;

function VectorTileLayer$2(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) { layer.version = pbf.readVarint(); }
    else if (tag === 1) { layer.name = pbf.readString(); }
    else if (tag === 5) { layer.extent = pbf.readVarint(); }
    else if (tag === 2) { layer._features.push(pbf.pos); }
    else if (tag === 3) { layer._keys.push(pbf.readString()); }
    else if (tag === 4) { layer._values.push(readValueMessage(pbf)); }
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer$2.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) { throw new Error('feature index out of bounds'); }

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature$1(this._pbf, end, this.extent, this._keys, this._values);
};

var VectorTileLayer$1 = vectortilelayer;

var vectortile = VectorTile$1;

function VectorTile$1(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer$1(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) { layers[layer.name] = layer; }
    }
}

var VectorTile = vectortile;

L.SVG.Tile = L.SVG.extend({

	initialize: function (tileCoord, tileSize, options) {
		L.SVG.prototype.initialize.call(this, options);
		this._tileCoord = tileCoord;
		this._size = tileSize;

		this._initContainer();
		this._container.setAttribute('width', this._size.x);
		this._container.setAttribute('height', this._size.y);
		this._container.setAttribute('viewBox', [0, 0, this._size.x, this._size.y].join(' '));

		this._layers = {};
	},

	getCoord: function() {
		return this._tileCoord;
	},

	getContainer: function() {
		return this._container;
	},

	onAdd: L.Util.falseFn,

	addTo: function(map) {
		this._map = map;
		if (this.options.interactive) {
			for (var i in this._layers) {
				var layer = this._layers[i];
				// By default, Leaflet tiles do not have pointer events.
				layer._path.style.pointerEvents = 'auto';
				this._map._targets[L.stamp(layer._path)] = layer;
			}
		}
	},

	removeFrom: function (map) {
		if (this.options.interactive) {
			for (var i in this._layers) {
				var layer = this._layers[i];
				delete this._map._targets[L.stamp(layer._path)];
			}
		}
		delete this._map;
	},

	_initContainer: function() {
		L.SVG.prototype._initContainer.call(this);
		var rect =  L.SVG.create('rect');
	},

	/// TODO: Modify _initPath to include an extra parameter, a group name
	/// to order symbolizers by z-index

	_addPath: function (layer) {
		this._rootGroup.appendChild(layer._path);
		this._layers[L.stamp(layer)] = layer;
	},

	_updateIcon: function (layer) {
		var path = layer._path = L.SVG.create('image'),
		    icon = layer.options.icon,
		    options = icon.options,
		    size = L.point(options.iconSize),
		    anchor = options.iconAnchor ||
		        	 size && size.divideBy(2, true),
		    p = layer._point.subtract(anchor);
		path.setAttribute('x', p.x);
		path.setAttribute('y', p.y);
		path.setAttribute('width', size.x + 'px');
		path.setAttribute('height', size.y + 'px');
		path.setAttribute('href', options.iconUrl);
	}
});


L.svg.tile = function(tileCoord, tileSize, opts){
	return new L.SVG.Tile(tileCoord, tileSize, opts);
};

// 🍂class Symbolizer
// 🍂inherits Class
// The abstract Symbolizer class is mostly equivalent in concept to a `L.Path` - it's an interface for
// polylines, polygons and circles. But instead of representing leaflet Layers,
// it represents things that have to be drawn inside a vector tile.

// A vector tile *data layer* might have zero, one, or more *symbolizer definitions*
// A vector tile *feature* might have zero, one, or more *symbolizers*.
// The actual symbolizers applied will depend on filters and the symbolizer functions.

var Symbolizer = L.Class.extend({
	// 🍂method initialize(feature: GeoJSON, pxPerExtent: Number)
	// Initializes a new Line Symbolizer given a GeoJSON feature and the
	// pixel-to-coordinate-units ratio. Internal use only.

	// 🍂method render(renderer, style)
	// Renders this symbolizer in the given tiled renderer, with the given
	// `L.Path` options.  Internal use only.
	render: function(renderer, style) {
		this._renderer = renderer;
		this.options = style;
		renderer._initPath(this);
		renderer._updateStyle(this);
	},

	// 🍂method render(renderer, style)
	// Updates the `L.Path` options used to style this symbolizer, and re-renders it.
	// Internal use only.
	updateStyle: function(renderer, style) {
		this.options = style;
		renderer._updateStyle(this);
	},

	_getPixelBounds: function() {
		var parts = this._parts;
		var bounds = L.bounds([]);
		for (var i = 0; i < parts.length; i++) {
			var part = parts[i];
			for (var j = 0; j < part.length; j++) {
				bounds.extend(part[j]);
			}
		}

		var w = this._clickTolerance(),
		    p = new L.Point(w, w);

		bounds.min._subtract(p);
		bounds.max._add(p);

		return bounds;
	},
	_clickTolerance: L.Path.prototype._clickTolerance,
});

// Contains mixins which are common to the Line Symbolizer and the Fill Symbolizer.

var PolyBase = {
	_makeFeatureParts: function(feat, pxPerExtent) {
		var rings = feat.geometry;
		var coord;

		this._parts = [];
		for (var i = 0; i < rings.length; i++) {
			var ring = rings[i];
			var part = [];
			for (var j = 0; j < ring.length; j++) {
				coord = ring[j];
				// Protobuf vector tiles return {x: , y:}
				// Geojson-vt returns [,]
				part.push(L.point(coord).scaleBy(pxPerExtent));
			}
			this._parts.push(part);
		}
	},

	makeInteractive: function() {
		this._pxBounds = this._getPixelBounds();
	}
};

// 🍂class PointSymbolizer
// 🍂inherits CircleMarker
// A symbolizer for points.

var PointSymbolizer = L.CircleMarker.extend({
	includes: Symbolizer.prototype,

	statics: {
		iconCache: {}
	},

	initialize: function(feature, pxPerExtent) {
		this.properties = feature.properties;
		this._makeFeatureParts(feature, pxPerExtent);
	},

	render: function(renderer, style) {
		Symbolizer.prototype.render.call(this, renderer, style);
		this._radius = style.radius || L.CircleMarker.prototype.options.radius;
		this._updatePath();
	},

	_makeFeatureParts: function(feat, pxPerExtent) {
		var coord = feat.geometry[0];
		if (typeof coord[0] === 'object' && 'x' in coord[0]) {
			// Protobuf vector tiles return [{x: , y:}]
			this._point = L.point(coord[0]).scaleBy(pxPerExtent);
			this._empty = L.Util.falseFn;
		} else {
			// Geojson-vt returns [,]
			this._point = L.point(coord).scaleBy(pxPerExtent);
			this._empty = L.Util.falseFn;
		}
	},

	makeInteractive: function() {
		this._updateBounds();
	},

	updateStyle: function(renderer, style) {
		this._radius = style.radius || this._radius;
		this._updateBounds();
		return Symbolizer.prototype.updateStyle.call(this, renderer, style);
	},

	_updateBounds: function() {
		var icon = this.options.icon;
		if (icon) {
			var size = L.point(icon.options.iconSize),
			    anchor = icon.options.iconAnchor ||
			             size && size.divideBy(2, true),
			    p = this._point.subtract(anchor);
			this._pxBounds = new L.Bounds(p, p.add(icon.options.iconSize));
		} else {
			L.CircleMarker.prototype._updateBounds.call(this);
		}
	},

	_updatePath: function() {
		if (this.options.icon) {
			this._renderer._updateIcon(this);
		} else {
			L.CircleMarker.prototype._updatePath.call(this);
		}
	},

	_getImage: function () {
		if (this.options.icon) {
			var url = this.options.icon.options.iconUrl,
			    img = PointSymbolizer.iconCache[url];
			if (!img) {
				var icon = this.options.icon;
				img = PointSymbolizer.iconCache[url] = icon.createIcon();
			}
			return img;
		} else {
			return null;
		}

	},

	_containsPoint: function(p) {
		var icon = this.options.icon;
		if (icon) {
			return this._pxBounds.contains(p);
		} else {
			return L.CircleMarker.prototype._containsPoint.call(this, p);
		}
	}
});

// 🍂class LineSymbolizer
// 🍂inherits Polyline
// A symbolizer for lines. Can be applied to line and polygon features.

var LineSymbolizer = L.Polyline.extend({
	includes: [Symbolizer.prototype, PolyBase],

	initialize: function(feature, pxPerExtent) {
		this.properties = feature.properties;
		this._makeFeatureParts(feature, pxPerExtent);
	},

	render: function(renderer, style) {
		style.fill = false;
		Symbolizer.prototype.render.call(this, renderer, style);
		this._updatePath();
	},

	updateStyle: function(renderer, style) {
		style.fill = false;
		Symbolizer.prototype.updateStyle.call(this, renderer, style);
	},
});

// 🍂class FillSymbolizer
// 🍂inherits Polyline
// A symbolizer for filled areas. Applies only to polygon features.

var FillSymbolizer = L.Polygon.extend({
	includes: [Symbolizer.prototype, PolyBase],

	initialize: function(feature, pxPerExtent) {
		this.properties = feature.properties;
		this._makeFeatureParts(feature, pxPerExtent);
	},

	render: function(renderer, style) {
		Symbolizer.prototype.render.call(this, renderer, style);
		this._updatePath();
	}
});

/* 🍂class VectorGrid
 * 🍂inherits GridLayer
 *
 * A `VectorGrid` is a generic, abstract class for displaying tiled vector data.
 * it provides facilities for symbolizing and rendering the data in the vector
 * tiles, but lacks the functionality to fetch the vector tiles from wherever
 * they are.
 *
 * Extends Leaflet's `L.GridLayer`.
 */

L.VectorGrid = L.GridLayer.extend({

	options: {
		// 🍂option rendererFactory = L.svg.tile
		// A factory method which will be used to instantiate the per-tile renderers.
		rendererFactory: L.svg.tile,

		// 🍂option vectorTileLayerStyles: Object = {}
		// A data structure holding initial symbolizer definitions for the vector features.
		vectorTileLayerStyles: {},

		// 🍂option interactive: Boolean = false
		// Whether this `VectorGrid` fires `Interactive Layer` events.
		interactive: false,

		// 🍂option getFeatureId: Function = undefined
		// A function that, given a vector feature, returns an unique identifier for it, e.g.
		// `function(feat) { return feat.properties.uniqueIdField; }`.
		// Must be defined for `setFeatureStyle` to work.
	},

	initialize: function(options) {
		L.setOptions(this, options);
		L.GridLayer.prototype.initialize.apply(this, arguments);
		if (this.options.getFeatureId) {
			this._vectorTiles = {};
			this._overriddenStyles = {};
			this.on('tileunload', function(e) {
				var key = this._tileCoordsToKey(e.coords),
				    tile = this._vectorTiles[key];

				if (tile && this._map) {
					tile.removeFrom(this._map);
				}
				delete this._vectorTiles[key];
			}, this);
		}
		this._dataLayerNames = {};
	},

	createTile: function(coords, done) {
		var storeFeatures = this.options.getFeatureId;

		var tileSize = this.getTileSize();
		var renderer = this.options.rendererFactory(coords, tileSize, this.options);

		var vectorTilePromise = this._getVectorTilePromise(coords);

		if (storeFeatures) {
			this._vectorTiles[this._tileCoordsToKey(coords)] = renderer;
			renderer._features = {};
		}

		vectorTilePromise.then( function renderTile(vectorTile) {
			for (var layerName in vectorTile.layers) {
				this._dataLayerNames[layerName] = true;
				var layer = vectorTile.layers[layerName];

				var pxPerExtent = this.getTileSize().divideBy(layer.extent);

				var layerStyle = this.options.vectorTileLayerStyles[ layerName ] ||
				L.Path.prototype.options;

				for (var i = 0; i < layer.features.length; i++) {
					var feat = layer.features[i];
					var id;

					var styleOptions = layerStyle;
					if (storeFeatures) {
						id = this.options.getFeatureId(feat);
						var styleOverride = this._overriddenStyles[id];
						if (styleOverride) {
							if (styleOverride[layerName]) {
								styleOptions = styleOverride[layerName];
							} else {
								styleOptions = styleOverride;
							}
						}
					}

					if (styleOptions instanceof Function) {
						styleOptions = styleOptions(feat.properties, coords.z);
					}

					if (!(styleOptions instanceof Array)) {
						styleOptions = [styleOptions];
					}

					if (!styleOptions.length) {
						continue;
					}

					var featureLayer = this._createLayer(feat, pxPerExtent);

					for (var j = 0; j < styleOptions.length; j++) {
						var style = L.extend({}, L.Path.prototype.options, styleOptions[j]);
						featureLayer.render(renderer, style);
						renderer._addPath(featureLayer);
					}

					if (this.options.interactive) {
						featureLayer.makeInteractive();
					}

					if (storeFeatures) {
						renderer._features[id] = {
							layerName: layerName,
							feature: featureLayer
						};
					}
				}

			}
			if (this._map != null) {
				renderer.addTo(this._map);
			}
			L.Util.requestAnimFrame(done.bind(coords, null, null));
		}.bind(this));

		return renderer.getContainer();
	},

	// 🍂method setFeatureStyle(id: Number, layerStyle: L.Path Options): this
	// Given the unique ID for a vector features (as per the `getFeatureId` option),
	// re-symbolizes that feature across all tiles it appears in.
	setFeatureStyle: function(id, layerStyle) {
		this._overriddenStyles[id] = layerStyle;

		for (var tileKey in this._vectorTiles) {
			var tile = this._vectorTiles[tileKey];
			var features = tile._features;
			var data = features[id];
			if (data) {
				var feat = data.feature;

				var styleOptions = layerStyle;
				if (layerStyle[data.layerName]) {
					styleOptions = layerStyle[data.layerName];
				}

				this._updateStyles(feat, tile, styleOptions);
			}
		}
		return this;
	},

	// 🍂method setFeatureStyle(id: Number): this
	// Reverts the effects of a previous `setFeatureStyle` call.
	resetFeatureStyle: function(id) {
		delete this._overriddenStyles[id];

		for (var tileKey in this._vectorTiles) {
			var tile = this._vectorTiles[tileKey];
			var features = tile._features;
			var data = features[id];
			if (data) {
				var feat = data.feature;
				var styleOptions = this.options.vectorTileLayerStyles[ data.layerName ] ||
				L.Path.prototype.options;
				this._updateStyles(feat, tile, styleOptions);
			}
		}
		return this;
	},

	// 🍂method getDataLayerNames(): Array
	// Returns an array of strings, with all the known names of data layers in
	// the vector tiles displayed. Useful for introspection.
	getDataLayerNames: function() {
		return Object.keys(this._dataLayerNames);
	},

	_updateStyles: function(feat, renderer, styleOptions) {
		styleOptions = (styleOptions instanceof Function) ?
			styleOptions(feat.properties, renderer.getCoord().z) :
			styleOptions;

		if (!(styleOptions instanceof Array)) {
			styleOptions = [styleOptions];
		}

		for (var j = 0; j < styleOptions.length; j++) {
			var style = L.extend({}, L.Path.prototype.options, styleOptions[j]);
			feat.updateStyle(renderer, style);
		}
	},

	_createLayer: function(feat, pxPerExtent, layerStyle) {
		var layer;
		switch (feat.type) {
		case 1:
			layer = new PointSymbolizer(feat, pxPerExtent);
			break;
		case 2:
			layer = new LineSymbolizer(feat, pxPerExtent);
			break;
		case 3:
			layer = new FillSymbolizer(feat, pxPerExtent);
			break;
		}

		if (this.options.interactive) {
			layer.addEventParent(this);
		}

		return layer;
	},
});

/*
 * 🍂section Extension methods
 *
 * Classes inheriting from `VectorGrid` **must** define the `_getVectorTilePromise` private method.
 *
 * 🍂method getVectorTilePromise(coords: Object): Promise
 * Given a `coords` object in the form of `{x: Number, y: Number, z: Number}`,
 * this function must return a `Promise` for a vector tile.
 *
 */
L.vectorGrid = function (options) {
	return new L.VectorGrid(options);
};

/*
 * 🍂class VectorGrid.Protobuf
 * 🍂extends VectorGrid
 *
 * A `VectorGrid` for vector tiles fetched from the internet.
 * Tiles are supposed to be protobufs (AKA "protobuffer" or "Protocol Buffers"),
 * containing data which complies with the
 * [MapBox Vector Tile Specification](https://github.com/mapbox/vector-tile-spec/tree/master/2.1).
 *
 * This is the format used by:
 * - Mapbox Vector Tiles
 * - Mapzen Vector Tiles
 * - ESRI Vector Tiles
 * - [OpenMapTiles hosted Vector Tiles](https://openmaptiles.com/hosting/)
 *
 * 🍂example
 *
 * You must initialize a `VectorGrid.Protobuf` with a URL template, just like in
 * `L.TileLayer`s. The difference is that the template must point to vector tiles
 * (usually `.pbf` or `.mvt`) instead of raster (`.png` or `.jpg`) tiles, and that
 * you should define the styling for all the features.
 *
 * <br><br>
 *
 * For OpenMapTiles, with a key from [https://openmaptiles.org/docs/host/use-cdn/](https://openmaptiles.org/docs/host/use-cdn/),
 * initialization looks like this:
 *
 * ```
 * L.vectorGrid.protobuf("https://free-{s}.tilehosting.com/data/v3/{z}/{x}/{y}.pbf.pict?key={key}", {
 * 	vectorTileLayerStyles: { ... },
 * 	subdomains: "0123",
 * 	key: 'abcdefghi01234567890',
 * 	maxNativeZoom: 14
 * }).addTo(map);
 * ```
 *
 * And for Mapbox vector tiles, it looks like this:
 *
 * ```
 * L.vectorGrid.protobuf("https://{s}.tiles.mapbox.com/v4/mapbox.mapbox-streets-v6/{z}/{x}/{y}.vector.pbf?access_token={token}", {
 * 	vectorTileLayerStyles: { ... },
 * 	subdomains: "abcd",
 * 	token: "pk.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRTS.TUVWXTZ0123456789abcde"
 * }).addTo(map);
 * ```
 */
L.VectorGrid.Protobuf = L.VectorGrid.extend({

	options: {
		// 🍂section
		// As with `L.TileLayer`, the URL template might contain a reference to
		// any option (see the example above and note the `{key}` or `token` in the URL
		// template, and the corresponding option).
		//
		// 🍂option subdomains: String = 'abc'
		// Akin to the `subdomains` option for `L.TileLayer`.
		subdomains: 'abc',	// Like L.TileLayer
		//
		// 🍂option fetchOptions: Object = {}
		// options passed to `fetch`, e.g. {credentials: 'same-origin'} to send cookie for the current domain
		fetchOptions: {}
	},

	initialize: function(url, options) {
		// Inherits options from geojson-vt!
// 		this._slicer = geojsonvt(geojson, options);
		this._url = url;
		L.VectorGrid.prototype.initialize.call(this, options);
	},

	// 🍂method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	setUrl: function(url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	},

	_getSubdomain: L.TileLayer.prototype._getSubdomain,

	_getVectorTilePromise: function(coords) {
		var data = {
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: coords.z
// 			z: this._getZoomForUrl()	/// TODO: Maybe replicate TileLayer's maxNativeZoom
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) { // Should this option be available in Leaflet.VectorGrid?
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		var tileUrl = L.Util.template(this._url, L.extend(data, this.options));

		return fetch(tileUrl, this.options.fetchOptions).then(function(response){

			if (!response.ok) {
				return {layers:[]};
			}

			return response.blob().then( function (blob) {
// 				console.log(blob);

				var reader = new FileReader();
				return new Promise(function(resolve){
					reader.addEventListener("loadend", function() {
						// reader.result contains the contents of blob as a typed array

						// blob.type === 'application/x-protobuf'
						var pbf = new index( reader.result );
// 						console.log(pbf);
						return resolve(new VectorTile( pbf ));

					});
					reader.readAsArrayBuffer(blob);
				});
			});
		}).then(function(json){

// 			console.log('Vector tile:', json.layers);
// 			console.log('Vector tile water:', json.layers.water);	// Instance of VectorTileLayer

			// Normalize feature getters into actual instanced features
			for (var layerName in json.layers) {
				var feats = [];

				for (var i=0; i<json.layers[layerName].length; i++) {
					var feat = json.layers[layerName].feature(i);
					feat.geometry = feat.loadGeometry();
					feats.push(feat);
				}

				json.layers[layerName].features = feats;
			}

			return json;
		});
	}
});


// 🍂factory L.vectorGrid.protobuf(url: String, options)
// Instantiates a new protobuf VectorGrid with the given URL template and options
L.vectorGrid.protobuf = function (url, options) {
	return new L.VectorGrid.Protobuf(url, options);
};

var workerCode = __$strToBlobUri("'use strict';\n\nvar simplify_1 = simplify$1;\n\n// calculate simplification data using optimized Douglas-Peucker algorithm\n\nfunction simplify$1(points, tolerance) {\n\n    var sqTolerance = tolerance * tolerance,\n        len = points.length,\n        first = 0,\n        last = len - 1,\n        stack = [],\n        i, maxSqDist, sqDist, index;\n\n    // always retain the endpoints (1 is the max value)\n    points[first][2] = 1;\n    points[last][2] = 1;\n\n    // avoid recursion by using a stack\n    while (last) {\n\n        maxSqDist = 0;\n\n        for (i = first + 1; i < last; i++) {\n            sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n            if (sqDist > maxSqDist) {\n                index = i;\n                maxSqDist = sqDist;\n            }\n        }\n\n        if (maxSqDist > sqTolerance) {\n            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate\n            stack.push(first);\n            stack.push(index);\n            first = index;\n\n        } else {\n            last = stack.pop();\n            first = stack.pop();\n        }\n    }\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, a, b) {\n\n    var x = a[0], y = a[1],\n        bx = b[0], by = b[1],\n        px = p[0], py = p[1],\n        dx = bx - x,\n        dy = by - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = bx;\n            y = by;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n\nvar convert_1 = convert$1;\n\nvar simplify = simplify_1;\n\n// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data\n\nfunction convert$1(data, tolerance) {\n    var features = [];\n\n    if (data.type === 'FeatureCollection') {\n        for (var i = 0; i < data.features.length; i++) {\n            convertFeature(features, data.features[i], tolerance);\n        }\n    } else if (data.type === 'Feature') {\n        convertFeature(features, data, tolerance);\n\n    } else {\n        // single geometry or a geometry collection\n        convertFeature(features, {geometry: data}, tolerance);\n    }\n    return features;\n}\n\nfunction convertFeature(features, feature, tolerance) {\n    if (feature.geometry === null) {\n        // ignore features with null geometry\n        return;\n    }\n\n    var geom = feature.geometry,\n        type = geom.type,\n        coords = geom.coordinates,\n        tags = feature.properties,\n        i, j, rings, projectedRing;\n\n    if (type === 'Point') {\n        features.push(create(tags, 1, [projectPoint(coords)]));\n\n    } else if (type === 'MultiPoint') {\n        features.push(create(tags, 1, project(coords)));\n\n    } else if (type === 'LineString') {\n        features.push(create(tags, 2, [project(coords, tolerance)]));\n\n    } else if (type === 'MultiLineString' || type === 'Polygon') {\n        rings = [];\n        for (i = 0; i < coords.length; i++) {\n            projectedRing = project(coords[i], tolerance);\n            if (type === 'Polygon') { projectedRing.outer = (i === 0); }\n            rings.push(projectedRing);\n        }\n        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));\n\n    } else if (type === 'MultiPolygon') {\n        rings = [];\n        for (i = 0; i < coords.length; i++) {\n            for (j = 0; j < coords[i].length; j++) {\n                projectedRing = project(coords[i][j], tolerance);\n                projectedRing.outer = (j === 0);\n                rings.push(projectedRing);\n            }\n        }\n        features.push(create(tags, 3, rings));\n\n    } else if (type === 'GeometryCollection') {\n        for (i = 0; i < geom.geometries.length; i++) {\n            convertFeature(features, {\n                geometry: geom.geometries[i],\n                properties: tags\n            }, tolerance);\n        }\n\n    } else {\n        throw new Error('Input data is not a valid GeoJSON object.');\n    }\n}\n\nfunction create(tags, type, geometry) {\n    var feature = {\n        geometry: geometry,\n        type: type,\n        tags: tags || null,\n        min: [2, 1], // initial bbox values;\n        max: [-1, 0]  // note that coords are usually in [0..1] range\n    };\n    calcBBox(feature);\n    return feature;\n}\n\nfunction project(lonlats, tolerance) {\n    var projected = [];\n    for (var i = 0; i < lonlats.length; i++) {\n        projected.push(projectPoint(lonlats[i]));\n    }\n    if (tolerance) {\n        simplify(projected, tolerance);\n        calcSize(projected);\n    }\n    return projected;\n}\n\nfunction projectPoint(p) {\n    var sin = Math.sin(p[1] * Math.PI / 180),\n        x = (p[0] / 360 + 0.5),\n        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n\n    y = y < 0 ? 0 :\n        y > 1 ? 1 : y;\n\n    return [x, y, 0];\n}\n\n// calculate area and length of the poly\nfunction calcSize(points) {\n    var area = 0,\n        dist = 0;\n\n    for (var i = 0, a, b; i < points.length - 1; i++) {\n        a = b || points[i];\n        b = points[i + 1];\n\n        area += a[0] * b[1] - b[0] * a[1];\n\n        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation\n        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);\n    }\n    points.area = Math.abs(area / 2);\n    points.dist = dist;\n}\n\n// calculate the feature bounding box for faster clipping later\nfunction calcBBox(feature) {\n    var geometry = feature.geometry,\n        min = feature.min,\n        max = feature.max;\n\n    if (feature.type === 1) { calcRingBBox(min, max, geometry); }\n    else { for (var i = 0; i < geometry.length; i++) { calcRingBBox(min, max, geometry[i]); } }\n\n    return feature;\n}\n\nfunction calcRingBBox(min, max, points) {\n    for (var i = 0, p; i < points.length; i++) {\n        p = points[i];\n        min[0] = Math.min(p[0], min[0]);\n        max[0] = Math.max(p[0], max[0]);\n        min[1] = Math.min(p[1], min[1]);\n        max[1] = Math.max(p[1], max[1]);\n    }\n}\n\nvar tile = transformTile;\nvar point = transformPoint;\n\n// Transforms the coordinates of each feature in the given tile from\n// mercator-projected space into (extent x extent) tile space.\nfunction transformTile(tile, extent) {\n    if (tile.transformed) { return tile; }\n\n    var z2 = tile.z2,\n        tx = tile.x,\n        ty = tile.y,\n        i, j, k;\n\n    for (i = 0; i < tile.features.length; i++) {\n        var feature = tile.features[i],\n            geom = feature.geometry,\n            type = feature.type;\n\n        if (type === 1) {\n            for (j = 0; j < geom.length; j++) { geom[j] = transformPoint(geom[j], extent, z2, tx, ty); }\n\n        } else {\n            for (j = 0; j < geom.length; j++) {\n                var ring = geom[j];\n                for (k = 0; k < ring.length; k++) { ring[k] = transformPoint(ring[k], extent, z2, tx, ty); }\n            }\n        }\n    }\n\n    tile.transformed = true;\n\n    return tile;\n}\n\nfunction transformPoint(p, extent, z2, tx, ty) {\n    var x = Math.round(extent * (p[0] * z2 - tx)),\n        y = Math.round(extent * (p[1] * z2 - ty));\n    return [x, y];\n}\n\nvar transform$1 = {\n	tile: tile,\n	point: point\n};\n\nvar clip_1 = clip$1;\n\n/* clip features between two axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   \____|____/\n *     |        |\n */\n\nfunction clip$1(features, scale, k1, k2, axis, intersect, minAll, maxAll) {\n\n    k1 /= scale;\n    k2 /= scale;\n\n    if (minAll >= k1 && maxAll <= k2) { return features; } // trivial accept\n    else if (minAll > k2 || maxAll < k1) { return null; } // trivial reject\n\n    var clipped = [];\n\n    for (var i = 0; i < features.length; i++) {\n\n        var feature = features[i],\n            geometry = feature.geometry,\n            type = feature.type,\n            min, max;\n\n        min = feature.min[axis];\n        max = feature.max[axis];\n\n        if (min >= k1 && max <= k2) { // trivial accept\n            clipped.push(feature);\n            continue;\n        } else if (min > k2 || max < k1) { continue; } // trivial reject\n\n        var slices = type === 1 ?\n                clipPoints(geometry, k1, k2, axis) :\n                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);\n\n        if (slices.length) {\n            // if a feature got clipped, it will likely get clipped on the next zoom level as well,\n            // so there's no need to recalculate bboxes\n            clipped.push({\n                geometry: slices,\n                type: type,\n                tags: features[i].tags || null,\n                min: feature.min,\n                max: feature.max\n            });\n        }\n    }\n\n    return clipped.length ? clipped : null;\n}\n\nfunction clipPoints(geometry, k1, k2, axis) {\n    var slice = [];\n\n    for (var i = 0; i < geometry.length; i++) {\n        var a = geometry[i],\n            ak = a[axis];\n\n        if (ak >= k1 && ak <= k2) { slice.push(a); }\n    }\n    return slice;\n}\n\nfunction clipGeometry(geometry, k1, k2, axis, intersect, closed) {\n\n    var slices = [];\n\n    for (var i = 0; i < geometry.length; i++) {\n\n        var ak = 0,\n            bk = 0,\n            b = null,\n            points = geometry[i],\n            area = points.area,\n            dist = points.dist,\n            outer = points.outer,\n            len = points.length,\n            a, j, last;\n\n        var slice = [];\n\n        for (j = 0; j < len - 1; j++) {\n            a = b || points[j];\n            b = points[j + 1];\n            ak = bk || a[axis];\n            bk = b[axis];\n\n            if (ak < k1) {\n\n                if ((bk > k2)) { // ---|-----|-->\n                    slice.push(intersect(a, b, k1), intersect(a, b, k2));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n\n                } else if (bk >= k1) { slice.push(intersect(a, b, k1)); } // ---|-->  |\n\n            } else if (ak > k2) {\n\n                if ((bk < k1)) { // <--|-----|---\n                    slice.push(intersect(a, b, k2), intersect(a, b, k1));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n\n                } else if (bk <= k2) { slice.push(intersect(a, b, k2)); } // |  <--|---\n\n            } else {\n\n                slice.push(a);\n\n                if (bk < k1) { // <--|---  |\n                    slice.push(intersect(a, b, k1));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n\n                } else if (bk > k2) { // |  ---|-->\n                    slice.push(intersect(a, b, k2));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n                }\n                // | --> |\n            }\n        }\n\n        // add the last point\n        a = points[len - 1];\n        ak = a[axis];\n        if (ak >= k1 && ak <= k2) { slice.push(a); }\n\n        // close the polygon if its endpoints are not the same after clipping\n\n        last = slice[slice.length - 1];\n        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) { slice.push(slice[0]); }\n\n        // add the final slice\n        newSlice(slices, slice, area, dist, outer);\n    }\n\n    return slices;\n}\n\nfunction newSlice(slices, slice, area, dist, outer) {\n    if (slice.length) {\n        // we don't recalculate the area/length of the unclipped geometry because the case where it goes\n        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work\n        slice.area = area;\n        slice.dist = dist;\n        if (outer !== undefined) { slice.outer = outer; }\n\n        slices.push(slice);\n    }\n    return [];\n}\n\nvar clip$2 = clip_1;\n\nvar wrap_1 = wrap$1;\n\nfunction wrap$1(features, buffer, intersectX) {\n    var merged = features,\n        left  = clip$2(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy\n        right = clip$2(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy\n\n    if (left || right) {\n        merged = clip$2(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy\n\n        if (left) { merged = shiftFeatureCoords(left, 1).concat(merged); } // merge left into center\n        if (right) { merged = merged.concat(shiftFeatureCoords(right, -1)); } // merge right into center\n    }\n\n    return merged;\n}\n\nfunction shiftFeatureCoords(features, offset) {\n    var newFeatures = [];\n\n    for (var i = 0; i < features.length; i++) {\n        var feature = features[i],\n            type = feature.type;\n\n        var newGeometry;\n\n        if (type === 1) {\n            newGeometry = shiftCoords(feature.geometry, offset);\n        } else {\n            newGeometry = [];\n            for (var j = 0; j < feature.geometry.length; j++) {\n                newGeometry.push(shiftCoords(feature.geometry[j], offset));\n            }\n        }\n\n        newFeatures.push({\n            geometry: newGeometry,\n            type: type,\n            tags: feature.tags,\n            min: [feature.min[0] + offset, feature.min[1]],\n            max: [feature.max[0] + offset, feature.max[1]]\n        });\n    }\n\n    return newFeatures;\n}\n\nfunction shiftCoords(points, offset) {\n    var newPoints = [];\n    newPoints.area = points.area;\n    newPoints.dist = points.dist;\n\n    for (var i = 0; i < points.length; i++) {\n        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);\n    }\n    return newPoints;\n}\n\nvar tile$1 = createTile$1;\n\nfunction createTile$1(features, z2, tx, ty, tolerance, noSimplify) {\n    var tile = {\n        features: [],\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: 0,\n        source: null,\n        x: tx,\n        y: ty,\n        z2: z2,\n        transformed: false,\n        min: [2, 1],\n        max: [-1, 0]\n    };\n    for (var i = 0; i < features.length; i++) {\n        tile.numFeatures++;\n        addFeature(tile, features[i], tolerance, noSimplify);\n\n        var min = features[i].min,\n            max = features[i].max;\n\n        if (min[0] < tile.min[0]) { tile.min[0] = min[0]; }\n        if (min[1] < tile.min[1]) { tile.min[1] = min[1]; }\n        if (max[0] > tile.max[0]) { tile.max[0] = max[0]; }\n        if (max[1] > tile.max[1]) { tile.max[1] = max[1]; }\n    }\n    return tile;\n}\n\nfunction addFeature(tile, feature, tolerance, noSimplify) {\n\n    var geom = feature.geometry,\n        type = feature.type,\n        simplified = [],\n        sqTolerance = tolerance * tolerance,\n        i, j, ring, p;\n\n    if (type === 1) {\n        for (i = 0; i < geom.length; i++) {\n            simplified.push(geom[i]);\n            tile.numPoints++;\n            tile.numSimplified++;\n        }\n\n    } else {\n\n        // simplify and transform projected coordinates for tile geometry\n        for (i = 0; i < geom.length; i++) {\n            ring = geom[i];\n\n            // filter out tiny polylines & polygons\n            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||\n                                (type === 3 && ring.area < sqTolerance))) {\n                tile.numPoints += ring.length;\n                continue;\n            }\n\n            var simplifiedRing = [];\n\n            for (j = 0; j < ring.length; j++) {\n                p = ring[j];\n                // keep points with importance > tolerance\n                if (noSimplify || p[2] > sqTolerance) {\n                    simplifiedRing.push(p);\n                    tile.numSimplified++;\n                }\n                tile.numPoints++;\n            }\n\n            if (type === 3) { rewind(simplifiedRing, ring.outer); }\n\n            simplified.push(simplifiedRing);\n        }\n    }\n\n    if (simplified.length) {\n        tile.features.push({\n            geometry: simplified,\n            type: type,\n            tags: feature.tags || null\n        });\n    }\n}\n\nfunction rewind(ring, clockwise) {\n    var area = signedArea(ring);\n    if (area < 0 === clockwise) { ring.reverse(); }\n}\n\nfunction signedArea(ring) {\n    var sum = 0;\n    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);\n    }\n    return sum;\n}\n\nvar index = geojsonvt;\n\nvar convert = convert_1;\nvar transform = transform$1;\nvar clip = clip_1;\nvar wrap = wrap_1;\nvar createTile = tile$1;     // final simplified tile generation\n\n\nfunction geojsonvt(data, options) {\n    return new GeoJSONVT(data, options);\n}\n\nfunction GeoJSONVT(data, options) {\n    options = this.options = extend(Object.create(this.options), options);\n\n    var debug = options.debug;\n\n    if (debug) { console.time('preprocess data'); }\n\n    var z2 = 1 << options.maxZoom, // 2^z\n        features = convert(data, options.tolerance / (z2 * options.extent));\n\n    this.tiles = {};\n    this.tileCoords = [];\n\n    if (debug) {\n        console.timeEnd('preprocess data');\n        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);\n        console.time('generate tiles');\n        this.stats = {};\n        this.total = 0;\n    }\n\n    features = wrap(features, options.buffer / options.extent, intersectX);\n\n    // start slicing from the top tile down\n    if (features.length) { this.splitTile(features, 0, 0, 0); }\n\n    if (debug) {\n        if (features.length) { console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints); }\n        console.timeEnd('generate tiles');\n        console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n    }\n}\n\nGeoJSONVT.prototype.options = {\n    maxZoom: 14,            // max zoom to preserve detail on\n    indexMaxZoom: 5,        // max zoom in the tile index\n    indexMaxPoints: 100000, // max number of points per tile in the tile index\n    solidChildren: false,   // whether to tile solid square tiles further\n    tolerance: 3,           // simplification tolerance (higher means simpler)\n    extent: 4096,           // tile extent\n    buffer: 64,             // tile buffer on each side\n    debug: 0                // logging level (0, 1 or 2)\n};\n\nGeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {\n    var this$1 = this;\n\n\n    var stack = [features, z, x, y],\n        options = this.options,\n        debug = options.debug,\n        solid = null;\n\n    // avoid recursion by using a processing queue\n    while (stack.length) {\n        y = stack.pop();\n        x = stack.pop();\n        z = stack.pop();\n        features = stack.pop();\n\n        var z2 = 1 << z,\n            id = toID(z, x, y),\n            tile = this$1.tiles[id],\n            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);\n\n        if (!tile) {\n            if (debug > 1) { console.time('creation'); }\n\n            tile = this$1.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);\n            this$1.tileCoords.push({z: z, x: x, y: y});\n\n            if (debug) {\n                if (debug > 1) {\n                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',\n                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);\n                    console.timeEnd('creation');\n                }\n                var key = 'z' + z;\n                this$1.stats[key] = (this$1.stats[key] || 0) + 1;\n                this$1.total++;\n            }\n        }\n\n        // save reference to original geometry in tile so that we can drill down later if we stop now\n        tile.source = features;\n\n        // if it's the first-pass tiling\n        if (!cz) {\n            // stop tiling if we reached max zoom, or if the tile is too simple\n            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) { continue; }\n\n        // if a drilldown to a specific tile\n        } else {\n            // stop tiling if we reached base zoom or our target tile zoom\n            if (z === options.maxZoom || z === cz) { continue; }\n\n            // stop tiling if it's not an ancestor of the target tile\n            var m = 1 << (cz - z);\n            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) { continue; }\n        }\n\n        // stop tiling if the tile is solid clipped square\n        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) {\n            if (cz) { solid = z; } // and remember the zoom if we're drilling down\n            continue;\n        }\n\n        // if we slice further down, no need to keep source geometry\n        tile.source = null;\n\n        if (debug > 1) { console.time('clipping'); }\n\n        // values we'll use for clipping\n        var k1 = 0.5 * options.buffer / options.extent,\n            k2 = 0.5 - k1,\n            k3 = 0.5 + k1,\n            k4 = 1 + k1,\n            tl, bl, tr, br, left, right;\n\n        tl = bl = tr = br = null;\n\n        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);\n        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);\n\n        if (left) {\n            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);\n            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);\n        }\n\n        if (right) {\n            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);\n            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);\n        }\n\n        if (debug > 1) { console.timeEnd('clipping'); }\n\n        if (tl) { stack.push(tl, z + 1, x * 2,     y * 2); }\n        if (bl) { stack.push(bl, z + 1, x * 2,     y * 2 + 1); }\n        if (tr) { stack.push(tr, z + 1, x * 2 + 1, y * 2); }\n        if (br) { stack.push(br, z + 1, x * 2 + 1, y * 2 + 1); }\n    }\n\n    return solid;\n};\n\nGeoJSONVT.prototype.getTile = function (z, x, y) {\n    var this$1 = this;\n\n    var options = this.options,\n        extent = options.extent,\n        debug = options.debug;\n\n    var z2 = 1 << z;\n    x = ((x % z2) + z2) % z2; // wrap tile x coordinate\n\n    var id = toID(z, x, y);\n    if (this.tiles[id]) { return transform.tile(this.tiles[id], extent); }\n\n    if (debug > 1) { console.log('drilling down to z%d-%d-%d', z, x, y); }\n\n    var z0 = z,\n        x0 = x,\n        y0 = y,\n        parent;\n\n    while (!parent && z0 > 0) {\n        z0--;\n        x0 = Math.floor(x0 / 2);\n        y0 = Math.floor(y0 / 2);\n        parent = this$1.tiles[toID(z0, x0, y0)];\n    }\n\n    if (!parent || !parent.source) { return null; }\n\n    // if we found a parent tile containing the original geometry, we can drill down from it\n    if (debug > 1) { console.log('found parent tile z%d-%d-%d', z0, x0, y0); }\n\n    // it parent tile is a solid clipped square, return it instead since it's identical\n    if (isClippedSquare(parent, extent, options.buffer)) { return transform.tile(parent, extent); }\n\n    if (debug > 1) { console.time('drilling down'); }\n    var solid = this.splitTile(parent.source, z0, x0, y0, z, x, y);\n    if (debug > 1) { console.timeEnd('drilling down'); }\n\n    // one of the parent tiles was a solid clipped square\n    if (solid !== null) {\n        var m = 1 << (z - solid);\n        id = toID(solid, Math.floor(x / m), Math.floor(y / m));\n    }\n\n    return this.tiles[id] ? transform.tile(this.tiles[id], extent) : null;\n};\n\nfunction toID(z, x, y) {\n    return (((1 << z) * y + x) * 32) + z;\n}\n\nfunction intersectX(a, b, x) {\n    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];\n}\nfunction intersectY(a, b, y) {\n    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];\n}\n\nfunction extend(dest, src) {\n    for (var i in src) { dest[i] = src[i]; }\n    return dest;\n}\n\n// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further\nfunction isClippedSquare(tile, extent, buffer) {\n\n    var features = tile.source;\n    if (features.length !== 1) { return false; }\n\n    var feature = features[0];\n    if (feature.type !== 3 || feature.geometry.length > 1) { return false; }\n\n    var len = feature.geometry[0].length;\n    if (len !== 5) { return false; }\n\n    for (var i = 0; i < len; i++) {\n        var p = transform.point(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);\n        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||\n            (p[1] !== -buffer && p[1] !== extent + buffer)) { return false; }\n    }\n\n    return true;\n}\n\nvar identity = function(x) {\n  return x;\n};\n\nvar transform$3 = function(topology) {\n  if ((transform = topology.transform) == null) { return identity; }\n  var transform,\n      x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(point, i) {\n    if (!i) { x0 = y0 = 0; }\n    point[0] = (x0 += point[0]) * kx + dx;\n    point[1] = (y0 += point[1]) * ky + dy;\n    return point;\n  };\n};\n\nvar bbox = function(topology) {\n  var bbox = topology.bbox;\n\n  function bboxPoint(p0) {\n    p1[0] = p0[0], p1[1] = p0[1], t(p1);\n    if (p1[0] < x0) { x0 = p1[0]; }\n    if (p1[0] > x1) { x1 = p1[0]; }\n    if (p1[1] < y0) { y0 = p1[1]; }\n    if (p1[1] > y1) { y1 = p1[1]; }\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  if (!bbox) {\n    var t = transform$3(topology), p0, p1 = new Array(2), name,\n        x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n    topology.arcs.forEach(function(arc) {\n      var i = -1, n = arc.length;\n      while (++i < n) {\n        p0 = arc[i], p1[0] = p0[0], p1[1] = p0[1], t(p1, i);\n        if (p1[0] < x0) { x0 = p1[0]; }\n        if (p1[0] > x1) { x1 = p1[0]; }\n        if (p1[1] < y0) { y0 = p1[1]; }\n        if (p1[1] > y1) { y1 = p1[1]; }\n      }\n    });\n\n    for (name in topology.objects) {\n      bboxGeometry(topology.objects[name]);\n    }\n\n    bbox = topology.bbox = [x0, y0, x1, y1];\n  }\n\n  return bbox;\n};\n\nvar reverse = function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) { t = array[i], array[i++] = array[j], array[j] = t; }\n};\n\nvar feature = function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature$1(topology, o); })}\n      : feature$1(topology, o);\n};\n\nfunction feature$1(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nfunction object(topology, o) {\n  var transformPoint = transform$3(topology),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) { points.pop(); }\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k].slice(), k));\n    }\n    if (i < 0) { reverse(points, n); }\n  }\n\n  function point(p) {\n    return transformPoint(p.slice());\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) { arc(arcs[i], points); }\n    if (points.length < 2) { points.push(points[0].slice()); }\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) { points.push(points[0].slice()); }\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n\nvar stitch = function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) { p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; }); }\n    else { p1 = arc[arc.length - 1]; }\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) { fragments.push([i]); } });\n\n  return fragments;\n};\n\nfunction extractArcs(topology, object$$1, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object$$1);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) { arcs.push(geoms[0].i); } });\n\n  return arcs;\n}\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) { a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0]; }\n  return Math.abs(area); // Note: doubled area!\n}\n\nvar bisect = function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n};\n\nvar slicers = {};\nvar options;\n\nonmessage = function (e) {\n	if (e.data[0] === 'slice') {\n		// Given a blob of GeoJSON and some topojson/geojson-vt options, do the slicing.\n		var geojson = e.data[1];\n		options     = e.data[2];\n\n		if (geojson.type && geojson.type === 'Topology') {\n			for (var layerName in geojson.objects) {\n				slicers[layerName] = index(\n					feature(geojson, geojson.objects[layerName])\n				, options);\n			}\n		} else {\n			slicers[options.vectorTileLayerName] = index(geojson, options);\n		}\n\n	} else if (e.data[0] === 'get') {\n		// Gets the vector tile for the given coordinates, sends it back as a message\n		var coords = e.data[1];\n\n		var tileLayers = {};\n		for (var layerName in slicers) {\n			var slicedTileLayer = slicers[layerName].getTile(coords.z, coords.x, coords.y);\n\n			if (slicedTileLayer) {\n				var vectorTileLayer = {\n					features: [],\n					extent: options.extent,\n					name: options.vectorTileLayerName,\n					length: slicedTileLayer.features.length\n				};\n\n				for (var i in slicedTileLayer.features) {\n					var feat = {\n						geometry: slicedTileLayer.features[i].geometry,\n						properties: slicedTileLayer.features[i].tags,\n						type: slicedTileLayer.features[i].type	// 1 = point, 2 = line, 3 = polygon\n					};\n					vectorTileLayer.features.push(feat);\n				}\n				tileLayers[layerName] = vectorTileLayer;\n			}\n		}\n		postMessage({ layers: tileLayers, coords: coords });\n	}\n};\n//# sourceMap" + "pingURL=slicerWebWorker.js.worker.map\n", "text/plain; charset=us-ascii", false);

// The geojson/topojson is sliced into tiles via a web worker.
// This import statement depends on rollup-file-as-blob, so that the
// variable 'workerCode' is a blob URL.

/*
 * 🍂class VectorGrid.Slicer
 * 🍂extends VectorGrid
 *
 * A `VectorGrid` for slicing up big GeoJSON or TopoJSON documents in vector
 * tiles, leveraging [`geojson-vt`](https://github.com/mapbox/geojson-vt).
 *
 * 🍂example
 *
 * ```
 * var geoJsonDocument = {
 * 	type: 'FeatureCollection',
 * 	features: [ ... ]
 * };
 *
 * L.vectorGrid.slicer(geoJsonDocument, {
 * 	vectorTileLayerStyles: {
 * 		sliced: { ... }
 * 	}
 * }).addTo(map);
 *
 * ```
 *
 * `VectorGrid.Slicer` can also handle [TopoJSON](https://github.com/mbostock/topojson) transparently:
 * ```js
 * var layer = L.vectorGrid.slicer(topojson, options);
 * ```
 *
 * The TopoJSON format [implicitly groups features into "objects"](https://github.com/mbostock/topojson-specification/blob/master/README.md#215-objects).
 * These will be transformed into vector tile layer names when styling (the
 * `vectorTileLayerName` option is ignored when using TopoJSON).
 *
 */

L.VectorGrid.Slicer = L.VectorGrid.extend({

	options: {
		// 🍂section
		// Additionally to these options, `VectorGrid.Slicer` can take in any
		// of the [`geojson-vt` options](https://github.com/mapbox/geojson-vt#options).

		// 🍂option vectorTileLayerName: String = 'sliced'
		// Vector tiles contain a set of *data layers*, and those data layers
		// contain features. Thus, the slicer creates one data layer, with
		// the name given in this option. This is important for symbolizing the data.
		vectorTileLayerName: 'sliced',

		extent: 4096,	// Default for geojson-vt
		maxZoom: 14  	// Default for geojson-vt
	},

	initialize: function(geojson, options) {
		L.VectorGrid.prototype.initialize.call(this, options);

		// Create a shallow copy of this.options, excluding things that might
		// be functions - we only care about topojson/geojsonvt options
		var options = {};
		for (var i in this.options) {
			if (i !== 'rendererFactory' &&
				i !== 'vectorTileLayerStyles' &&
				typeof (this.options[i]) !== 'function'
			) {
				options[i] = this.options[i];
			}
		}

// 		this._worker = new Worker(window.URL.createObjectURL(new Blob([workerCode])));
		this._worker = new Worker(workerCode);

		// Send initial data to worker.
		this._worker.postMessage(['slice', geojson, options]);

	},


	_getVectorTilePromise: function(coords) {

		var _this = this;

		var p = new Promise( function waitForWorker(res) {
			_this._worker.addEventListener('message', function recv(m) {
				if (m.data.coords &&
				    m.data.coords.x === coords.x &&
				    m.data.coords.y === coords.y &&
				    m.data.coords.z === coords.z ) {

					res(m.data);
					_this._worker.removeEventListener('message', recv);
				}
			});
		});

		this._worker.postMessage(['get', coords]);

		return p;
	},

});


L.vectorGrid.slicer = function (geojson, options) {
	return new L.VectorGrid.Slicer(geojson, options);
};

L.Canvas.Tile = L.Canvas.extend({

	initialize: function (tileCoord, tileSize, options) {
		L.Canvas.prototype.initialize.call(this, options);
		this._tileCoord = tileCoord;
		this._size = tileSize;

		this._initContainer();
		this._container.setAttribute('width', this._size.x);
		this._container.setAttribute('height', this._size.y);
		this._layers = {};
		this._drawnLayers = {};
		this._drawing = true;

		if (options.interactive) {
			// By default, Leaflet tiles do not have pointer events
			this._container.style.pointerEvents = 'auto';
		}
	},

	getCoord: function() {
		return this._tileCoord;
	},

	getContainer: function() {
		return this._container;
	},

	getOffset: function() {
		return this._tileCoord.scaleBy(this._size).subtract(this._map.getPixelOrigin());
	},

	onAdd: L.Util.falseFn,

	addTo: function(map) {
		this._map = map;
	},

	removeFrom: function (map) {
		delete this._map;
	},

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e).subtract(this.getOffset()), layer, clickedLayer;

		for (var id in this._layers) {
			layer = this._layers[id];
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				clickedLayer = layer;
			}
		}
		if (clickedLayer)  {
			L.DomEvent.fakeStop(e);
			this._fireEvent([clickedLayer], e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e).subtract(this.getOffset());
		this._handleMouseHover(e, point);
	},

	/// TODO: Modify _initPath to include an extra parameter, a group name
	/// to order symbolizers by z-index

	_updateIcon: function (layer) {
		if (!this._drawing) { return; }

		var icon = layer.options.icon,
		    options = icon.options,
		    size = L.point(options.iconSize),
		    anchor = options.iconAnchor ||
		        	 size && size.divideBy(2, true),
		    p = layer._point.subtract(anchor),
		    ctx = this._ctx,
		    img = layer._getImage();

		if (img.complete) {
			ctx.drawImage(img, p.x, p.y, size.x, size.y);
		} else {
			L.DomEvent.on(img, 'load', function() {
				ctx.drawImage(img, p.x, p.y, size.x, size.y);
			});
		}

		this._drawnLayers[layer._leaflet_id] = layer;
	}
});


L.canvas.tile = function(tileCoord, tileSize, opts){
	return new L.Canvas.Tile(tileCoord, tileSize, opts);
};

// Aux file to bundle everything together, including the optional dependencies
// for protobuf tiles

}());
//# sourceMappingURL=Leaflet.VectorGrid.bundled.js.map



/** 
* @targomo/core "0.2.14" http://targomo.com
* The JavaScript (& TypeScript) API for Targomo's time-based access mapping services.
* (c) 2019 Targomo
*/
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.tgm = {})));
}(this, (function (exports) { 'use strict';

(function(self) {
  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    };

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue+','+value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) { items.push(name); });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) { items.push(value); });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) { items.push([name, value]); });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);
      var xhr = new XMLHttpRequest();

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  };
  self.fetch.polyfill = true;
})(typeof self !== 'undefined' ? self : window);

// TODO: or rename to ClientDefaults maybe to make it more clear
// TODO: add more defaults here ...ex same stuff as in r360-js
var ClientConfig = /** @class */ (function () {
    // routeTypes  = [
    //   // non transit
    //   { routeType : 'WALK'     , color : 'red',       haloColor : 'white'},
    //   { routeType : 'BIKE'     , color : '#558D54',   haloColor : 'white'},
    //   { routeType : 'CAR'      , color : '#558D54',   haloColor : 'white'},
    //   { routeType : 'TRANSFER' , color : '#C1272D',   haloColor : 'white'},
    //   // berlin
    //   { routeType : 102        , color : '#006837',   haloColor : 'white' },
    //   { routeType : 400        , color : '#156ab8',   haloColor : 'white' },
    //   { routeType : 900        , color : 'red',       haloColor : 'white' },
    //   { routeType : 700        , color : '#A3007C',   haloColor : 'white' },
    //   { routeType : 1000       , color : 'blue',      haloColor : 'white' },
    //   { routeType : 109        , color : '#006F35',   haloColor : 'white' },
    //   { routeType : 100        , color : 'red',       haloColor : 'white' },
    //   // new york
    //   { routeType : 1          , color : 'red',       haloColor : 'red'},
    //   { routeType : 2          , color : 'blue',      haloColor : 'blue'},
    //   { routeType : 3          , color : 'yellow',    haloColor : 'yellow'},
    //   { routeType : 0          , color : 'green',     haloColor : 'green'},
    //   { routeType : 4          , color : 'orange',    haloColor : 'orange'},
    //   { routeType : 5          , color : 'red',       haloColor : 'red'},
    //   { routeType : 6          , color : 'blue',      haloColor : 'blue'},
    //   { routeType : 7          , color : 'yellow',    haloColor : 'yellow' }
    // ]
    function ClientConfig(options) {
        this.serverUrl = 'https://api.targomo.com/';
        this.statisticsUrl = 'https://api.targomo.com/statistics/';
        this.tilesUrl = 'https://api.targomo.com/vector-statistics/';
        this.poiUrl = 'https://api.targomo.com/pointofinterest/';
        this.mapTilesUrl = 'https://maps.targomo.com/';
        this.photonGeocoderUrl = 'https://api.targomo.com/geocode/';
        this.overpassUrl = 'https://api.targomo.com/overpass/';
        this.fleetsUrl = 'https://api.targomo.com/fleetplanner/';
        this.basemapsUrl = 'https://maps.targomo.com/styles/';
        this.version = 1;
        this.debug = false;
        Object.assign(this, options);
    }
    return ClientConfig;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};









function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var SimpleLRUEntry = /** @class */ (function () {
    function SimpleLRUEntry(value, key, previous, next) {
        this.value = value;
        this.key = key;
        this.previous = previous;
        this.next = next;
    }
    return SimpleLRUEntry;
}());
/**
 * Extremely simple LRU (to avoid includinng another library)...However when more functionality is needed then an existing library is better
 */
var SimpleLRU = /** @class */ (function () {
    function SimpleLRU(capacity) {
        if (capacity === void 0) { capacity = 0; }
        this.capacity = capacity;
        this.map = {};
        this.size = 0;
    }
    /**
     * If a value for a given key is contained in the cache then return that value
     * otherwise create/store and return a new value, by calling the given `factory` function
     *
     * @param key
     * @param factory
     */
    SimpleLRU.prototype.get = function (key, factory) {
        return __awaiter(this, void 0, void 0, function () {
            var found, e_1, promise, entry, value, current;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        found = this.map[key];
                        if (!(found !== undefined)) return [3 /*break*/, 5];
                        if (this.oldest == found && found.next) {
                            this.oldest = found.next;
                        }
                        if (found.next) {
                            found.next.previous = found.previous;
                        }
                        if (found.previous) {
                            found.previous.next = found.next;
                        }
                        found.previous = this.newest;
                        found.next = null;
                        this.newest = found;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, found.value];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_1 = _a.sent();
                        this.map[key] = undefined;
                        return [2 /*return*/, this.get(key, factory)];
                    case 4: return [3 /*break*/, 8];
                    case 5:
                        if (!factory) return [3 /*break*/, 7];
                        promise = factory();
                        entry = this.map[key] = new SimpleLRUEntry(promise, key, this.newest, null);
                        return [4 /*yield*/, promise];
                    case 6:
                        value = _a.sent();
                        if (this.newest) {
                            this.newest.next = entry;
                        }
                        this.newest = entry;
                        if (this.capacity) {
                            if (this.size >= this.capacity) {
                                current = this.oldest;
                                if (current) {
                                    this.oldest = current.next;
                                    delete this.map[current.key];
                                }
                            }
                            else {
                                this.size++;
                            }
                        }
                        if (!this.oldest) {
                            this.oldest = this.newest;
                        }
                        return [2 /*return*/, value];
                    case 7: return [2 /*return*/, undefined];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    return SimpleLRU;
}());
/**
 * Even simpler unlimited cache
 */
var SimpleCache = /** @class */ (function () {
    function SimpleCache() {
        this.map = {};
    }
    SimpleCache.prototype.get = function (key, factory) {
        return __awaiter(this, void 0, void 0, function () {
            var keyString, value;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (typeof key === 'string') {
                            keyString = key;
                        }
                        else {
                            keyString = JSON.stringify(key);
                        }
                        if (!(this.map[keyString] != undefined)) return [3 /*break*/, 1];
                        return [2 /*return*/, this.map[keyString]];
                    case 1: return [4 /*yield*/, factory()];
                    case 2:
                        value = _a.sent();
                        this.map[keyString] = value;
                        return [2 /*return*/, value];
                }
            });
        });
    };
    return SimpleCache;
}());

var CACHE = new SimpleCache();
function logBody(body) {
    if (body instanceof String || typeof body === 'string') {
        console.log(body);
    }
    else {
        console.log(JSON.stringify(body, null, 2));
    }
}
var RequestsUtil = /** @class */ (function () {
    function RequestsUtil(options) {
        this.options = options;
    }
    RequestsUtil.prototype.fetch = function (url, method, payload, headers) {
        if (method === void 0) { method = 'GET'; }
        if (headers === void 0) { headers = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestMethod, requestHeaders, requestOptions, response, responseBody, _a, _b, _c, responseValue, data, start, end, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        requestMethod = method;
                        if (method !== 'JSONP') {
                            headers['Accept'] = headers['Accept'] ? headers['Accept'] : 'application/json';
                        }
                        else {
                            requestMethod = 'GET';
                        }
                        if (method === 'POST-RAW') {
                            requestMethod = 'POST';
                        }
                        if (requestMethod === 'PUT' || requestMethod === 'POST') {
                            headers['Content-Type'] = 'application/json';
                        }
                        requestHeaders = new Headers(headers);
                        requestOptions = {
                            method: requestMethod,
                            headers: requestHeaders
                        };
                        if (method === 'POST-RAW') {
                            requestOptions.body = payload;
                        }
                        else if (method !== 'GET' && method !== 'JSONP') {
                            requestOptions.body = JSON.stringify(payload);
                        }
                        return [4 /*yield*/, fetch(url, requestOptions)];
                    case 1:
                        response = _e.sent();
                        if ((this.options && this.options.debug) || response.status >= 400) {
                            console.log('[TargomoClient Begin]');
                            console.log('[Request]', requestOptions.method, url);
                            console.log("  [Headers]");
                            requestHeaders.forEach(function (value, key) {
                                console.log("    " + key + " = " + value);
                            });
                            if (requestOptions.body) {
                                console.log("  [Body]");
                                console.log(requestOptions.body);
                            }
                            console.log('[Response]');
                            console.log('    status = ', response.status);
                            console.log('    statusText = ', response.statusText);
                            console.log("  [Headers]");
                            response.headers.forEach(function (value, key) {
                                console.log("    " + key + " = " + value);
                            });
                        }
                        if (!(response.status >= 400)) return [3 /*break*/, 6];
                        console.log("  [Body]");
                        if (!(response.headers.get('content-type') === 'application/json')) return [3 /*break*/, 3];
                        _c = (_b = JSON).stringify;
                        return [4 /*yield*/, response.text()];
                    case 2:
                        _a = _c.apply(_b, [_e.sent(), null, 2]);
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, response.text()];
                    case 4:
                        _a = _e.sent();
                        _e.label = 5;
                    case 5:
                        responseBody = _a;
                        logBody(responseBody);
                        console.log('[TargomoClient End]');
                        throw new Error(responseBody);
                    case 6:
                        responseValue = null;
                        if (!(method === 'JSONP')) return [3 /*break*/, 8];
                        return [4 /*yield*/, response.text()];
                    case 7:
                        data = _e.sent();
                        start = data.indexOf('(');
                        end = data.lastIndexOf(')');
                        if (start > -1 && end > -1) {
                            responseValue = JSON.parse(data.substring(start + 1, end));
                        }
                        else {
                            responseValue = JSON.parse(data);
                        }
                        return [3 /*break*/, 9];
                    case 8:
                        responseValue = response.json();
                        _e.label = 9;
                    case 9:
                        if (!(this.options && this.options.debug)) return [3 /*break*/, 11];
                        console.log('  [Body]');
                        _d = logBody;
                        return [4 /*yield*/, responseValue];
                    case 10:
                        _d.apply(void 0, [_e.sent()]);
                        console.log('[TargomoClient End]');
                        _e.label = 11;
                    case 11: return [2 /*return*/, responseValue];
                }
            });
        });
    };
    RequestsUtil.prototype.fetchData = function (url, method, payload, headers) {
        if (method === void 0) { method = 'GET'; }
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch(url, method, payload, headers)];
                    case 1:
                        result = _a.sent();
                        if (!result.data) {
                            console.warn('No data object was transmitted by ' + url + ' \nReturning raw response');
                            return [2 /*return*/, result];
                        }
                        else {
                            return [2 /*return*/, result.data];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     *
     * @param cache
     * @param url
     * @param method
     * @param payload
     */
    RequestsUtil.prototype.fetchCached = function (cache, url, method, payload, headers) {
        var _this = this;
        if (method === void 0) { method = 'GET'; }
        if (cache !== false) {
            if (cache === true || !cache) {
                cache = CACHE;
            }
            var key = JSON.stringify({ url: url, method: method, payload: payload });
            return cache.get(key, function () { return _this.fetch(url, method, payload, headers); });
        }
        else {
            return this.fetch(url, method, payload, headers);
        }
    };
    /**
     *
     * @param cache
     * @param url
     * @param method
     * @param payload
     */
    RequestsUtil.prototype.fetchCachedData = function (cache, url, method, payload, headers) {
        var _this = this;
        if (method === void 0) { method = 'GET'; }
        if (cache !== false) {
            if (cache === true || !cache) {
                cache = CACHE;
            }
            var key = JSON.stringify({ url: url, method: method, payload: payload });
            return cache.get(key, function () { return _this.fetchData(url, method, payload, headers); });
        }
        else {
            return this.fetchData(url, method, payload, headers);
        }
    };
    return RequestsUtil;
}());
function requests(client, options) {
    // const requestTimeout = options && options.requestTimeout || client && client.config && client.config.requestTimeout // TODO....problem
    return new RequestsUtil({ debug: client && client.config && client.config.debug }); // {timeout: requestTimeout})
}

/**
 * @Topic Benchmarks
 */
var BenchmarksClient = /** @class */ (function () {
    function BenchmarksClient(client) {
        this.client = client;
    }
    /**
     *
     */
    BenchmarksClient.prototype.fetch = function (group, conditions, bounds) {
        return __awaiter(this, void 0, void 0, function () {
            var boundsData, data, url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        boundsData = {
                            'west': bounds.southWest.lng,
                            'south': bounds.southWest.lat,
                            'east': bounds.northEast.lng,
                            'north': bounds.northEast.lat
                        };
                        data = {
                            bounds: boundsData,
                            benchmarks: conditions.map(function (item) { return ({
                                source: item.source,
                                minEnd: item.minEnd,
                                minStart: item.minStart,
                                factor: item.factor,
                            }); })
                        };
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.tilesUrl)
                            .part('benchmarks/scores_cumulative/')
                            .version()
                            .part('/' + encodeURIComponent('' + group))
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this.client).fetch(url, 'POST', data)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     *
     */
    BenchmarksClient.prototype.metadata = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.tilesUrl)
                            .part('benchmarks/meta/')
                            .version()
                            .part('/' + encodeURIComponent('' + key))
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this.client).fetch(url)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return BenchmarksClient;
}());

(function (UrlUtil) {
    var TargomoUrl = /** @class */ (function () {
        function TargomoUrl(client) {
            this.client = client;
            this.url = '';
            this.firstParamPlaced = false;
        }
        TargomoUrl.prototype.host = function (value) {
            if (this.url.length === 0 && value[value.length - 1] !== '/') {
                value += '/';
            }
            return this.part(value);
        };
        TargomoUrl.prototype.part = function (value) {
            this.url += value;
            return this;
        };
        TargomoUrl.prototype.version = function () {
            if (this.client.config.version !== null && this.client.config.version !== undefined) {
                this.part('v' + this.client.config.version);
            }
            else if (this.url[this.url.length - 1] === '/') {
                this.url = this.url.substr(0, this.url.length - 1);
            }
            return this;
        };
        TargomoUrl.prototype.params = function (value) {
            var _this = this;
            var keys = Object.keys(value);
            keys.forEach(function (key) {
                if (value[key] instanceof Array) {
                    value[key].forEach(function (v) {
                        _this.param(key, v);
                    });
                }
                else {
                    _this.param(key, value[key]);
                }
            });
            return this;
        };
        TargomoUrl.prototype.param = function (name, value) {
            if (!this.firstParamPlaced) {
                this.firstParamPlaced = true;
                this.url += '?' + name + '=' + value;
            }
            else {
                this.url += '&' + name + '=' + value;
            }
        };
        TargomoUrl.prototype.key = function () {
            return this.params({ key: this.client.serviceKey });
        };
        TargomoUrl.prototype.toString = function () {
            return this.url;
        };
        return TargomoUrl;
    }());
    UrlUtil.TargomoUrl = TargomoUrl;
})(exports.UrlUtil || (exports.UrlUtil = {}));

var GeocodeEsriClient = /** @class */ (function () {
    function GeocodeEsriClient() {
    }
    /**
     *  Geocoding with esri service
     * @param query
     * @param center
     * @param language
     * @param country
     * @param magicKey
     */
    GeocodeEsriClient.prototype.geocode = function (query, center, language, country, magicKey) {
        return __awaiter(this, void 0, void 0, function () {
            var params, url, jsonResult, results;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            singleLine: query,
                            f: 'json',
                            countryCode: country,
                            maxLocations: 5,
                        };
                        if (center) {
                            params.location = center.lng + "," + center.lat;
                        }
                        if (magicKey) {
                            params.magicKey = magicKey;
                        }
                        url = new exports.UrlUtil.TargomoUrl()
                            .part('https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates')
                            .params(params)
                            .toString();
                        return [4 /*yield*/, requests().fetch(url)];
                    case 1:
                        jsonResult = _a.sent();
                        results = jsonResult.candidates.map(function (result) {
                            var location = {
                                lat: result.location.y,
                                lng: result.location.x,
                                description: result.address
                            };
                            return location;
                        });
                        return [2 /*return*/, results];
                }
            });
        });
    };
    /**
     *
     * @param query
     * @param center
     * @param language
     * @param country
     * @param suggestionsCount
     */
    GeocodeEsriClient.prototype.suggest = function (query, center, language, country, suggestionsCount) {
        if (suggestionsCount === void 0) { suggestionsCount = 5; }
        return __awaiter(this, void 0, void 0, function () {
            var params, url, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            // token: '',
                            // forStorage: false,
                            // singleLine: query,
                            text: query,
                            f: 'json',
                            countryCode: country,
                            // maxLocations: 5,
                            maxSuggestions: suggestionsCount
                        };
                        if (center) {
                            params.location = center.lng + "," + center.lat;
                        }
                        url = new exports.UrlUtil.TargomoUrl()
                            .part('https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/suggest')
                            .params(params)
                            .toString();
                        return [4 /*yield*/, requests().fetch(url)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response.suggestions];
                }
            });
        });
    };
    /**
     * Makes a reverse geocode request to the esri geocoder
     *
     * @param location
     * @param language
     */
    GeocodeEsriClient.prototype.reverseGeocode = function (location, language) {
        return __awaiter(this, void 0, void 0, function () {
            var params, url, response, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            // token: '',
                            // forStorage: false,
                            f: 'json',
                        };
                        params.location = location.lng + "," + location.lat;
                        url = new exports.UrlUtil.TargomoUrl()
                            .part('https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode')
                            .params(params)
                            .toString();
                        return [4 /*yield*/, requests().fetch(url)];
                    case 1:
                        response = _a.sent();
                        if (response && response.address) {
                            result = {
                                address: response.address.Match_addr,
                                city: response.address.City,
                                countryCode: response.address.CountryCode,
                                location: response.address.Loc_name,
                                region: response.address.Region,
                                subregion: response.address.Subregion,
                                zip: response.address.Postal
                            };
                            return [2 /*return*/, result];
                        }
                        else {
                            return [2 /*return*/, {}];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    return GeocodeEsriClient;
}());

var GeocodePhotonClient = /** @class */ (function () {
    function GeocodePhotonClient(client) {
        this.client = client;
    }
    GeocodePhotonClient.prototype.geocode = function (query, center, language) {
        return __awaiter(this, void 0, void 0, function () {
            var url, response, results;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl()
                            .host(this.client.config.photonGeocoderUrl)
                            .part('api')
                            .params({
                            q: encodeURIComponent(query),
                            limit: 5
                        })
                            .toString();
                        if (center) {
                            url += '&lat=' + center.lat + '&lon=' + center.lng;
                        }
                        if (language) {
                            url += '&lang=' + encodeURIComponent(language);
                        }
                        return [4 /*yield*/, requests().fetch(url)];
                    case 1:
                        response = _a.sent();
                        response.features.forEach(function (feature, index, array) {
                            if (feature.properties.osm_key == 'boundary') {
                                array.splice(index, 1);
                            }
                        });
                        results = response.features.map(function (result) {
                            result.value = result.properties.osm_id;
                            result.description = _this.buildPlaceDescription(result.properties);
                            return result;
                        });
                        return [2 /*return*/, results];
                }
            });
        });
    };
    GeocodePhotonClient.prototype.buildPlaceDescription = function (properties) {
        var join = function (texts, middle) {
            if (middle === void 0) { middle = ' '; }
            return texts.filter(function (text) { return !!text; }).join(middle).trim();
        };
        var parts = function (fields, middle) { return join(fields.map(function (key) { return properties[key]; }), middle); };
        var address1 = parts(['street', 'housenumber'], ' ');
        var address2 = join([parts(['postcode', 'city'], ' '), properties.country], ', ');
        var result = {
            title: '',
            meta1: '',
            meta2: '',
            full: '' // join([parts(['name', 'street', 'housenumber'], ' '), parts(['postcode', 'city'], ', ')])
        };
        if (properties.name !== undefined) {
            result.title = properties.name;
            result.meta1 = address1;
            result.meta2 = address2;
        }
        else {
            result.title = address1;
            result.meta1 = address2;
        }
        if (properties.name !== address1) {
            result.full = result.title;
        }
        if (result.meta1 && properties.name !== address1) {
            result.full += ', ' + result.meta1;
        }
        if (result.meta1 && properties.name === address1) {
            result.full += result.meta1;
        }
        result.full = join([result.full, result.meta2], ', ');
        return result;
    };
    return GeocodePhotonClient;
}());

var UseCacheRequestOptions = /** @class */ (function () {
    function UseCacheRequestOptions() {
    }
    return UseCacheRequestOptions;
}());
var BaseRequestOptions = /** @class */ (function () {
    function BaseRequestOptions() {
        /**
         * @General Determines the dimension of the edges' weight, i.e.
         * @Format time (distance in seconds) or distance (distance in meters)
         * @Default `'time'`
         */
        this.edgeWeight = 'time';
    }
    return BaseRequestOptions;
}());
var TravelRequestOptions = /** @class */ (function (_super) {
    __extends(TravelRequestOptions, _super);
    function TravelRequestOptions() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Time-frame duration in seconds
         */
        _this.transitFrameDuration = undefined;
        /**
         * Date of the transit request in the format `YYYYMMDD`
         */
        _this.transitFrameDate = 20170801;
        /**
         * Start time of the transit request in seconds from midnight
         */
        _this.transitFrameTime = 39600;
        /**
         * Maximum transfer segements in a route
         */
        _this.transitMaxTransfers = -1;
        /**
         * Route types to avoid. https://developers.google.com/transit/gtfs/reference/#routestxt
         */
        _this.transitAvoidTransitRouteTypes = [];
        _this.walkSpeed = {};
        _this.bikeSpeed = {};
        return _this;
    }
    return TravelRequestOptions;
}(BaseRequestOptions));

/**
 * An object the contains a configuration set for making requests to the r360 services backend
 */
var TravelRequestPayload = /** @class */ (function (_super) {
    __extends(TravelRequestPayload, _super);
    function TravelRequestPayload(options) {
        var _this = _super.call(this) || this;
        Object.assign(_this, options);
        if (options.transitFrameDateTime != null) {
            var date = void 0;
            if (options.transitFrameDateTime instanceof Date) {
                date = options.transitFrameDateTime;
            }
            else {
                date = new Date(options.transitFrameDateTime);
            }
            var transitFrameDate = date ? ((date.getFullYear() * 10000) + (date.getMonth() + 1) * 100 + date.getDate()) : undefined;
            var transitFrameTime = date ? ((date.getHours() * 3600) + (date.getMinutes() * 60)) : undefined;
            _this.transitFrameDate = transitFrameDate || _this.transitFrameDate;
            _this.transitFrameTime = transitFrameTime || _this.transitFrameTime;
        }
        return _this;
    }
    TravelRequestPayload.prototype.buildTargetsCfg = function (targets) {
        return targets.map(function (original) {
            return {
                lat: original.lat,
                lng: original.lng,
                id: original.id,
            };
        });
    };
    TravelRequestPayload.prototype.buildSourcesCfg = function (sources) {
        var _this = this;
        return sources.map(function (original) {
            var source = {
                lat: original.lat,
                lng: original.lng,
                id: original.id,
                tm: original.tm
            };
            if (!source.tm) {
                switch (_this.travelType) {
                    case 'car':
                        source.tm = {
                            car: _this.rushHour ? {
                                rushHour: _this.rushHour
                            } : {}
                        };
                        break;
                    case 'walk':
                        source.tm = {
                            walk: _this.walkSpeed
                        };
                        break;
                    case 'bike':
                        source.tm = {
                            bike: _this.bikeSpeed
                        };
                        break;
                    case 'transit':
                        source.tm = {
                            transit: {
                                frame: {
                                    date: _this.transitFrameDate,
                                    time: _this.transitFrameTime,
                                    duration: _this.transitFrameDuration
                                },
                                maxTransfers: _this.transitMaxTransfers
                            }
                        };
                }
            }
            return source;
        });
    };
    return TravelRequestPayload;
}(TravelRequestOptions));

var MultigraphRequestPayload = /** @class */ (function (_super) {
    __extends(MultigraphRequestPayload, _super);
    function MultigraphRequestPayload(sources, options, targets) {
        var _this = _super.call(this, options) || this;
        _this.sources = _this.buildSourcesCfg(sources);
        if (targets) {
            _this.targets = _this.buildTargetsCfg(targets);
        }
        _this.multigraph = options.multigraph;
        return _this;
    }
    return MultigraphRequestPayload;
}(TravelRequestPayload));

/**
 * @Topic Multigraph
 */
var MultigraphClient = /** @class */ (function () {
    function MultigraphClient(client) {
        this.client = client;
    }
    /**
  
     */
    MultigraphClient.prototype.fetch = function (sources, options, targets) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/multigraph')
                            .key()
                            .toString();
                        cfg = new MultigraphRequestPayload(sources, options, targets);
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', cfg)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    MultigraphClient.prototype.fetchOverview = function (sources, options, targets) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/multigraph/overview')
                            .key()
                            .toString();
                        cfg = new MultigraphRequestPayload(sources, options, targets);
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', cfg)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    MultigraphClient.prototype.getTiledMultigraphUrl = function (sources, options, format, targets) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg, objectCache;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/objectcache/add')
                            .key()
                            .toString();
                        cfg = new MultigraphRequestPayload(sources, options, targets);
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', cfg)];
                    case 1:
                        objectCache = _a.sent();
                        return [2 /*return*/, new exports.UrlUtil.TargomoUrl(this.client)
                                .part(this.client.serviceUrl)
                                .version()
                                .part('/multigraph/{z}/{x}/{y}.' + format)
                                .key()
                                .params({
                                cfgUuid: objectCache.uuid
                            })
                                .toString()];
                }
            });
        });
    };
    return MultigraphClient;
}());

var OptimizationRequestPayload = /** @class */ (function () {
    function OptimizationRequestPayload(serviceUrl, serviceKey, sources, options) {
        this.description = options.description || '';
        this.serviceUrl = serviceUrl;
        this.serviceKey = serviceKey;
        this.email = options.email || 'developers@targomo.com';
        this.sendMail = false;
        this.callbackUrl = options.callbackUrl || 'https://localhost/'; // TODO: was this donig anything?
        this.pointsPerSolution = options.pointsPerSolution;
        this.maxSolutions = options.maxSolutions || 1;
        this.travelType = options.travelType;
        this.edgeWeight = options.edgeWeight;
        this.maxEdgeWeight = options.maxEdgeWeight;
        this.statisticGroupId = options.statisticGroup;
        if (options.statistic instanceof Number || typeof options.statistic === 'number') {
            this.statisticId = +options.statistic;
        }
        else {
            this.statisticId = options.statistic.id;
        }
        var sourcesObject = {};
        sources.forEach(function (source) {
            sourcesObject[source.id] = {
                id: source.id,
                x: source.lng,
                y: source.lat
            };
        });
        this.sources.push(sourcesObject);
    }
    return OptimizationRequestPayload;
}());

/**
 * Results of an optimization simulation run
 */
var OptimizationResult = /** @class */ (function () {
    function OptimizationResult(raw) {
        this.raw = raw;
        this.id = raw.id;
        this.maxPossibleValue = raw.maxPossibleValue;
        this.solutions = raw.simulationResults.map(function (simulationResult) {
            var sources = {};
            simulationResult.sourcePoints.forEach(function (point) {
                sources[point.id] = point.optimal;
            });
            return {
                id: simulationResult.id,
                startTime: simulationResult.startTime,
                endTime: simulationResult.endTime,
                maxValue: simulationResult.maxValue,
                numberOfDesiredPoints: simulationResult.numberOfDesiredPoints,
                sources: sources
            };
        });
    }
    return OptimizationResult;
}());

/**
 * @Topic Optimizations
 */
var OptimizationsClient = /** @class */ (function () {
    function OptimizationsClient(client) {
        this.client = client;
    }
    /**
     * Initiates a an optimimization simulation. Given a list of locations and simulation parameters it tries to
     * derive a subset of these locations that are optimal.
     *
     * @param sources
     * @param options
     */
    // NOTE: we can't have unit tests for this....
    OptimizationsClient.prototype.create = function (sources, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!sources.length) {
                            return [2 /*return*/, null];
                        }
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('simulation/start/')
                            .key()
                            .params({
                            serviceUrl: encodeURIComponent(this.client.serviceUrl)
                        })
                            .toString();
                        cfg = new OptimizationRequestPayload(this.client.serviceUrl, this.client.serviceKey, sources, options);
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', cfg)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result && +result.id];
                }
            });
        });
    };
    /**
     * Checks if the given optimization simulation have completed and have results ready for retrieval
     *
     * @param optimizationId
     */
    OptimizationsClient.prototype.ready = function (optimizationId) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                if (!(optimizationId instanceof Array)) {
                    optimizationId = [optimizationId];
                }
                url = new exports.UrlUtil.TargomoUrl(this.client)
                    .host(this.client.config.statisticsUrl)
                    .part('simulation/ready/')
                    .key()
                    .params({
                    serviceUrl: encodeURIComponent(this.client.serviceUrl),
                    simulationId: optimizationId
                })
                    .toString();
                return [2 /*return*/, requests(this.client).fetch(url)];
            });
        });
    };
    /**
     * Retrieve the results of an optimization simulation
     *
     * @param optimizationId
     */
    OptimizationsClient.prototype.fetch = function (optimizationId) {
        return __awaiter(this, void 0, void 0, function () {
            var url, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('simulation/' + optimizationId + '/')
                            .key()
                            .params({
                            serviceUrl: encodeURIComponent(this.client.serviceUrl)
                        })
                            .toString();
                        _a = OptimizationResult.bind;
                        return [4 /*yield*/, requests(this.client).fetch(url)];
                    case 1: return [2 /*return*/, new (_a.apply(OptimizationResult, [void 0, _b.sent()]))()];
                }
            });
        });
    };
    return OptimizationsClient;
}());

var POIRequestPayload = /** @class */ (function (_super) {
    __extends(POIRequestPayload, _super);
    function POIRequestPayload(client, source, options) {
        var _this = _super.call(this, options) || this;
        _this.osmTypes = [];
        _this.sources = _this.buildSourcesCfg([source]);
        _this.osmTypes = options.osmTypes;
        _this.format = options.format;
        _this.serviceKey = client.serviceKey;
        _this.serviceUrl = client.serviceUrl;
        return _this;
    }
    return POIRequestPayload;
}(TravelRequestPayload));

/**
 * An object representing a point (poi/marker) which is returned from overpass queries in this module
 */
// TODO: move elsewhere...or maybe not used in public library...things in here are too specific
var OSMLatLng = /** @class */ (function () {
    function OSMLatLng(id, lng, lat, properties) {
        this.id = id;
        this.lng = lng;
        this.lat = lat;
        this.properties = properties;
        // TODO: think...this is convenient to how we have things in mapbox widget...but maybe should not be done in a public api
        if (this.properties) {
            this.properties['marker-size'] = 1;
        }
    }
    OSMLatLng.prototype.toString = function () {
        return this.properties ? this.properties['name'] : '';
    };
    OSMLatLng.prototype.copy = function () {
        var result = new OSMLatLng(this.id, this.lat, this.lng, __assign({}, this.properties));
        for (var key in this) {
            if (key != 'properties') {
                result[key] = this[key];
            }
        }
        return result;
    };
    return OSMLatLng;
}());
function parseOSMLocation(item) {
    var lat = item.lat;
    var lng = item.lon;
    if (lat === undefined && item.center) {
        lat = item.center.lat;
        lng = item.center.lon;
    }
    return new OSMLatLng(item.id, lng, lat, item.tags);
}
/**
 *
 */
// TODO: better method names
/**
 * @Topic Points of Interest
 */
var PointsOfInterestClient = /** @class */ (function () {
    // Idea is this will be instantiated internally in Targomoclient,. and will receive instance of parent in its constructor
    function PointsOfInterestClient(client) {
        this.client = client;
    }
    // TODO move queryRaw and query to common lib
    /**
     * Query the overpass service with a raw overpass query string (in other words you supply the exact query)
     *
     * @param query
     */
    PointsOfInterestClient.prototype.queryRaw = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, requests(this.client).fetch(this.client.config.overpassUrl + '/api/interpreter', 'POST-RAW', query)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.elements.filter(function (item) { return !!item.tags; }).map(function (item) { return parseOSMLocation(item); })];
                }
            });
        });
    };
    /**
     * Query the overpass servive for given categories (way[type]=tag and node[way]=tag) within a given bounding box
     *
     * @param categories
     * @param boundingBox
     */
    PointsOfInterestClient.prototype.query = function (categories, boundingBox) {
        function asQueryElement(query) {
            if (query.tag === '*' || query.tag == null) {
                return "\"" + query.type + "\"";
            }
            else if (query.type && query.tag) {
                return "\"" + query.type + "\"=\"" + query.tag + "\"";
            }
            else {
                throw new Error('invalid query' + JSON.stringify(query));
            }
        }
        var params = [];
        categories.forEach(function (category) {
            boundingBox.forEach(function (box) {
                params.push("\n      way[" + asQueryElement(category) + "]\n        (" + box.southWest.lat + "," + box.southWest.lng + "," + box.northEast.lat + "," + box.northEast.lng + ");\n      node[" + asQueryElement(category) + "]\n        (" + box.southWest.lat + "," + box.southWest.lng + "," + box.northEast.lat + "," + box.northEast.lng + ");\n        ");
            });
        });
        var data = "\n      [out:json];\n      (\n      " + params.join('') + "\n      );\n      out center;\n    ";
        return this.queryRaw(data);
    };
    /**
     * Make an overpass query to a given url (full url including the query parameters)
     *
     * The results will be parsed and returned as a list of OSMLatLng objects
     */
    // TODO: ...this was used in GH...think what shape of this make best sense for a public library
    PointsOfInterestClient.prototype.queryGetCustom = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, requests(this.client).fetch(url)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.elements.map(function (item) { return parseOSMLocation(item); })];
                }
            });
        });
    };
    /**
     * Makes a request to the r360 poi service.
     * Returns a list of OSMLatLng locations of the categories specified by `osmTypes` that are reachable within the given travel options
     */
    PointsOfInterestClient.prototype.reachable = function (source, /// LatLng
    options) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.client.config.poiUrl + "/reachability";
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', new POIRequestPayload(this.client, source, options))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return PointsOfInterestClient;
}());

/**
 * A map coordinate
 */
var LatLng = /** @class */ (function () {
    function LatLng() {
    }
    return LatLng;
}());
/**
 * A map bounding box
 */
var BoundingBox = /** @class */ (function () {
    function BoundingBox() {
    }
    return BoundingBox;
}());

(function (StatisticsGroups) {
    StatisticsGroups[StatisticsGroups["GERMANY_ZENSUS_100M_STATISTICS"] = 9] = "GERMANY_ZENSUS_100M_STATISTICS";
    StatisticsGroups[StatisticsGroups["GERMANY_ZENSUS_200M_STATISTICS"] = 2] = "GERMANY_ZENSUS_200M_STATISTICS";
    StatisticsGroups[StatisticsGroups["GERMANY_ZENSUS_500M_STATISTICS"] = 11] = "GERMANY_ZENSUS_500M_STATISTICS";
    StatisticsGroups[StatisticsGroups["GERMANY_ZENSUS_1000M_STATISTICS"] = 3] = "GERMANY_ZENSUS_1000M_STATISTICS";
    StatisticsGroups[StatisticsGroups["GERMANY_ZENSUS_2000M_STATISTICS"] = 10] = "GERMANY_ZENSUS_2000M_STATISTICS";
    StatisticsGroups[StatisticsGroups["NORWAY_STATISTICS"] = 4] = "NORWAY_STATISTICS";
    StatisticsGroups[StatisticsGroups["CENSUS_BRANDENBURG_POPULATION"] = 12] = "CENSUS_BRANDENBURG_POPULATION";
    StatisticsGroups[StatisticsGroups["CANADA_BLOCK_STATISTICS"] = 8] = "CANADA_BLOCK_STATISTICS";
    StatisticsGroups[StatisticsGroups["CANADA_AREA_STATISTICS"] = 5] = "CANADA_AREA_STATISTICS";
    StatisticsGroups[StatisticsGroups["BERLIN_STATISTICS"] = 6] = "BERLIN_STATISTICS";
})(exports.StatisticsGroups || (exports.StatisticsGroups = {}));
var TravelSpeedValues = /** @class */ (function () {
    function TravelSpeedValues() {
    }
    return TravelSpeedValues;
}());
/**
 *A result object for a specific statistic
 */
var StatisticValues = /** @class */ (function () {
    function StatisticValues(values) {
        this.values = values;
        this.total = 0;
        for (var key in this.values) {
            this.total += this.values[key];
        }
    }
    return StatisticValues;
}());

(function (SRID) {
    SRID[SRID["SRID_3857"] = 3857] = "SRID_3857";
    SRID[SRID["SRID_4326"] = 4326] = "SRID_4326";
})(exports.SRID || (exports.SRID = {}));

(function (MultigraphRequestAggregation) {
    MultigraphRequestAggregation["NONE"] = "none";
    MultigraphRequestAggregation["SUM"] = "sum";
    MultigraphRequestAggregation["MAX"] = "max";
    MultigraphRequestAggregation["MIN"] = "min";
    MultigraphRequestAggregation["MEAN"] = "mean";
    MultigraphRequestAggregation["MEDIAN"] = "median";
    MultigraphRequestAggregation["NEAREST"] = "nearest";
    MultigraphRequestAggregation["UNION"] = "routing_union";
})(exports.MultigraphRequestAggregation || (exports.MultigraphRequestAggregation = {}));

(function (MultigraphRequestLayer) {
    MultigraphRequestLayer["EDGE"] = "edge";
    MultigraphRequestLayer["NODE"] = "node";
    MultigraphRequestLayer["TILE"] = "tile";
    MultigraphRequestLayer["HEXAGON"] = "hexagon";
    MultigraphRequestLayer["TILE_NODE"] = "tile_node";
    MultigraphRequestLayer["HEXAGON_NODE"] = "hexagon_node";
})(exports.MultigraphRequestLayer || (exports.MultigraphRequestLayer = {}));

var sphericalMercator = new /** @class */ (function () {
    function class_1() {
        this.R = 6378137; // constant for Earth's radius
    }
    class_1.prototype.project = function (latlng) {
        var d = Math.PI / 180;
        var max = 1 - 1E-15;
        var sin = Math.max(Math.min(Math.sin(latlng.lat * d), max), -max);
        return {
            x: this.R * latlng.lng * d,
            y: this.R * Math.log((1 + sin) / (1 - sin)) / 2
        };
    };
    class_1.prototype.unproject = function (point) {
        var d = 180 / Math.PI;
        return {
            lat: (2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
            lng: point.x * d / this.R
        };
    };
    return class_1;
}());

/**
 * Some reusable functions that deal with lat/lng gemoetry calculations
 */
var EARTH_RADIUS_KM = 6371.01;
var RADIANS = Math.PI / 180;
// const DEGREES = 180 / Math.PI
/**
 * Return whether a lat/lng point is contained within a bounding box
 */
function contains(bBox, point) {
    return point.lat >= bBox.southWest.lat && point.lat <= bBox.northEast.lat &&
        point.lng >= bBox.southWest.lng && point.lng <= bBox.northEast.lng;
}
/**
 * Returns the distance in kilometers between two lat/lng points
 */
function calculateDistance(from, to) {
    var fromLat = RADIANS * from.lat;
    var fromLng = RADIANS * from.lng;
    var toLat = RADIANS * to.lat;
    var toLng = RADIANS * to.lng;
    return Math.acos(Math.sin(fromLat) * Math.sin(toLat) +
        Math.cos(fromLat) * Math.cos(toLat) *
            Math.cos(fromLng - toLng)) * EARTH_RADIUS_KM;
}
/**
 *
 * Creates a bounding box around a point
 *
 * @param from
 * @param distance distance in km
 */
function boundingBox(from, distance) {
    distance = distance * 1000;
    var lat = from.lat;
    var lng = from.lng;
    var latRadians = lat * RADIANS;
    var DELTA_LAT_KM = 110.574235;
    var DEGREES_LONG_KM = 110.572833 * Math.cos(latRadians);
    var deltaLat = distance / 1000.0 / DELTA_LAT_KM;
    var deltaLong = distance / 1000.0 / DEGREES_LONG_KM;
    var topLat = lat + deltaLat;
    var bottomLat = lat - deltaLat;
    var leftLng = lng - deltaLong;
    var rightLng = lng + deltaLong;
    return {
        northEast: {
            lat: topLat, lng: rightLng
        },
        southWest: {
            lat: bottomLat, lng: leftLng
        }
    };
}
/**
 * Give a list of locations return only those that are in proximity (predefined based on given TravelOptions)
 * to any location in the  `from` list
 * The use of this is to reduce the inputs to reachability and other requests (pre-filtering out remote targets) for perfromance reasons
 *
 * @param locations  The list to be filtered
 * @param from  results will be in proximity to these
 * @param options traveloptions (affect the distance around the `from` list that will be considered)
 */
function locationsWithinTravelOptions(locations, from, options) {
    var maxEdgeWeight = options.maxEdgeWeight;
    var speed;
    switch (options.travelType) {
        case 'walk':
            speed = 10;
            break;
        case 'bike':
            speed = 25;
            break;
        case 'transit':
            speed = 150;
            break;
        default:
            speed = 120;
            break;
    }
    var distanceKm = (options.edgeWeight === 'distance')
        ? Math.round(maxEdgeWeight / 1000)
        : (speed * maxEdgeWeight / 3600);
    return locationsWithinDistance(locations, from, distanceKm);
}
function getSpeed(options) {
    switch (options.travelType) {
        case 'walk': return 10;
        case 'bike': return 25;
        case 'transit': return 150;
        default: return 120;
    }
}
/**
 * Creates a bounding box around a location, with parametres about the distance calculated (based on predefined internal logic)
 * from a give TravelOptions
 *
 * @param from
 * @param options
 */
function boundingBoxWithinTravelOptions(from, options) {
    var maxEdgeWeight = options.maxEdgeWeight;
    var speed = getSpeed(options);
    var distanceKm = (options.edgeWeight === 'distance')
        ? Math.round(maxEdgeWeight / 1000)
        : (speed * maxEdgeWeight / 3600);
    return boundingBox(from, distanceKm);
}
/**
 * Create a bounding box from an Array of latlng locations
 *
 * @param locations location array to get the bbox from
 */
function boundingBoxFromLocationArray(locations) {
    var bbox = locations.reduce(function (acc, val) {
        acc.northEast.lat = (val.lat > acc.northEast.lat) ? val.lat : acc.northEast.lat;
        acc.northEast.lng = (val.lng > acc.northEast.lng) ? val.lng : acc.northEast.lng;
        acc.southWest.lat = (val.lat < acc.southWest.lat) ? val.lat : acc.southWest.lat;
        acc.southWest.lng = (val.lng < acc.southWest.lng) ? val.lng : acc.southWest.lng;
        return acc;
    }, {
        northEast: {
            lat: locations[0].lat, lng: locations[0].lng
        },
        southWest: {
            lat: locations[0].lat, lng: locations[0].lng
        }
    });
    return bbox;
}
/**
 * Creates a bounding box around a list location, with parameters about the distance calculated * (based on predefined internal logic)
 * from a give TravelOptions.
 * The bounding box returned will be the maximum bounding box that will include all bounding boxes generated for each location
 *
 * @param sources
 * @param options
 */
function boundingBoxListWithinTravelOptions(sources, options) {
    var maxEdgeWeight = options.maxEdgeWeight;
    var speed = getSpeed(options);
    var distanceKm = (options.edgeWeight === 'distance')
        ? Math.round(maxEdgeWeight / 1000)
        : (speed * maxEdgeWeight / 3600);
    var boundingBoxResult = {
        northEast: {
            lat: -Infinity, lng: -Infinity
        },
        southWest: {
            lat: Infinity, lng: Infinity
        }
    };
    sources.forEach(function (source) {
        var box = boundingBox(source, distanceKm);
        boundingBoxResult.northEast.lat = Math.max(boundingBoxResult.northEast.lat, box.northEast.lat);
        boundingBoxResult.northEast.lng = Math.max(boundingBoxResult.northEast.lng, box.northEast.lng);
        boundingBoxResult.southWest.lat = Math.min(boundingBoxResult.southWest.lat, box.southWest.lat);
        boundingBoxResult.southWest.lng = Math.min(boundingBoxResult.southWest.lng, box.southWest.lng);
    });
    return boundingBoxResult;
}
/**
 * Given a list of locations return only those that are within `distanceKm` to any location in the
 * `from` list, and which are not included in the `from` locations
 *
 * @param locations
 * @param from
 * @param distanceKm
 */
function locationsWithinDistance(locations, from, distanceKm) {
    if (from instanceof Array) {
        return locationsWithinDistanceInclusive(locations, from, distanceKm).filter(function (location) { return !from.some(function (item) { return item == location; }); });
    }
    else {
        return locationsWithinDistanceInclusive(locations, from, distanceKm).filter(function (location) { return from != location; });
    }
}
/**
 * Given a list of locations return only those that are within `distanceKm` to any location in the  `from` list
 *
 * @param locations
 * @param from
 * @param distanceKm
 */
function locationsWithinDistanceInclusive(locations, from, distanceKm) {
    if (from instanceof Array) {
        return locations.filter(function (location) { return from.some(function (point) { return calculateDistance(location, point) <= distanceKm; }); });
    }
    else {
        return locations.filter(function (location) { return calculateDistance(location, from) <= distanceKm; });
    }
}
/**
 *
 * @param point
 * @param elevation
 */
function webMercatorToLatLng(point, elevation) {
    var latlng = sphericalMercator.unproject(point);
    if (elevation != undefined) {
        // x,y,z given so we have elevation data
        return { lat: latlng.lat, lng: latlng.lng, elevation: elevation };
    }
    else {
        // no elevation given, just unproject coordinates to lat/lng
        return latlng;
    }
}
/**
 *
 * @param latlng
 */
function latLngToWebMercator(latlng) {
    var point = sphericalMercator.project(latlng);
    // point.x *= 6378137
    // point.y *= 6378137
    return point;
}

// Barrel for geometry module. See https://angular.io/guide/glossary#barrel



var geometryModule = Object.freeze({
	contains: contains,
	calculateDistance: calculateDistance,
	boundingBox: boundingBox,
	locationsWithinTravelOptions: locationsWithinTravelOptions,
	boundingBoxWithinTravelOptions: boundingBoxWithinTravelOptions,
	boundingBoxFromLocationArray: boundingBoxFromLocationArray,
	boundingBoxListWithinTravelOptions: boundingBoxListWithinTravelOptions,
	locationsWithinDistance: locationsWithinDistance,
	locationsWithinDistanceInclusive: locationsWithinDistanceInclusive,
	webMercatorToLatLng: webMercatorToLatLng,
	latLngToWebMercator: latLngToWebMercator
});

/**
 * Represents a continuous segment of a route using one travel mode
 */
var RouteSegment = /** @class */ (function () {
    function RouteSegment(client, segment) {
        var _this = this;
        this.points = [];
        this.type = segment.type;
        this.travelTime = segment.travelTime;
        /*
        * TODO don't call it length! in route length refers to the array length.
        * Call it distance instead
        */
        this.distance = segment.length / 1000;
        this.warning = segment.warning;
        this.elevationGain = segment.elevationGain;
        this.transitSegment = false;
        this.startName = segment.startname;
        this.endName = segment.endname;
        // build the geometry
        segment.points.forEach(function (point) {
            _this.points.push(webMercatorToLatLng({ x: point[1], y: point[0] }, point[2]));
        });
        // in case we have a transit route, we set information which are only available
        // for transit segments like depature station and route short sign
        if (segment.isTransit) {
            this.transitSegment = true;
            this.routeType = segment.routeType;
            this.routeShortName = segment.routeShortName;
            this.startName = segment.startname;
            this.endName = segment.endname;
            this.departureTime = segment.departureTime;
            this.arrivalTime = segment.arrivalTime;
            this.tripHeadSign = segment.tripHeadSign;
        }
    }
    return RouteSegment;
}());

/**
 *
 */
var Route = /** @class */ (function () {
    function Route(client, travelTime, segments, meta) {
        var _this = this;
        this.travelTime = travelTime;
        this.routeSegments = [];
        this.targetHeight = undefined;
        this.sourceHeight = undefined;
        this.sourceId = undefined;
        this.targetId = undefined;
        this.length = undefined;
        var transfers = 0;
        var points = [];
        // the server delivers the route from target to source
        segments.reverse().forEach(function (segment) {
            var routeSegment = new RouteSegment(client, segment);
            _this.routeSegments.push(routeSegment);
            if (routeSegment.type === 'TRANSFER') {
                transfers++;
            }
            points = points.concat(routeSegment.points.reverse());
        });
        this.points = points;
        this.transfers = transfers;
        if (typeof meta !== 'undefined') {
            this.sourceId = meta.source_id;
            this.targetId = meta.target_id;
            this.length = meta.length;
        }
        var elevationDifferences = this.calculateElevationDifferences(this.points);
        this.targetHeight = elevationDifferences.targetHeight;
        this.sourceHeight = elevationDifferences.sourceHeight;
        this.uphillMeter = elevationDifferences.uphillMeter;
        this.downhillMeter = elevationDifferences.downhillMeter;
        this.totalElevationDifference = Math.abs(this.sourceHeight - this.targetHeight);
        this.departureTime = this.calculateDepartureTime();
        this.arrivalTime = this.calculateArrivalTime();
        this.distance = this.calculateDistance();
        this.elevationGain = this.calculateElevationGain();
    }
    Route.prototype.calculateDistance = function () {
        var distance = 0;
        for (var i = 0; i < this.routeSegments.length; i++) {
            distance += this.routeSegments[i].distance;
        }
        return distance;
    };
    Route.prototype.calculateElevationGain = function () {
        var distance = undefined;
        for (var i = 0; i < this.routeSegments.length; i++) {
            if (isFinite(this.routeSegments[i].elevationGain)) {
                distance = (distance || 0) + this.routeSegments[i].elevationGain;
            }
        }
        return distance;
    };
    // TODO: check again what this does
    Route.prototype.calculateElevationDifferences = function (points) {
        var previousHeight = undefined;
        var targetHeight = undefined;
        var sourceHeight = undefined;
        var uphillMeter = 0;
        var downhillMeter = 0;
        for (var i = this.points.length - 1; i >= 0; i--) {
            if (i == 0) {
                targetHeight = this.points[i].elevation;
            }
            if (i == this.points.length - 1) {
                sourceHeight = this.points[i].elevation;
            }
            if (typeof previousHeight != 'undefined') {
                // we go up
                if (previousHeight > this.points[i].elevation) {
                    uphillMeter += (previousHeight - this.points[i].elevation);
                }
                else if (previousHeight < this.points[i].elevation) {
                    // and down
                    downhillMeter += (this.points[i].elevation - previousHeight);
                }
            }
            previousHeight = this.points[i].elevation;
        }
        return { targetHeight: targetHeight, sourceHeight: sourceHeight, uphillMeter: uphillMeter, downhillMeter: downhillMeter };
    }; // check why this was like this in original
    Route.prototype.calculateDepartureTime = function () {
        var travelTime = 0;
        for (var i = 0; i < this.routeSegments.length; i++) {
            var segment = this.routeSegments[i];
            if (segment.departureTime != null) {
                return (segment.departureTime - travelTime);
            }
            else {
                travelTime += (segment.travelTime || 0);
            }
        }
        return undefined;
    };
    Route.prototype.calculateArrivalTime = function () {
        var travelTime = 0;
        for (var i = this.routeSegments.length - 1; i >= 0; i--) {
            var segment = this.routeSegments[i];
            if (segment.arrivalTime != null) {
                return (segment.arrivalTime - travelTime);
            }
            else {
                travelTime += (segment.travelTime || 0);
            }
        }
        return undefined;
    };
    return Route;
}());

var StatisticsResult = /** @class */ (function () {
    function StatisticsResult(result, statistics) {
        function dataToStatisticgroup(values) {
            var statisticsGroup = {};
            // Convert to map of named statistics, instead of index based ones
            for (var _i = 0, statistics_1 = statistics; _i < statistics_1.length; _i++) {
                var statistic = statistics_1[_i];
                statisticsGroup[statistic.name] = new StatisticValues(values[statistic.id]);
            }
            return statisticsGroup;
        }
        var individualStatistics = {};
        if (result.individualStatistics) {
            for (var key in result.individualStatistics) {
                if (result.individualStatistics[key] && result.individualStatistics[key].statistics) {
                    individualStatistics[key] = dataToStatisticgroup(result.individualStatistics[key].statistics);
                }
            }
        }
        this.statistics = dataToStatisticgroup(result.statistics), this.individualStatistics = individualStatistics, this.raw = result;
    }
    return StatisticsResult;
}());

/**
 * Lifecycle of a Multigraph:
 *
 * 1. CREATED
 * 2. ROUTING
 * 3. MERGING
 * 4. AGGREGATING
 * 5. COMPLETED / FAILED
 */

(function (MultigraphStatus) {
    MultigraphStatus["CREATED"] = "CREATED";
    MultigraphStatus["ROUTING"] = "ROUTING";
    MultigraphStatus["MERGING"] = "MERGING";
    MultigraphStatus["AGGREGATING"] = "AGGREGATING";
    MultigraphStatus["COMPLETED"] = "COMPLETED";
    MultigraphStatus["FAILED"] = "FAILED";
})(exports.MultigraphStatus || (exports.MultigraphStatus = {}));

/**
 * @General The reponse of the request if the optimization was successfully carried out. It contains the original request body information
 * (plus potential mitigated values). The result of the fleet planning optimization is stored in "tours" and additional helpful information
 * with regards to the execution (e.g. messages, mitigated errors) are stored in "resultStatus".
 * All elements in the return body (including stores, orders, transports) now have an id field which can be ignored by the client.
 */
var FpResult = /** @class */ (function () {
    function FpResult() {
    }
    return FpResult;
}());

var StatisticsGeometryResult = /** @class */ (function () {
    function StatisticsGeometryResult(result, statistics) {
        this.values = {};
        var statsticsMap = {};
        statistics.forEach(function (statistic) {
            statsticsMap[statistic.id] = statistic.name;
        });
        this.raw = result;
        var values = this.values;
        for (var key in result) {
            var row = result[key];
            var aggregationKey = (row.aggregation || '').toLowerCase();
            values[aggregationKey] = values[aggregationKey] || {};
            var statistic = statsticsMap[row.statisticId];
            values[aggregationKey][statistic] = { value: row.value };
        }
    }
    return StatisticsGeometryResult;
}());

// Barrel for types module. See https://angular.io/guide/glossary#barrel

var PolygonPayloadOptions = /** @class */ (function () {
    function PolygonPayloadOptions() {
        this.minPolygonHoleSize = 10000000;
        this.buffer = 50;
        this.simplify = 50;
        this.srid = exports.SRID.SRID_4326;
        this.quadrantSegments = 2;
        this.intersectionMode = 'union';
        this.decimalPrecision = 6;
    }
    return PolygonPayloadOptions;
}());
var PolygonRequestPayload = /** @class */ (function (_super) {
    __extends(PolygonRequestPayload, _super);
    function PolygonRequestPayload(client, sources, options) {
        var _this = _super.call(this, options) || this;
        _this.polygon = new PolygonPayloadOptions();
        _this.sources = _this.buildSourcesCfg(sources);
        _this.polygon.values = options.travelEdgeWeights;
        _this.polygon.serializer = options.serializer;
        _this.polygon.simplify = options.simplify;
        _this.polygon.srid = options.srid;
        _this.polygon.buffer = options.buffer;
        _this.polygon.minPolygonHoleSize = options.minPolygonHoleSize;
        _this.polygon.quadrantSegments = options.quadrantSegments;
        _this.polygon.intersectionMode = options.intersectionMode;
        _this.polygon.decimalPrecision = options.decimalPrecision;
        return _this;
    }
    return PolygonRequestPayload;
}(TravelRequestPayload));

/**
 *
 */
var ProjectedBounds = /** @class */ (function () {
    function ProjectedBounds(bounds) {
        this.southWest = new ProjectedPoint(Infinity, Infinity);
        this.northEast = new ProjectedPoint(-Infinity, -Infinity);
        if (bounds) {
            this.southWest = new ProjectedPoint(bounds.southWest.x, bounds.southWest.y);
            this.northEast = new ProjectedPoint(bounds.northEast.x, bounds.northEast.y);
        }
    }
    ProjectedBounds.prototype.expandPoint = function (x, y) {
        this.southWest.x = Math.min(this.southWest.x, x);
        this.northEast.x = Math.max(this.northEast.x, x);
        this.southWest.y = Math.min(this.southWest.y, y);
        this.northEast.y = Math.max(this.northEast.y, y);
    };
    ProjectedBounds.prototype.expand = function (bounds) {
        this.expandPoint(bounds.northEast.x, bounds.northEast.y);
        this.expandPoint(bounds.southWest.x, bounds.southWest.y);
    };
    return ProjectedBounds;
}());
/**
 *
 */
var ProjectedPoint = /** @class */ (function () {
    function ProjectedPoint(x, y) {
        this.x = x;
        this.y = y;
    }
    return ProjectedPoint;
}());
/**
 *
 */
var ProjectedLineString = /** @class */ (function () {
    function ProjectedLineString(coordinates) {
        var _this = this;
        this.bounds3857 = new ProjectedBounds();
        this.points = coordinates.map(function (coordinate) {
            _this.bounds3857.expandPoint(coordinate[0], coordinate[1]);
            var pair = sphericalMercator.project({ lat: coordinate[0], lng: coordinate[1] });
            return new ProjectedPoint(pair.x, pair.y);
        });
    }
    return ProjectedLineString;
}());
/**
 *
 */
var ProjectedPolygon = /** @class */ (function () {
    function ProjectedPolygon(data) {
        var _this = this;
        this.bounds3857 = new ProjectedBounds();
        this.travelTime = data.travelTime;
        this.area = data.area;
        this.lineStrings = [new ProjectedLineString(data.outerBoundary)];
        this.bounds3857.expand(this.lineStrings[0].bounds3857);
        if (data.innerBoundary) {
            data.innerBoundary.forEach(function (innerBoundary) {
                var lineString = new ProjectedLineString(innerBoundary);
                _this.lineStrings.push(lineString);
                _this.bounds3857.expand(lineString.bounds3857);
            });
        }
    }
    return ProjectedPolygon;
}());

/**
 * @Topic Polygons
 */
var PolygonsClient = /** @class */ (function () {
    function PolygonsClient(client) {
        this.client = client;
    }
    PolygonsClient.prototype.fetch = function (sources, options) {
        return __awaiter(this, void 0, void 0, function () {
            var cfg, result, boundedPolys;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cfg = new PolygonRequestPayload(this.client, sources, options);
                        return [4 /*yield*/, this._executeFetch(sources, options, cfg)];
                    case 1:
                        result = _a.sent();
                        if (options.serializer === 'json') {
                            boundedPolys = PolygonArray.create(result, result.metadata);
                            return [2 /*return*/, boundedPolys];
                        }
                        else if (options.serializer === 'geojson') {
                            return [2 /*return*/, result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    PolygonsClient.prototype._executeFetch = function (sources, options, cfg) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/polygon')
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg)];
                    case 1:
                        result = _a.sent();
                        result.metadata = options;
                        return [2 /*return*/, result];
                }
            });
        });
    };
    return PolygonsClient;
}());
/**
 * Class to extend Array for polygons result to add maxBounds method to array results
 */
var PolygonArray = /** @class */ (function (_super) {
    __extends(PolygonArray, _super);
    function PolygonArray(items) {
        return _super.apply(this, items) || this;
    }
    PolygonArray.create = function (items, metadata) {
        var newProto = Object.create(PolygonArray.prototype);
        items.forEach(function (polygons) { return newProto.push(polygons); });
        if (metadata) {
            newProto.metadata = metadata;
        }
        return newProto;
    };
    PolygonArray.prototype.getMaxBounds = function () {
        var boundsPoints = [];
        this.forEach(function (svgPolygons) {
            var bounds3857;
            svgPolygons.polygons.forEach(function (polygonData) {
                var polygon = new ProjectedPolygon(polygonData);
                if (bounds3857) {
                    bounds3857.expand(polygon.bounds3857);
                }
                else {
                    bounds3857 = polygon.bounds3857;
                }
            });
            boundsPoints.push(webMercatorToLatLng(bounds3857.northEast, null));
            boundsPoints.push(webMercatorToLatLng(bounds3857.southWest, null));
        });
        return boundingBoxFromLocationArray(boundsPoints);
    };
    return PolygonArray;
}(Array));

var TimeRequestPayload = /** @class */ (function (_super) {
    __extends(TimeRequestPayload, _super);
    function TimeRequestPayload(client, sources, targets, options) {
        var _this = _super.call(this, options) || this;
        _this.sources = _this.buildSourcesCfg(sources);
        _this.targets = _this.buildTargetsCfg(targets);
        return _this;
    }
    return TimeRequestPayload;
}(TravelRequestPayload));

// TODO: decide on method names...or keep previous names
/**
 * @Topic Reachability
 */
var ReachabilityClient = /** @class */ (function () {
    function ReachabilityClient(client) {
        this.client = client;
    }
    /**
     *
     * @param sources
     * @param targets
     * @param options
     */
    ReachabilityClient.prototype.individual = function (sources, targets, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/time')
                            .key()
                            .toString();
                        cfg = new TimeRequestPayload(this.client, sources, targets, options);
                        return [4 /*yield*/, requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Makes a reachability request to the r360 services, and returns the raw results of the request
     *
     * @param sources
     * @param targets
     * @param options
     */
    ReachabilityClient.prototype.combined = function (sources, targets, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/reachability')
                            .key()
                            .toString();
                        cfg = new TimeRequestPayload(this.client, sources, targets, options);
                        return [4 /*yield*/, requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg)];
                    case 1: 
                    // TODO: add timeout
                    return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Makes a reachability request to the r360 services and returns the number of locations that are reachable within the given parameters
     *
     * @param sources
     * @param targets
     * @param options
     */
    ReachabilityClient.prototype.count = function (sources, targets, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.locations(sources, targets, options)];
                    case 1: 
                    // TODO: sopmething like this was used somewhere think
                    // (maybe autoprop)....however since it is trivial...maybe we should not have it anymore
                    return [2 /*return*/, (_a.sent()).length];
                }
            });
        });
    };
    /**
     * Makes a reachability requests to the r360 services and returns the input targets decorated with the resulting travel time
     *
     * @param sources
     * @param targets
     * @param options
     */
    ReachabilityClient.prototype.locations = function (sources, targets, options) {
        return __awaiter(this, void 0, void 0, function () {
            var map, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        map = {};
                        targets.forEach(function (place) { return map[String(place.id)] = -1; });
                        return [4 /*yield*/, this.combined(sources, targets, options)];
                    case 1:
                        response = _a.sent();
                        response.forEach(function (target) {
                            var id = String(target.id);
                            if (!map[id]) {
                                console.warn('NOT FOUND', String(target.id));
                            }
                            else {
                                if (target.travelTime > -1) {
                                    if (map[id] > -1) {
                                        map[id] = Math.min(map[id], target.travelTime);
                                    }
                                    else {
                                        map[id] = target.travelTime;
                                    }
                                }
                            }
                        });
                        return [2 /*return*/, targets.filter(function (place) {
                                var id = String(place.id);
                                place.travelTime = map[id];
                                return map[id] > -1;
                            })];
                }
            });
        });
    };
    return ReachabilityClient;
}());

var RouteRequestPayload = /** @class */ (function (_super) {
    __extends(RouteRequestPayload, _super);
    function RouteRequestPayload(client, sources, targets, options) {
        var _this = _super.call(this, options) || this;
        _this.sources = _this.buildSourcesCfg(sources);
        _this.targets = _this.buildTargetsCfg(targets);
        _this.pathSerializer = options.pathSerializer;
        if (typeof options.recommendations === 'boolean') {
            options.recommendations = options.recommendations ? 1 : 0;
        }
        if (Number.isInteger(options.recommendations) && _this.sources) {
            _this.sources.forEach(function (source) {
                if (source.tm != null) {
                    for (var mode in source.tm) {
                        source.tm[mode].recommendations = options.recommendations;
                    }
                }
            });
        }
        return _this;
    }
    return RouteRequestPayload;
}(TravelRequestPayload));

/**
 * @Topic Routes
 */
var RoutesClient = /** @class */ (function () {
    function RoutesClient(client) {
        this.client = client;
    }
    RoutesClient.prototype.fetch = function (sources, targets, options) {
        return __awaiter(this, void 0, void 0, function () {
            var cfg, result;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cfg = new RouteRequestPayload(this.client, sources, targets, options);
                        return [4 /*yield*/, this._executeFetch(sources, targets, options, cfg)];
                    case 1:
                        result = _a.sent();
                        if (!options.pathSerializer || options.pathSerializer === 'compact') {
                            return [2 /*return*/, result.routes.map(function (meta) {
                                    return new Route(_this.client, meta.travelTime, meta.segments, meta);
                                })];
                        }
                        else if (options.pathSerializer === 'geojson') {
                            return [2 /*return*/, result.routes];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    RoutesClient.prototype._executeFetch = function (sources, targets, options, cfg) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/route')
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg, {
                                // Headers are here because something needs to be fixed in the service endpoint
                                'Accept': 'application/json,application/javascript,*/*'
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    return RoutesClient;
}());

/**
 * @Topic Similarity
 */
var SimilarityClient = /** @class */ (function () {
    function SimilarityClient(client) {
        this.client = client;
    }
    /**
     *
     */
    SimilarityClient.prototype.metadata = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.tilesUrl)
                            .part('similarity/meta/')
                            .version()
                            .part('/' + encodeURIComponent('' + key))
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this.client).fetch(url)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     *
     */
    SimilarityClient.prototype.fetch = function (group, cell, conditions, bounds, normalizeOnViewport) {
        return __awaiter(this, void 0, void 0, function () {
            var boundsData, data, urlObject, url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        boundsData = {
                            'west': bounds.southWest.lng,
                            'south': bounds.southWest.lat,
                            'east': bounds.northEast.lng,
                            'north': bounds.northEast.lat
                        };
                        data = {
                            bounds: boundsData,
                            refCellId: cell,
                            scores: conditions.map(function (item) { return ({
                                source: item.source,
                                minutes: item.minutes,
                                factor: item.factor || 1
                            }); })
                        };
                        urlObject = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.tilesUrl)
                            .part('similarity/scores_cumulative/')
                            .version()
                            .part('/' + encodeURIComponent('' + group))
                            .key();
                        url = normalizeOnViewport ? urlObject.params({ normalizeOnViewport: !!normalizeOnViewport }).toString() : urlObject.toString();
                        return [4 /*yield*/, requests(this.client).fetch(url, 'POST', data)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return SimilarityClient;
}());

function isStatisticsRequestOptions(value) {
    return value.statistics;
}
var StatisticsRequestPayload = /** @class */ (function () {
    function StatisticsRequestPayload(client, sources, options) {
        this.inactiveSources = [];
        this.getClosestSources = false;
        this.serviceUrl = client.serviceUrl;
        this.serviceKey = client.serviceKey;
        this.useCache = options.useCache == undefined ? true : options.useCache;
        this.sources = sources.map(function (source) { return ({ id: source.id, y: source.lat, x: source.lng }); });
        this.iFeelLucky = options.iFeelLucky;
        this.travelType = options.travelType;
        this.edgeWeight = options.edgeWeight;
        this.maxEdgeWeight = options.maxEdgeWeight;
        this.frame = options.transitFrameDuration;
        this.time = options.transitFrameTime;
        this.date = options.transitFrameDate;
        this.maxTransfers = options.transitMaxTransfers;
        this.maxWalkingTimeFromSource = options.transitMaxWalkingTimeFromSource;
        this.avoidTransitRouteTypes = options.transitAvoidTransitRouteTypes;
        this.rushHour = options.rushHour;
        if (options.inactiveSources) {
            this.inactiveSources = options.inactiveSources.map(function (source) { return ({ id: source.id, y: source.lat, x: source.lng }); });
        }
        var statisticsIndices = [];
        if (isStatisticsRequestOptions(options)) {
            this.omitIndividualStatistics = options.omitIndividualStatistics;
            statisticsIndices = options.statistics.map(function (statistic) {
                if (statistic instanceof Number || typeof statistic === 'number') {
                    return +statistic;
                }
                else {
                    return statistic.id;
                }
            });
        }
        this.statisticGroupId = +options.statisticsGroup;
        this.statisticIds = statisticsIndices;
        if (options.closestSources) {
            this.getClosestSources = true;
        }
    }
    return StatisticsRequestPayload;
}());

var StatisticsGeometryRequestPayload = /** @class */ (function () {
    function StatisticsGeometryRequestPayload(client, geometry, options) {
        var statisticsIndices = options.statistics.map(function (statistic) {
            if (statistic instanceof Number || typeof statistic === 'number') {
                return +statistic;
            }
            else {
                return statistic.id;
            }
        });
        this.statisticGroupId = +options.statisticsGroup;
        this.statisticIds = statisticsIndices;
        this.intersectionGeometry = {
            data: geometry,
            crs: options.crs || 4326
        };
    }
    return StatisticsGeometryRequestPayload;
}());

/**
 * @Topic Statistics
 */
var StatisticsClient = /** @class */ (function () {
    function StatisticsClient(client) {
        this.client = client;
        this.statisticsMetadataCache = new SimpleLRU(200);
        this.statisticsEnsemblesCache = new SimpleLRU(200);
    }
    /**
     *
     * @param sources
     * @param options
     */
    StatisticsClient.prototype.combined = function (sources, // sources: LatLng[],
    options) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.dependent(sources, options)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result && result.statistics];
                }
            });
        });
    };
    /**
    * Make a statistics request to the r360 services
    */
    StatisticsClient.prototype.individual = function (sources, // sources: LatLng[],
    options) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.dependent(sources, options)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result && result.individualStatistics];
                }
            });
        });
    };
    /**
    * Make a statistics request to the r360 services
    */
    StatisticsClient.prototype.travelTimes = function (sources, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!sources.length) {
                            return [2 /*return*/, null];
                        }
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('traveltimes')
                            .params({
                            serviceUrl: this.client.serviceUrl
                        })
                            .toString();
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', new StatisticsRequestPayload(this.client, sources, options))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     *
     * @param sources
     * @param options
     */
    StatisticsClient.prototype.dependent = function (sources, // was LatLng[]
    options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!sources.length) {
                            return [2 /*return*/, null];
                        }
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('charts/dependent')
                            .params({
                            serviceUrl: this.client.serviceUrl
                        })
                            .toString();
                        return [4 /*yield*/, requests(this.client, options)
                                .fetch(url, 'POST', new StatisticsRequestPayload(this.client, sources, options))];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new StatisticsResult(result, options.statistics)];
                }
            });
        });
    };
    /**
     *
     * @param sources
     * @param options
     */
    StatisticsClient.prototype.geometry = function (geometry$$1, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!geometry$$1) {
                            return [2 /*return*/, null];
                        }
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('values/geometry')
                            .params({
                            serviceUrl: this.client.serviceUrl
                        })
                            .toString();
                        return [4 /*yield*/, requests(this.client, options)
                                .fetch(url, 'POST', new StatisticsGeometryRequestPayload(this.client, geometry$$1, options))];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new StatisticsGeometryResult(result, options.statistics)];
                }
            });
        });
    };
    /**
     *
     * @param group
     */
    StatisticsClient.prototype.metadata = function (group) {
        return __awaiter(this, void 0, void 0, function () {
            var server, key, cacheKey;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        server = this.client.config.tilesUrl;
                        key = (typeof group == 'number') ? group : group.id;
                        cacheKey = server + '-' + key;
                        return [4 /*yield*/, this.statisticsMetadataCache.get(cacheKey, function () { return __awaiter(_this, void 0, void 0, function () {
                                var url, result;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            url = new exports.UrlUtil.TargomoUrl(this.client)
                                                .host(this.client.config.tilesUrl)
                                                .part('statistics/meta/')
                                                .version()
                                                .part('/' + key + '')
                                                .key()
                                                .toString();
                                            return [4 /*yield*/, requests(this.client).fetch(url)];
                                        case 1:
                                            result = _a.sent();
                                            if (!result.name && result.names && result.names.en) {
                                                result.name = result.names.en;
                                            }
                                            if (result.stats && result.stats.length) {
                                                result.stats.forEach(function (stat) {
                                                    if (!stat.name && stat.names && stat.names.en) {
                                                        stat.name = stat.names.en;
                                                    }
                                                });
                                            }
                                            return [2 /*return*/, result];
                                    }
                                });
                            }); })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     *
     */
    StatisticsClient.prototype.metadataKey = function (group, statistic) {
        return __awaiter(this, void 0, void 0, function () {
            var endpoint, _i, _a, attribute;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.metadata(group)];
                    case 1:
                        endpoint = _b.sent();
                        for (_i = 0, _a = endpoint.stats; _i < _a.length; _i++) {
                            attribute = _a[_i];
                            if (statistic.id == attribute.statistic_id || (attribute.names && attribute.names.en == statistic.name)) {
                                return [2 /*return*/, attribute];
                            }
                        }
                        return [2 /*return*/, null];
                }
            });
        });
    };
    /**
     * Potentially decorate a layer route with excluded statistics.
     */
    StatisticsClient.prototype.tileRoute = function (group, include) {
        var key = (typeof group == 'number') ? group : group.id;
        var urlObject = new exports.UrlUtil.TargomoUrl(this.client)
            .host(this.client.config.tilesUrl)
            .part('statistics/tiles/')
            .version()
            .part('/' + key + '/{z}/{x}/{y}.mvt')
            .key();
        return include && include.length > 0 ?
            urlObject.params({ columns: encodeURIComponent(include.map(function (row) { return +row.id; }).join(',')) }).toString() :
            urlObject.toString();
    };
    /**
     *
     * @param sources
     * @param options
     */
    StatisticsClient.prototype.ensembles = function () {
        return __awaiter(this, void 0, void 0, function () {
            var cacheKey;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cacheKey = this.client.config.tilesUrl;
                        return [4 /*yield*/, this.statisticsEnsemblesCache.get(cacheKey, function () { return __awaiter(_this, void 0, void 0, function () {
                                var url, result, id, ensemble;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            url = new exports.UrlUtil.TargomoUrl(this.client)
                                                .host(this.client.config.tilesUrl)
                                                .part('ensemble/list/')
                                                .version()
                                                .key()
                                                .toString();
                                            return [4 /*yield*/, requests(this.client).fetch(url, 'GET')
                                                // FIXME: workaround for server results
                                            ];
                                        case 1:
                                            result = _a.sent();
                                            // FIXME: workaround for server results
                                            for (id in result) {
                                                if (result[id]) {
                                                    ensemble = result[id];
                                                    ensemble.id = +ensemble.id;
                                                    if (ensemble.groups && ensemble.groups.length) {
                                                        ensemble.groups.forEach(function (group) {
                                                            group.hierarchy = +group.hierarchy;
                                                            group.id = +group.id;
                                                        });
                                                    }
                                                }
                                            }
                                            return [2 /*return*/, result];
                                    }
                                });
                            }); })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return StatisticsClient;
}());

var StatefulMultigraphRequestPayload = /** @class */ (function (_super) {
    __extends(StatefulMultigraphRequestPayload, _super);
    function StatefulMultigraphRequestPayload(client, sources, options) {
        var _this = _super.call(this, client, sources, options) || this;
        // This request only works if only recognized attributes are sent
        delete _this.inactiveSources;
        delete _this.statisticGroupId;
        delete _this.statisticIds;
        delete _this.getClosestSources;
        delete _this.useCache;
        if (options) {
            _this.multiGraphSerializationType = options.multigraph.serialization.format;
            _this.multiGraphSerializationDecimalPrecision = options.multigraph.serialization.decimalPrecision;
            /**
             * not yet supported in the stateful version
            if (options.layer) {
              this.multiGraphLayerType = options.layer.type
              this.multiGraphLayerEdgeAggregationType = options.layer.edgeAggregationType
              this.multiGraphLayerGeometryDetailPerTile = options.layer.geometryDetailPerTile
              this.multiGraphLayerMinGeometryDetailLevel = options.layer.minGeometryDetailLevel
              this.multiGraphLayerMaxGeometryDetailLevel = options.layer.maxGeometryDetailLevel
            }
            */
            if (options.multigraph.aggregation) {
                _this.multiGraphAggregationType = options.multigraph.aggregation.type || null;
                _this.multiGraphAggregationIgnoreOutlier = options.multigraph.aggregation.ignoreOutliers || null;
                _this.multiGraphAggregationMinSourcesRatio = options.multigraph.aggregation.minSourcesRatio || null;
                _this.multiGraphAggregationMinSourcesCount = options.multigraph.aggregation.minSourcesCount || null;
                _this.multiGraphAggregationMaxResultValueRatio = options.multigraph.aggregation.maxResultValueRatio || null;
                _this.multiGraphAggregationMaxResultValue = options.multigraph.aggregation.maxResultValue || null;
            }
        }
        return _this;
    }
    return StatefulMultigraphRequestPayload;
}(StatisticsRequestPayload));

/**
 * @Topic Stateful Multigraph
 */
var StatefulMultigraphClient = /** @class */ (function () {
    function StatefulMultigraphClient(client) {
        this.client = client;
    }
    /**
     * Creates a new multigraph tile set for the given sources and parameters.
     * Returns an id for the given aggregation to be used in subsequent mvt requests.
     *
     * @param sources
     * @param options
     */
    StatefulMultigraphClient.prototype.create = function (sources, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('multigraph')
                            .key()
                            .toString();
                        cfg = new StatefulMultigraphRequestPayload(this.client, sources, options);
                        return [4 /*yield*/, requests(this.client, options)
                                .fetchCachedData(options.useClientCache, url, 'POST', cfg, { 'Accept': 'text/plain' })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Returns Info about the current State of the multigraph calculation
     *
     * **Multigraph Lifecycle**
     * 1. CREATED
     * 2. ROUTING
     * 3. MERGING
     * 4. AGGREGATING
     * 5. COMPLETED / FAILED
     *
     * @param multigaphId Id of the multigraph
     */
    StatefulMultigraphClient.prototype.info = function (multigaphId) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('multigraph/' + multigaphId)
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this.client).fetch(url, 'GET')];
                    case 1:
                        result = _a.sent();
                        if (result.boundingBoxNorthEast && result.boundingBoxSouthWest) {
                            result.boundingBox = {
                                northEast: {
                                    lat: result.boundingBoxNorthEast.y,
                                    lng: result.boundingBoxNorthEast.x
                                },
                                southWest: {
                                    lat: result.boundingBoxSouthWest.y,
                                    lng: result.boundingBoxSouthWest.x
                                }
                            };
                            delete result.boundingBoxNorthEast;
                            delete result.boundingBoxSouthWest;
                        }
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Redo Multigraph with id `multigraphId`
     *
     * @param multigaphId
     */
    StatefulMultigraphClient.prototype.redo = function (multigaphId) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('multigraph/' + multigaphId + '/update')
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this.client).fetch(url, 'PATCH')];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    return StatefulMultigraphClient;
}());

/**
 * @Topic Fleetplanner
 * @General This is the entry point for the Fleetplanner service.
 * The Fleetplanner service enables the configurable calculation of
 * efficient routing for multi-vehicle, multi-destination delivery scenarios.
 *
 * This service solves the Vehicle Routing Problem(VRP) which is similar to the traveling salesman problem. The difference between the two
 * problems, is that the VRP concerns multiple vehicles; a fleet of vehicles.
 * The VRP is about finding the optimal combination of routes for all of the vehicles.
 *
 * The VRP can be extended with additional factors that make the problem more complex. For example, deadlines can
 * be introduced. Every location has a deadline. In an optimal scenario, all the deadlines should be met. However, it is
 * not always possible to meet all deadlines with the number of vehicles that are available. In that case, the goal of the
 * VRP is to either meet as many deadlines, or to optimize the total sum of expired deadline times.
 *
 * Another way the VRP can be extended is by introducing weight and volumes to the orders that need to be delivered and having
 * vehicles with a maximum load weight and volume capacity.
 *
 * More in-depth/detailed information about the Fleetplanner service can be found at https://docs.targomo.com/fleetplanner/
*/
var FleetsClient = /** @class */ (function () {
    function FleetsClient(client) {
        this.client = client;
    }
    /**
     * @General Start a new request to compute optimized routes with the provided information.
     * @Performance Depending on the options, the execution time of this call can vary significantly.
     * This function makes a http POST request to the Targomo REST service for the Fleetplanner.
     * Every call to this function will be recorded based on your API key.
     * All your usage statistics are accessible on https://account.targomo.com/statistics.
     * @Exceptions This function can return the same exceptions as described on https://docs.targomo.com/fleetplanner/
     * @Example
     * ``` js
     * const stores = [{ uuid: '1', address: { lat: 52.474257, lng: 13.378094 } }];
     * const orders = [{ storeUuid: '1', address: { lat: 52.4, lng: 13.4 } },
     *                 { storeUuid: '1', address: { lat: 52.6, lng: 13.6 } },
     *                 { storeUuid: '1', address: { lat: 52.6, lng: 13.3 } }];
     * const transports = [{ vehicle: { storeUuid: '1', maxVolume: 100, maxWeight: 100 } }];
     * const options = { optimizationAlgorithm: 'CONSTRAINT_SATISFACTION', maxEdgeWeight: 3000, travelType: 'car' }
     * targomoClient.fleets.fetch(stores, orders, transports, options).then(result => {
     *     console.log(result.tours);
     * });
     * ```
     *
     * @Param stores
     * The stores, or otherwise called 'depots' from which their respective vehicles start their routes.
     * A store has a relation with zero or more orders, and zero or more vehicles.
     * @Param orders
     * The orders that need to be serviced by a vehicle from the store which is concerns this order.
     * An order has a relation with one store.
     * ##### Performance
     * The amount of orders has a significant on the time it takes to optimize the routes.
     * When using the default settings for optimizationTime and unimprovedWaitingTime in combination with more than 100 orders,
     * you can expect the results to be less optimized.
     * In this case, the algorithm doesn't have enough time to completely finish the optimization for this amount of orders.
     * Raise the optimizationTime option when sending a request with a high amount of orders.
     * @Param transports
     * The transports (vehicles). Each of which are assigned to a certain store.
     * @Param options
     * ##### Performance
     * Various different options within this options object can have a significant noticable impact on the request duration.
     */
    FleetsClient.prototype.fetch = function (stores, orders, transports, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.fleetsUrl)
                            .version()
                            .part('/api/key-auth/optimizations')
                            .key()
                            .toString();
                        cfg = this._createPayload(this.client, stores, orders, transports, options);
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', cfg)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    FleetsClient.prototype._createPayload = function (client, stores, orders, transports, options) {
        var payload = {
            optimizationTime: options.optimizationTime,
            optimizationAlgorithm: options.optimizationAlgorithm,
            optimizationMetadata: {
                costMatrixSource: options.costMatrixSource,
                geojsonCreation: options.geojsonCreation,
                unimprovedWaitingTime: options.unimprovedWaitingTime,
                filterOrdersWithMissedDeadline: options.filterOrdersWithMissedDeadline,
                filterOrdersOutsideOfValidWorkingHours: options.filterOrdersOutsideOfValidWorkingHours,
                prohibitFilteringOfOrdersWithDeadlinesEarlierEqualsThan: options.prohibitFilteringOfOrdersWithDeadlinesEarlierEqualsThan,
                secondsToPenaltyRatioForDeadlineMissed: options.secondsToPenaltyRatioForDeadlineMissed,
                secondsToPenaltyRatioForOutOfWorkingHours: options.secondsToPenaltyRatioForOutOfWorkingHours,
                timeConstraintPenaltyToTravelCostRatio: options.timeConstraintPenaltyToTravelCostRatio,
                longestTourPenaltyFactor: options.longestTourPenaltyFactor,
                nonParallelOrdersByTags: options.nonParallelOrdersByTags,
                travelOptions: {
                    travelType: options.travelType,
                    serviceKey: client.serviceKey,
                    serviceUrl: client.serviceUrl,
                    travelTimeFactors: options.travelTimeFactors,
                    fallbackServiceUrl: '',
                    edgeWeight: options.edgeWeight,
                    maxEdgeWeight: options.maxEdgeWeight,
                    elevation: options.elevation,
                    rushHour: options.rushHour
                }
            },
            stores: stores,
            transports: transports,
            orders: orders
        };
        return payload;
    };
    return FleetsClient;
}());

/**
 * @Topic Basemaps
 * @General This is the entry point for using the basemaps provided by Targomo.
 * @Alternative If you wish to use our basemaps with Leaflet. Please take a look at the targomo-js-extensions library.
 * We have a Leaflet extension for using our basemaps in that library.
*/
var BasemapsClient = /** @class */ (function () {
    function BasemapsClient(client) {
        this.client = client;
        /**
         * @General A lookup list of all the basemap names that we provide.
         * Soon we will have a code example in which you can see what the different basemaps look like.
         * @Alternative Use the basemapNames getter if you want to get a list of keys which you can use to get the GLStyleURL.
        */
        this.basemapsLookup = {
            'Bright': 'osm-bright-gl-style',
            'Light': 'positron-gl-style',
            'Light No-Labels': 'positron-nolabels-gl-style',
            'Dark': 'dark-matter-gl-style',
            'Dark No-Labels': 'dark-matter-nolabels-gl-style',
            'Gray': 'gray-gl-style',
            'Gray No-Labels': 'gray-nolabels-gl-style',
            'Light blue': 'blueberry-gl-style',
            'Dark blue': 'fiord-color-gl-style',
            'Dark blue No-Labels': 'fiord-color-nolabels-gl-style',
            'Basic': 'klokantech-basic-gl-style',
            'Toner': 'toner-gl-style',
        };
    }
    Object.defineProperty(BasemapsClient.prototype, "basemapNames", {
        /**
         * @Format Note that the basemap names start with a capital letter.
         * @Return A list of basemap names which can be used to pass as a parameter in the getGLStyleURL method.
        */
        get: function () {
            return Object.keys(this.basemapsLookup);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @General Get a GL style URL which can be used in Mapbox.
     * @Exceptions This method can throw the error "valid style name required to access Targomo basemap".
     * This error is thrown when the passed basremapName does not exist in basemapsLookup.
     * Make sure that you get the basemapName with the basemapNames accessor when this error is thrown.
     * @Example
     * ``` js
     * const basemaps = targomoClient.basemaps;
     * const basemapNames = basemaps.basemapNames;
     * const name = basemapNames[0];
     * const styleURL = basemaps.getStyleURL(name);
     * yourMapboxMap.setStyle(styleUrl);
     * ```
     * @Return Url for mapbox-gl style.
     * @Param basemapName
     * A string of valid basemap name (which you can get from the basemapNames accessor)
    */
    BasemapsClient.prototype.getGLStyleURL = function (basemapName) {
        if (!basemapName || !this.basemapsLookup[basemapName]) {
            throw new Error('valid style name required to access Targomo basemap');
        }
        return new exports.UrlUtil.TargomoUrl(this.client)
            .host(this.client.config.basemapsUrl)
            .part(this.basemapsLookup[basemapName] + '.json')
            .params({ key: this.client.serviceKey })
            .toString();
    };
    return BasemapsClient;
}());

/**
 * @Topic Geocoding
 */
var GeocodingClients = /** @class */ (function () {
    function GeocodingClients(esri, photon) {
        this.esri = esri;
        this.photon = photon;
    }
    return GeocodingClients;
}());
var TargomoClient = /** @class */ (function () {
    /**
     * Create a new Targomo client
     * @param region Service region name or full service URL. See: https://developers.route360.net/availability/
     * @param serviceKey Your targomo service key
     * @param additionalOptions additional options, defaults will be used if not provided
     */
    function TargomoClient(region, serviceKey, options) {
        this.serviceKey = serviceKey;
        if (!region) {
            throw new TypeError('Region parameter is missing');
        }
        this.config = new ClientConfig(options);
        if (!region.includes('http') && !region.includes('localhost') && !region.includes('/')) {
            this.serviceUrl = 'https://api.targomo.com/' + region + '/';
        }
        else {
            this.serviceUrl = region;
        }
        this.pois = new PointsOfInterestClient(this);
        this.statistics = new StatisticsClient(this);
        this.reachability = new ReachabilityClient(this);
        this.optimizations = new OptimizationsClient(this);
        this.geocoding = new GeocodingClients(new GeocodeEsriClient(), new GeocodePhotonClient(this));
        this.polygons = new PolygonsClient(this);
        this.routes = new RoutesClient(this);
        this.similarity = new SimilarityClient(this);
        this.benchmarks = new BenchmarksClient(this);
        this.statefulMultigraph = new StatefulMultigraphClient(this);
        this.multigraph = new MultigraphClient(this);
        this.basemaps = new BasemapsClient(this);
        this.fleets = new FleetsClient(this);
    }
    Object.defineProperty(TargomoClient.prototype, "endpoint", {
        /**
         * Extracts the endpoint part from the serviceUrl (for example `germany`)
         */
        get: function () {
            var items = this.serviceUrl.split('/').filter(function (item) { return !!item; });
            return items[items.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    TargomoClient.prototype.metadata = function () {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this)
                            .part(this.serviceUrl)
                            .version()
                            .part('/metadata/network')
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this).fetch(url)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return TargomoClient;
}());

// Barrel for API functions see https://angular.io/guide/glossary#barrel

var geometry = geometryModule; // NOTE: this does not export types, however we have none in there for now

exports.geometry = geometry;
exports.PointsOfInterestClient = PointsOfInterestClient;
exports.ClientConfig = ClientConfig;
exports.BenchmarksClient = BenchmarksClient;
exports.GeocodeEsriClient = GeocodeEsriClient;
exports.GeocodePhotonClient = GeocodePhotonClient;
exports.MultigraphClient = MultigraphClient;
exports.OptimizationsClient = OptimizationsClient;
exports.PolygonsClient = PolygonsClient;
exports.PolygonArray = PolygonArray;
exports.ReachabilityClient = ReachabilityClient;
exports.RoutesClient = RoutesClient;
exports.SimilarityClient = SimilarityClient;
exports.StatisticsClient = StatisticsClient;
exports.GeocodingClients = GeocodingClients;
exports.TargomoClient = TargomoClient;
exports.FleetsClient = FleetsClient;
exports.LatLng = LatLng;
exports.BoundingBox = BoundingBox;
exports.TravelSpeedValues = TravelSpeedValues;
exports.StatisticValues = StatisticValues;
exports.UseCacheRequestOptions = UseCacheRequestOptions;
exports.BaseRequestOptions = BaseRequestOptions;
exports.TravelRequestOptions = TravelRequestOptions;
exports.Route = Route;
exports.RouteSegment = RouteSegment;
exports.StatisticsResult = StatisticsResult;
exports.FpResult = FpResult;
exports.OptimizationResult = OptimizationResult;
exports.StatisticsGeometryResult = StatisticsGeometryResult;
exports.RequestsUtil = RequestsUtil;
exports.requests = requests;
exports.SimpleLRU = SimpleLRU;
exports.SimpleCache = SimpleCache;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=targomo-core.umd.js.map



/**
* @targomo/js-extensions "0.0.9" http://targomo.com
* Google and Leaflet JavaScript (& TypeScript) extensions for Targomo's time-based access mapping services.
* (c) 2020 Targomo
*/
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('leaflet'), require('@targomo/core'), require('leaflet.vectorgrid/dist/Leaflet.VectorGrid.bundled.js')) :
	typeof define === 'function' && define.amd ? define(['exports', 'leaflet', '@targomo/core', 'leaflet.vectorgrid/dist/Leaflet.VectorGrid.bundled.js'], factory) :
	(factory((global.tgm = global.tgm || {}, global.tgm.leaflet = {}),global.L,global.tgm));
}(this, (function (exports,L,core) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};









function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var transformEPSG3857 = (function (a, b, c, d) {
    return function (x, y, scale) {
        if (scale === void 0) { scale = 1; }
        x = scale * (a * x + b);
        y = scale * (c * y + d);
        return { x: x, y: y };
    };
})(0.5 / (Math.PI), 0.5, -(0.5 / (Math.PI)), 0.5);
function webMercatorToLeaflet(x, y, scale) {
    if (scale === void 0) { scale = 1; }
    return transformEPSG3857(x / 6378137, y / 6378137, scale);
}

/**
 *
 */
var ProjectedBounds = /** @class */ (function () {
    function ProjectedBounds(bounds) {
        this.southWest = new ProjectedPoint(Infinity, Infinity);
        this.northEast = new ProjectedPoint(-Infinity, -Infinity);
        if (bounds) {
            this.southWest = new ProjectedPoint(bounds.southWest.x, bounds.southWest.y);
            this.northEast = new ProjectedPoint(bounds.northEast.x, bounds.northEast.y);
        }
    }
    ProjectedBounds.prototype.expandPoint = function (x, y) {
        this.southWest.x = Math.min(this.southWest.x, x);
        this.northEast.x = Math.max(this.northEast.x, x);
        this.southWest.y = Math.min(this.southWest.y, y);
        this.northEast.y = Math.max(this.northEast.y, y);
    };
    ProjectedBounds.prototype.expand = function (bounds) {
        this.expandPoint(bounds.northEast.x, bounds.northEast.y);
        this.expandPoint(bounds.southWest.x, bounds.southWest.y);
    };
    ProjectedBounds.prototype.modifyIntersect = function (bounds) {
        this.southWest.x = Math.max(this.southWest.x, bounds.southWest.x);
        this.northEast.x = Math.min(this.northEast.x, bounds.northEast.x);
        this.southWest.y = Math.max(this.southWest.y, bounds.southWest.y);
        this.northEast.y = Math.min(this.northEast.y, bounds.northEast.y);
        return this;
    };
    // modifyExpand(bounds: ProjectedBounds) {
    //   this.southWest.x = Math.min(this.southWest.x, bounds.southWest.x)
    //   this.northEast.x = Math.max(this.northEast.x, bounds.northEast.x)
    //   this.southWest.y = Math.min(this.southWest.y, bounds.southWest.y)
    //   this.northEast.y = Math.max(this.northEast.y, bounds.northEast.y)
    //   return this
    // }
    ProjectedBounds.prototype.contains = function (bounds) {
        return (this.northEast.x >= bounds.northEast.x &&
            this.northEast.y >= bounds.northEast.y &&
            this.southWest.x <= bounds.southWest.x &&
            this.southWest.y <= bounds.southWest.y);
    };
    ProjectedBounds.prototype.intersects = function (bounds) {
        return !(this.northEast.x < bounds.southWest.x ||
            this.northEast.y < bounds.southWest.y ||
            this.southWest.x > bounds.northEast.x ||
            this.southWest.y > bounds.northEast.y);
    };
    ProjectedBounds.prototype.growOutwardsFactor = function (factor) {
        if (factor === void 0) { factor = 1; }
        var diffX = (this.northEast.x - this.southWest.x) * factor;
        var diffY = (this.northEast.y - this.southWest.y) * factor;
        this.northEast.x += diffX;
        this.northEast.y += diffY;
        this.southWest.x -= diffX;
        this.southWest.y -= diffY;
        return this;
    };
    ProjectedBounds.prototype.growOutwardsAmount = function (amount) {
        this.northEast.x += amount;
        this.northEast.y += amount;
        this.southWest.x -= amount;
        this.southWest.y -= amount;
        return this;
    };
    ProjectedBounds.prototype.toLineString = function () {
        return [
            // new ProjectedPoint(this.southWest.x, this.southWest.y),
            // new ProjectedPoint(this.northEast.x, this.southWest.y),
            // new ProjectedPoint(this.northEast.x, this.northEast.y),
            // new ProjectedPoint(this.southWest.x, this.northEast.y),
            new ProjectedPoint(this.southWest.x, this.northEast.y),
            new ProjectedPoint(this.northEast.x, this.northEast.y),
            new ProjectedPoint(this.northEast.x, this.southWest.y),
            new ProjectedPoint(this.southWest.x, this.southWest.y),
        ];
    };
    ProjectedBounds.prototype.reproject = function (project) {
        return new ProjectedBounds({
            northEast: project(this.northEast.x, this.northEast.y),
            southWest: project(this.southWest.x, this.southWest.y),
        });
    };
    ProjectedBounds.prototype.width = function () {
        return this.northEast.x - this.southWest.x;
    };
    ProjectedBounds.prototype.height = function () {
        return this.southWest.y - this.northEast.y;
    };
    ProjectedBounds.prototype.left = function () {
        return this.southWest.x;
    };
    ProjectedBounds.prototype.top = function () {
        return this.northEast.y;
    };
    return ProjectedBounds;
}());
/**
 *
 */
var ProjectedPoint = /** @class */ (function () {
    function ProjectedPoint(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * Checks if the given three points are collinear.
     */
    ProjectedPoint.prototype.isCollinear = function (before, after, tolerance) {
        if (before.x == after.x && before.y == after.y) {
            return false;
        }
        if (before.x == this.x && this.x == after.x) {
            return true;
        }
        if (before.y == this.y && this.y == after.y) {
            return true;
        }
        var val = (before.x * (this.y - after.y) + this.x * (after.y - before.y) + after.x * (before.y - this.y));
        return (val < tolerance && val > -tolerance && before.x != after.x && before.y != after.y);
    };
    /**
     *
     * @param point
     */
    ProjectedPoint.prototype.euclideanDistance = function (point) {
        return Math.sqrt(Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2));
    };
    return ProjectedPoint;
}());
/**
 *
 */
var ProjectedLineString = /** @class */ (function () {
    function ProjectedLineString(coordinates) {
        var _this = this;
        this.bounds3857 = new ProjectedBounds();
        this.points = coordinates.map(function (coordinate) {
            _this.bounds3857.expandPoint(coordinate[0], coordinate[1]);
            var pair = webMercatorToLeaflet(coordinate[0], coordinate[1], 1);
            return new ProjectedPoint(pair.x, pair.y);
        });
    }
    return ProjectedLineString;
}());
/**
 *
 */
var ProjectedPolygon = /** @class */ (function () {
    function ProjectedPolygon(data) {
        var _this = this;
        this.bounds3857 = new ProjectedBounds();
        this.travelTime = data.travelTime;
        this.area = data.area;
        this.lineStrings = [new ProjectedLineString(data.outerBoundary)];
        this.bounds3857.expand(this.lineStrings[0].bounds3857);
        if (data.innerBoundary) {
            data.innerBoundary.forEach(function (innerBoundary) {
                var lineString = new ProjectedLineString(innerBoundary);
                _this.lineStrings.push(lineString);
                _this.bounds3857.expand(lineString.bounds3857);
            });
        }
    }
    ProjectedPolygon.prototype.getOuterBoundary = function () {
        return this.lineStrings[0];
    };
    ProjectedPolygon.prototype.getInnerBoundary = function () {
        return this.lineStrings.slice(1);
    };
    return ProjectedPolygon;
}());
/**
 *
 */
var ProjectedMultiPolygon = /** @class */ (function () {
    function ProjectedMultiPolygon(data) {
        var _this = this;
        this.polygons = {};
        this.bounds3857 = new ProjectedBounds();
        data.forEach(function (multipolygonData) {
            multipolygonData.polygons.forEach(function (polygonData) {
                var polygon = new ProjectedPolygon(polygonData);
                _this.polygons[polygon.travelTime] = _this.polygons[polygon.travelTime] || [];
                _this.polygons[polygon.travelTime].push(polygon);
                _this.bounds3857.expand(polygon.bounds3857);
            });
        });
    }
    ProjectedMultiPolygon.prototype.forEach = function (callback) {
        var _this = this;
        var keys = Object.keys(this.polygons).map(function (key) { return +key; }).sort(function (a, b) { return b - a; });
        keys.forEach(function (key, i) { return callback(+key, _this.polygons[key], i); });
    };
    return ProjectedMultiPolygon;
}());

/**
 * [clip clipping like sutherland http://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping#JavaScript]
 */
function clip(subjectPolygon, clipPolygon) {
    var cp1, cp2, s, e;
    var inside = function (p) {
        return (cp2.x - cp1.x) * (p.y - cp1.y) > (cp2.y - cp1.y) * (p.x - cp1.x);
    };
    var intersection = function () {
        var dc = new ProjectedPoint(cp1.x - cp2.x, cp1.y - cp2.y), dp = new ProjectedPoint(s.x - e.x, s.y - e.y), n1 = cp1.x * cp2.y - cp1.y * cp2.x, n2 = s.x * e.y - s.y * e.x, n3 = 1.0 / (dc.x * dp.y - dc.y * dp.x);
        return new ProjectedPoint((n1 * dp.x - n2 * dc.x) * n3, (n1 * dp.y - n2 * dc.y) * n3);
    };
    var outputList = subjectPolygon;
    cp1 = clipPolygon[clipPolygon.length - 1];
    for (var j in clipPolygon) {
        cp2 = clipPolygon[j];
        var inputList = outputList;
        outputList = [];
        s = inputList[inputList.length - 1]; // last on the input list
        for (var i in inputList) {
            e = inputList[i];
            if (inside(e)) {
                if (!inside(s)) {
                    outputList.push(intersection());
                }
                outputList.push(e);
            }
            else if (inside(s)) {
                outputList.push(intersection());
            }
            s = e;
        }
        cp1 = cp2;
    }
    return outputList;
}

var COLORS = ['#006837', '#39B54A', '#8CC63F', '#F7931E', '#F15A24', '#C1272D'];
var COLORS_MAP = {};
COLORS.forEach(function (color, i) {
    COLORS_MAP[(i + 1) * 300] = color;
});
function isPolygonRenderColorComplexOption(option) {
    return option && option.color != null;
}
var PolygonRenderOptionsData = /** @class */ (function () {
    function PolygonRenderOptionsData() {
        this.inverse = false;
        // colors: ({[edgeWeight: number]: PolygonRenderColorOption}) | (PolygonRenderColorOption[]) = COLORS
        this.colors = COLORS_MAP;
        this.opacity = 0.5;
        this.strokeWidth = 5;
    }
    return PolygonRenderOptionsData;
}());
var PolygonRenderOptions = /** @class */ (function (_super) {
    __extends(PolygonRenderOptions, _super);
    function PolygonRenderOptions(data) {
        var _this = _super.call(this) || this;
        Object.assign(_this, data);
        return _this;
    }
    PolygonRenderOptions.prototype.getColorOpacity = function (travelTime, index) {
        var option = null;
        if (this.colors instanceof Array) {
            option = this.colors[index];
        }
        else {
            option = this.colors[travelTime];
        }
        if (isPolygonRenderColorComplexOption(option)) {
            return {
                color: option.color || '#ccc',
                opacity: option.opacity || 1
            };
        }
        else {
            return {
                color: option || '#ccc',
                opacity: 1
            };
        }
    };
    return PolygonRenderOptions;
}(PolygonRenderOptionsData));

var idCounter = 0;
function renderPath(svgData, elementOptions) {
    var initialOpacity = elementOptions.opacity;
    return "\n    <g style='opacity: " + initialOpacity + "'>\n      <path style='stroke: " + elementOptions.color + ";\n            fill: " + elementOptions.color + ";\n            stroke-opacity: " + elementOptions.opacity + ";\n            stroke-width: " + elementOptions.strokeWidth + ";\n            fill-opacity: " + elementOptions.opacity + "'\n\n            d='" + svgData + "'/>\n    </g>\n  ";
}
function renderElement(children, width, height) {
    return "\n    <svg  height=\"100%\" width=\"100%\" viewbox=\"0 0 " + width + " " + height + "\"\n          style='opacity: 1; stroke-linejoin:round; stroke-linecap:round; fill-rule: evenodd'\n          xmlns='http://www.w3.org/2000/svg'>\n          " + children.join('\n') + "\n    </svg>";
}
function renderInverseElement(children, width, height) {
    var id = 'tgm:inverse:' + idCounter++;
    var svgFrame = "M 0 0 L " + width + " 0 L " + width + " " + height + " L 0 " + height + " z";
    var frame = "<path style='mask: url(#mask_" + id + ")' d='" + svgFrame + "'/>";
    var newSvg = "\n    <defs>\n      <mask id='mask_" + id + "'>\n          <path style='fill-opacity:1; stroke: white; fill:white;' d='" + svgFrame + "'/>\"\n          " + children.join('\n') + "\n      </mask>\n    </defs>\n  ";
    return "\n    <svg  height=\"100%\" width=\"100%\" viewbox=\"0 0 " + width + " " + height + "\"\n          style='opacity: 1; stroke-linejoin:round; stroke-linecap:round; fill-rule: evenodd'\n          xmlns='http://www.w3.org/2000/svg'>\n          " + frame + "\n          " + newSvg + "\n    </svg>";
}
/**
 *
 * @param viewport
 * @param bounds3857
 * @param zoomFactor
 * @param multipolygons
 */
function render(viewport, bounds3857, zoomFactor, multipolygons, options) {
    var _a;
    var pairMin = webMercatorToLeaflet(bounds3857.southWest.x, bounds3857.southWest.y, zoomFactor);
    var pairMax = webMercatorToLeaflet(bounds3857.northEast.x, bounds3857.northEast.y, zoomFactor);
    if (pairMax.y < pairMin.y) {
        _a = [pairMin.y, pairMax.y], pairMax.y = _a[0], pairMin.y = _a[1];
    }
    var xMinLeaflet = Math.floor(pairMin.x);
    var yMinLeaflet = Math.floor(pairMin.y);
    var xMaxLeaflet = Math.ceil(pairMax.x);
    var yMaxLeaflet = Math.ceil(pairMax.y);
    var projectedViewport = new ProjectedBounds(viewport)
        .reproject(webMercatorToLeaflet);
    var projectedViewportLineString = projectedViewport.toLineString();
    function renderLineString(pathData, points) {
        // points = collinear.filterCollinear(points, 1 / (zoomFactor * 100000))
        points = clip(points, projectedViewportLineString);
        points.forEach(function (point, i) {
            var suffix = i > 0 ? 'L' : 'M';
            var x = Math.round((point.x) * zoomFactor) - xMinLeaflet;
            var y = Math.round((point.y) * zoomFactor) - yMinLeaflet;
            var generatedPoint = suffix + " " + x + " " + y;
            pathData.push(generatedPoint);
        });
        if (pathData.length > 0) {
            pathData.push('z'); // svgz
        }
        return pathData;
    }
    function renderPolygon(polygon) {
        var pathData = [];
        if (viewport.intersects(polygon.bounds3857)) {
            renderLineString(pathData, polygon.getOuterBoundary().points);
            polygon.getInnerBoundary().forEach(function (innerBoundary) {
                if (viewport.intersects(innerBoundary.bounds3857)) {
                    renderLineString(pathData, innerBoundary.points);
                }
            });
        }
        return pathData;
    }
    var children = [];
    multipolygons.forEach(function (travelTime, polygons, i) {
        var svgData = polygons.map(function (item) { return renderPolygon(item).join(' '); }).join(' ');
        if (svgData.length != 0) {
            var polygonOption = options.getColorOpacity(travelTime, i);
            children.push(renderPath(svgData, __assign({}, polygonOption, { strokeWidth: options.strokeWidth, color: options.inverse ? 'black' : polygonOption.color })));
        }
    });
    var width = Math.ceil(Math.abs(xMaxLeaflet - xMinLeaflet));
    var height = Math.ceil(Math.abs(yMaxLeaflet - yMinLeaflet));
    var content;
    if (options.inverse) {
        content = renderInverseElement(children, width, height);
    }
    else {
        content = renderElement(children, width, height);
    }
    return { content: content, width: width, height: height };
}

var MinMaxSchedule = /** @class */ (function () {
    function MinMaxSchedule(min, max) {
        if (min === void 0) { min = 200; }
        if (max === void 0) { max = 700; }
        this.min = min;
        this.max = max;
    }
    MinMaxSchedule.prototype.schedule = function (callback) {
        var _this = this;
        var action = function () {
            clearTimeout(_this.longTimeout);
            clearTimeout(_this.shortTimeout);
            _this.longTimeout = null;
            _this.shortTimeout = null;
            callback();
        };
        if (!this.longTimeout) {
            this.longTimeout = setTimeout(action, this.max);
        }
        clearTimeout(this.shortTimeout);
        this.shortTimeout = setTimeout(action, this.min);
    };
    MinMaxSchedule.prototype.scheduleMaximum = function (callback) {
        var _this = this;
        var action = function () {
            clearTimeout(_this.longTimeout);
            _this.longTimeout = null;
            callback();
        };
        if (!this.longTimeout) {
            this.longTimeout = setTimeout(action, this.max);
        }
        clearTimeout(this.shortTimeout);
    };
    return MinMaxSchedule;
}());

/**
 *
 */
var PolygonOverlayElement = /** @class */ (function () {
    /**
     *
     * @param map
     */
    function PolygonOverlayElement(plugin, options) {
        this.plugin = plugin;
        this.options = options;
        this.renderTimeout = new MinMaxSchedule(300, 3000);
    }
    PolygonOverlayElement.prototype.getElement = function () {
        return this.divElement;
    };
    /**
     *
     */
    PolygonOverlayElement.prototype.draw = function (immediately) {
        var _this = this;
        if (immediately === void 0) { immediately = false; }
        if (immediately) {
            this.resize();
            this.render();
            this.divElement.style.transform = null;
        }
        else {
            if (this.divElement && this.bounds) {
                var bounds = new ProjectedBounds(this.plugin.getElementPixels(this.bounds));
                var div = this.divElement;
                var dx = Math.round(bounds.left() - this.currentPixelBounds.left());
                var dy = Math.round(bounds.top() - this.currentPixelBounds.top());
                var scaleX = bounds.width() / this.currentPixelBounds.width();
                var scaleY = bounds.height() / this.currentPixelBounds.height();
                if (scaleY !== 1 || scaleX !== 1) {
                    div.style.transform = "translate3d(" + dx + "px, " + dy + "px, 0) scale3d(" + scaleX + ", " + scaleY + ", 1)";
                }
                else if (dx !== 0 || dy !== 0) {
                    div.style.transform = "translate3d(" + dx + "px, " + dy + "px, 0)";
                }
            }
            this.renderTimeout.scheduleMaximum(function () {
                _this.render();
                _this.divElement.style.transform = null;
            });
        }
    };
    PolygonOverlayElement.prototype.resize = function () {
        if (!this.divElement || !this.bounds) {
            return;
        }
        var bounds = this.currentPixelBounds = new ProjectedBounds(this.plugin.getElementPixels(this.bounds));
        var div = this.divElement;
        div.style.left = bounds.left() + 'px';
        div.style.top = bounds.top() + 'px';
        div.style.width = bounds.width() + 'px';
        div.style.height = bounds.height() + 'px';
        div.style.transform = null;
    };
    /**
     *
     */
    PolygonOverlayElement.prototype.initElement = function () {
        var div = document.createElement('div');
        div.style.borderStyle = 'none';
        div.style.borderWidth = '0px';
        div.style.position = 'absolute';
        div.style.opacity = ('' + this.options.opacity) || '0.5';
        div.style['backface-visibility'] = 'hidden';
        div.style['perspective'] = 1000;
        div.style['transform-origin'] = '0 0 0';
        div.style['will-change'] = 'transform';
        this.divElement = div;
        return this.divElement;
    };
    /**
     *
     */
    PolygonOverlayElement.prototype.onRemove = function () {
        this.divElement.parentNode.removeChild(this.divElement);
        this.divElement = null;
    };
    /**
     *
     * @param multipolygon
     */
    PolygonOverlayElement.prototype.setData = function (multipolygon) {
        if (multipolygon) {
            this.model = new ProjectedMultiPolygon(multipolygon);
        }
        else {
            this.model = null;
        }
        this.render();
    };
    PolygonOverlayElement.prototype.setInverse = function (inverse) {
        this.options.inverse = inverse;
        this.render();
    };
    PolygonOverlayElement.prototype.setColors = function (colors) {
        this.options.colors = colors;
        this.render();
    };
    PolygonOverlayElement.prototype.setOpacity = function (opacity) {
        this.options.opacity = opacity;
        if (this.divElement) {
            this.divElement.style.opacity = '' + this.options.opacity || '0.5';
        }
    };
    PolygonOverlayElement.prototype.setStrokeWidth = function (strokeWidth) {
        this.options.strokeWidth = strokeWidth;
        this.render();
    };
    PolygonOverlayElement.prototype.boundsCalculation = function (growFactor) {
        var projectedMultiPolygon = this.model;
        var inverse = this.options.inverse;
        var viewPort = new ProjectedBounds(this.plugin.getViewPort()); // .growOutwardsAmount(this.options && this.options.strokeWidth || 0)
        var bounds = new ProjectedBounds(viewPort);
        var newBounds = new ProjectedBounds(bounds).growOutwardsFactor(growFactor).modifyIntersect(projectedMultiPolygon.bounds3857);
        if (inverse) {
            newBounds.expand(viewPort);
            newBounds.growOutwardsFactor(growFactor);
        }
        bounds.growOutwardsFactor(growFactor);
        // pixel to
        var southWest = core.geometry.webMercatorToLatLng(viewPort.southWest, undefined);
        var northEast = core.geometry.webMercatorToLatLng(viewPort.northEast, undefined);
        var newPixelBounds = this.plugin.getElementPixels({ southWest: southWest, northEast: northEast });
        var ratio = Math.abs((viewPort.northEast.x - viewPort.southWest.x) / newPixelBounds.northEast.x - newPixelBounds.southWest.x);
        newBounds.growOutwardsAmount(this.options && (ratio * this.options.strokeWidth) || 0);
        //
        return { bounds: bounds, newBounds: newBounds };
    };
    PolygonOverlayElement.prototype.render = function (resize) {
        if (resize === void 0) { resize = true; }
        if (!this.divElement) {
            return;
        }
        if (!this.model) {
            this.divElement.innerHTML = '';
            return;
        }
        var zoom = this.plugin.getZoom();
        var zoomFactor = Math.pow(2, zoom) * 256;
        zoomFactor = Math.min(10000000, zoomFactor);
        var growFactor = 0.1;
        var _a = this.boundsCalculation(growFactor), bounds = _a.bounds, newBounds = _a.newBounds;
        var content = render(bounds, newBounds, zoomFactor, this.model, new PolygonRenderOptions(this.options)).content;
        this.divElement.innerHTML = content;
        var southWest = core.geometry.webMercatorToLatLng(newBounds.southWest, undefined);
        var northEast = core.geometry.webMercatorToLatLng(newBounds.northEast, undefined);
        this.bounds = { southWest: southWest, northEast: northEast };
        if (resize) {
            this.resize();
        }
    };
    return PolygonOverlayElement;
}());

var LeafletPolygonOverlayOptions = /** @class */ (function (_super) {
    __extends(LeafletPolygonOverlayOptions, _super);
    function LeafletPolygonOverlayOptions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return LeafletPolygonOverlayOptions;
}(PolygonRenderOptionsData));
/**
 *
 */
var TgmLeafletPolygonOverlay = /** @class */ (function (_super) {
    __extends(TgmLeafletPolygonOverlay, _super);
    /**
     *
     * @param options
     */
    function TgmLeafletPolygonOverlay(options) {
        var _this = _super.call(this) || this;
        _this.readyPromise = new Promise(function (resolve) { return _this.readyResolve = resolve; });
        _this.options = Object.assign(new LeafletPolygonOverlayOptions(), options || {});
        return _this;
    }
    /**
     *
     * @param multipolygon
     */
    TgmLeafletPolygonOverlay.prototype.setData = function (multipolygon) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readyPromise];
                    case 1:
                        _a.sent();
                        if (this.element) {
                            this.element.setData(multipolygon);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     *
     */
    TgmLeafletPolygonOverlay.prototype.draw = function () {
        if (this.element) {
            L.DomUtil.setTransform(this.element.getElement(), new L.Point(0, 0), null);
            this.element.draw(true);
        }
    };
    /**
     *
     * @param map
     */
    TgmLeafletPolygonOverlay.prototype.onAdd = function (map) {
        var _this = this;
        this.element = new PolygonOverlayElement({
            getZoom: function () {
                return map.getZoom();
            },
            getViewPort: function () {
                var bounds = map.getBounds();
                return new ProjectedBounds({
                    northEast: core.geometry.latLngToWebMercator({
                        lng: bounds.getNorthEast().lng,
                        lat: bounds.getNorthEast().lat,
                    }),
                    southWest: core.geometry.latLngToWebMercator({
                        lng: bounds.getSouthWest().lng,
                        lat: bounds.getSouthWest().lat,
                    })
                });
            },
            getElementPixels: function (bounds) {
                var northEast = map.latLngToLayerPoint(bounds.northEast);
                var southWest = map.latLngToLayerPoint(bounds.southWest);
                return { northEast: northEast, southWest: southWest };
            }
        }, this.options);
        var div = this.element.initElement();
        div.style.transformOrigin = 'center';
        L.DomUtil.addClass(div, 'leaflet-zoom-' + ('animated'));
        map.getPanes().overlayPane.appendChild(div);
        // const draw = () => this.draw()
        map.on('moveend', this.draw, this);
        map.on('resize', this.draw, this);
        map.on('zoomend', this.draw, this);
        var animated = this._map.options.zoomAnimation && L.Browser.any3d;
        if (animated) {
            map.on('zoomanim', function (e) {
                if (_this.element.bounds) {
                    var scale = map.getZoomScale(e.zoom, map.getZoom());
                    var pos1 = map._latLngToNewLayerPoint(_this.element.bounds.southWest, e.zoom, e.center).round();
                    var pos2 = map._latLngToNewLayerPoint(_this.element.bounds.northEast, e.zoom, e.center).round();
                    var cur1 = map._latLngToNewLayerPoint(_this.element.bounds.southWest, map.getZoom(), map.getCenter()).round();
                    var cur2 = map._latLngToNewLayerPoint(_this.element.bounds.northEast, map.getZoom(), map.getCenter()).round();
                    var pos = { x: (pos1.x + pos2.x) / 2, y: (pos1.y + pos2.y) / 2 };
                    var cur = { x: (cur1.x + cur2.x) / 2, y: (cur1.y + cur2.y) / 2 };
                    L.DomUtil.setTransform(div, new L.Point(pos.x - cur.x, pos.y - cur.y), scale);
                }
            });
        }
        this.readyResolve();
        this.draw();
        return this;
    };
    TgmLeafletPolygonOverlay.prototype.onRemove = function () {
        if (this.element) {
            this.element.onRemove();
            this.element = null;
        }
        return this;
    };
    /**
     *
     * @param inverse
     */
    TgmLeafletPolygonOverlay.prototype.setInverse = function (inverse) {
        this.options.inverse = inverse;
        this.draw();
    };
    /**
     *
     * @param colors
     */
    TgmLeafletPolygonOverlay.prototype.setColors = function (colors) {
        this.options.colors = colors;
        this.draw();
    };
    /**
     *
     * @param opacity
     */
    TgmLeafletPolygonOverlay.prototype.setOpacity = function (opacity) {
        this.options.opacity = opacity;
        if (this.element) {
            var div = this.element.getElement();
            div.style.opacity = this.options.opacity != null ? ('' + this.options.opacity) : '0.5';
        }
    };
    /**
     *
     * @param strokeWidth
     */
    TgmLeafletPolygonOverlay.prototype.setStrokeWidth = function (strokeWidth) {
        this.options.strokeWidth = strokeWidth;
        this.draw();
    };
    return TgmLeafletPolygonOverlay;
}(L.Layer));

var TgmLeafletTileLayer = /** @class */ (function (_super) {
    __extends(TgmLeafletTileLayer, _super);
    function TgmLeafletTileLayer(tgmClient, basemapName, options) {
        var _this = this;
        if (!basemapName && !tgmClient.basemaps.basemapsLookup[basemapName]) {
            throw new Error('valid style name required to access Targomo basemap');
        }
        var tileUrl = 'https://maps.targomo.com/styles/' +
            tgmClient.basemaps.basemapsLookup[basemapName] +
            '/rendered/{z}/{x}/{y}.png?key=' +
            tgmClient.serviceKey;
        _this = _super.call(this, tileUrl, options) || this;
        return _this;
    }
    TgmLeafletTileLayer.getTileLayerList = function (tgmClient) {
        var tileLayerList = {};
        tgmClient.basemaps.basemapNames.forEach(function (basemapName) {
            tileLayerList[basemapName] = new TgmLeafletTileLayer(tgmClient, basemapName, {});
        });
        return tileLayerList;
    };
    return TgmLeafletTileLayer;
}(L.TileLayer));

var TgmLeafletMultigraphTileLayer = /** @class */ (function () {
    function TgmLeafletMultigraphTileLayer(tgmClient, sources, multigraphOptions, vectorTileoptions) {
        this.tgmClient = tgmClient;
        this.update(multigraphOptions, vectorTileoptions, sources);
    }
    TgmLeafletMultigraphTileLayer.prototype.addTo = function (map) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!this.layer) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.createLayer()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        this.map = map;
                        this.layer.addTo(map);
                        return [2 /*return*/];
                }
            });
        });
    };
    TgmLeafletMultigraphTileLayer.prototype.update = function (multigraphOptions, vectorTileoptions, sources) {
        if (multigraphOptions) {
            this.multigraphOptions = multigraphOptions;
        }
        if (vectorTileoptions) {
            this.vectorTileoptions = vectorTileoptions;
        }
        if (sources) {
            this.sources = sources;
        }
        return this.createLayer();
    };
    TgmLeafletMultigraphTileLayer.prototype.createLayer = function () {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.map && this.layer) {
                            this.map.removeLayer(this.layer);
                        }
                        return [4 /*yield*/, this.tgmClient.multigraph.getTiledMultigraphUrl(this.sources, this.multigraphOptions, 'mvt')];
                    case 1:
                        url = _a.sent();
                        this.layer = L.vectorGrid.protobuf(url, this.vectorTileoptions);
                        if (this.map && this.layer) {
                            this.layer.addTo(this.map);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    return TgmLeafletMultigraphTileLayer;
}());

exports.LeafletPolygonOverlayOptions = LeafletPolygonOverlayOptions;
exports.TgmLeafletPolygonOverlay = TgmLeafletPolygonOverlay;
exports.TgmLeafletTileLayer = TgmLeafletTileLayer;
exports.TgmLeafletMultigraphTileLayer = TgmLeafletMultigraphTileLayer;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=targomo-leaflet.umd.js.map
