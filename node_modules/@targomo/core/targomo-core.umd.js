/** 
* @targomo/core "0.2.19" http://targomo.com
* The JavaScript (& TypeScript) API for Targomo's time-based access mapping services.
* (c) 2020 Targomo
*/
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.tgm = {})));
}(this, (function (exports) { 'use strict';

(function(self) {
  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    };

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue+','+value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) { items.push(name); });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) { items.push(value); });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) { items.push([name, value]); });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);
      var xhr = new XMLHttpRequest();

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  };
  self.fetch.polyfill = true;
})(typeof self !== 'undefined' ? self : window);

// TODO: or rename to ClientDefaults maybe to make it more clear
// TODO: add more defaults here ...ex same stuff as in r360-js
var ClientConfig = /** @class */ (function () {
    // routeTypes  = [
    //   // non transit
    //   { routeType : 'WALK'     , color : 'red',       haloColor : 'white'},
    //   { routeType : 'BIKE'     , color : '#558D54',   haloColor : 'white'},
    //   { routeType : 'CAR'      , color : '#558D54',   haloColor : 'white'},
    //   { routeType : 'TRANSFER' , color : '#C1272D',   haloColor : 'white'},
    //   // berlin
    //   { routeType : 102        , color : '#006837',   haloColor : 'white' },
    //   { routeType : 400        , color : '#156ab8',   haloColor : 'white' },
    //   { routeType : 900        , color : 'red',       haloColor : 'white' },
    //   { routeType : 700        , color : '#A3007C',   haloColor : 'white' },
    //   { routeType : 1000       , color : 'blue',      haloColor : 'white' },
    //   { routeType : 109        , color : '#006F35',   haloColor : 'white' },
    //   { routeType : 100        , color : 'red',       haloColor : 'white' },
    //   // new york
    //   { routeType : 1          , color : 'red',       haloColor : 'red'},
    //   { routeType : 2          , color : 'blue',      haloColor : 'blue'},
    //   { routeType : 3          , color : 'yellow',    haloColor : 'yellow'},
    //   { routeType : 0          , color : 'green',     haloColor : 'green'},
    //   { routeType : 4          , color : 'orange',    haloColor : 'orange'},
    //   { routeType : 5          , color : 'red',       haloColor : 'red'},
    //   { routeType : 6          , color : 'blue',      haloColor : 'blue'},
    //   { routeType : 7          , color : 'yellow',    haloColor : 'yellow' }
    // ]
    function ClientConfig(options) {
        this.serverUrl = 'https://api.targomo.com/';
        this.statisticsUrl = 'https://api.targomo.com/statistics/';
        this.tilesUrl = 'https://api.targomo.com/vector-statistics/';
        this.poiUrl = 'https://api.targomo.com/pointofinterest/';
        this.mapTilesUrl = 'https://maps.targomo.com/';
        this.photonGeocoderUrl = 'https://api.targomo.com/geocode/';
        this.overpassUrl = 'https://api.targomo.com/overpass/';
        this.fleetsUrl = 'https://api.targomo.com/fleetplanner/';
        this.basemapsUrl = 'https://maps.targomo.com/styles/';
        this.version = 1;
        this.debug = false;
        Object.assign(this, options);
    }
    return ClientConfig;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};









function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var SimpleLRUEntry = /** @class */ (function () {
    function SimpleLRUEntry(value, key, previous, next) {
        this.value = value;
        this.key = key;
        this.previous = previous;
        this.next = next;
    }
    return SimpleLRUEntry;
}());
/**
 * Extremely simple LRU (to avoid includinng another library)...However when more functionality is needed then an existing library is better
 */
var SimpleLRU = /** @class */ (function () {
    function SimpleLRU(capacity) {
        if (capacity === void 0) { capacity = 0; }
        this.capacity = capacity;
        this.map = {};
        this.size = 0;
    }
    /**
     * If a value for a given key is contained in the cache then return that value
     * otherwise create/store and return a new value, by calling the given `factory` function
     *
     * @param key
     * @param factory
     */
    SimpleLRU.prototype.get = function (key, factory) {
        return __awaiter(this, void 0, void 0, function () {
            var found, e_1, promise, entry, value, current;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        found = this.map[key];
                        if (!(found !== undefined)) return [3 /*break*/, 5];
                        if (this.oldest == found && found.next) {
                            this.oldest = found.next;
                        }
                        if (found.next) {
                            found.next.previous = found.previous;
                        }
                        if (found.previous) {
                            found.previous.next = found.next;
                        }
                        found.previous = this.newest;
                        found.next = null;
                        this.newest = found;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, found.value];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_1 = _a.sent();
                        this.map[key] = undefined;
                        return [2 /*return*/, this.get(key, factory)];
                    case 4: return [3 /*break*/, 8];
                    case 5:
                        if (!factory) return [3 /*break*/, 7];
                        promise = factory();
                        entry = this.map[key] = new SimpleLRUEntry(promise, key, this.newest, null);
                        return [4 /*yield*/, promise];
                    case 6:
                        value = _a.sent();
                        if (this.newest) {
                            this.newest.next = entry;
                        }
                        this.newest = entry;
                        if (this.capacity) {
                            if (this.size >= this.capacity) {
                                current = this.oldest;
                                if (current) {
                                    this.oldest = current.next;
                                    delete this.map[current.key];
                                }
                            }
                            else {
                                this.size++;
                            }
                        }
                        if (!this.oldest) {
                            this.oldest = this.newest;
                        }
                        return [2 /*return*/, value];
                    case 7: return [2 /*return*/, undefined];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    return SimpleLRU;
}());
/**
 * Even simpler unlimited cache
 */
var SimpleCache = /** @class */ (function () {
    function SimpleCache() {
        this.map = {};
    }
    SimpleCache.prototype.get = function (key, factory) {
        return __awaiter(this, void 0, void 0, function () {
            var keyString, value;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (typeof key === 'string') {
                            keyString = key;
                        }
                        else {
                            keyString = JSON.stringify(key);
                        }
                        if (!(this.map[keyString] != undefined)) return [3 /*break*/, 1];
                        return [2 /*return*/, this.map[keyString]];
                    case 1: return [4 /*yield*/, factory()];
                    case 2:
                        value = _a.sent();
                        this.map[keyString] = value;
                        return [2 /*return*/, value];
                }
            });
        });
    };
    return SimpleCache;
}());

var CACHE = new SimpleCache();
function logBody(body) {
    if (body instanceof String || typeof body === 'string') {
        console.log(body);
    }
    else {
        console.log(JSON.stringify(body, null, 2));
    }
}
var RequestsUtil = /** @class */ (function () {
    function RequestsUtil(options) {
        this.options = options;
    }
    RequestsUtil.prototype.fetch = function (url, method, payload, headers) {
        if (method === void 0) { method = 'GET'; }
        if (headers === void 0) { headers = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestMethod, requestHeaders, requestOptions, response, responseBody, _a, _b, _c, responseValue, data, start, end, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        requestMethod = method;
                        if (method !== 'JSONP') {
                            headers['Accept'] = headers['Accept'] ? headers['Accept'] : 'application/json';
                        }
                        else {
                            requestMethod = 'GET';
                        }
                        if (method === 'POST-RAW') {
                            requestMethod = 'POST';
                        }
                        if (requestMethod === 'PUT' || requestMethod === 'POST') {
                            headers['Content-Type'] = 'application/json';
                        }
                        requestHeaders = new Headers(headers);
                        requestOptions = {
                            method: requestMethod,
                            headers: requestHeaders
                        };
                        if (method === 'POST-RAW') {
                            requestOptions.body = payload;
                        }
                        else if (method !== 'GET' && method !== 'JSONP') {
                            requestOptions.body = JSON.stringify(payload);
                        }
                        return [4 /*yield*/, fetch(url, requestOptions)];
                    case 1:
                        response = _e.sent();
                        if ((this.options && this.options.debug) || response.status >= 400) {
                            console.log('[TargomoClient Begin]');
                            console.log('[Request]', requestOptions.method, url);
                            console.log("  [Headers]");
                            requestHeaders.forEach(function (value, key) {
                                console.log("    " + key + " = " + value);
                            });
                            if (requestOptions.body) {
                                console.log("  [Body]");
                                console.log(requestOptions.body);
                            }
                            console.log('[Response]');
                            console.log('    status = ', response.status);
                            console.log('    statusText = ', response.statusText);
                            console.log("  [Headers]");
                            response.headers.forEach(function (value, key) {
                                console.log("    " + key + " = " + value);
                            });
                        }
                        if (!(response.status >= 400)) return [3 /*break*/, 6];
                        console.log("  [Body]");
                        if (!(response.headers.get('content-type') === 'application/json')) return [3 /*break*/, 3];
                        _c = (_b = JSON).stringify;
                        return [4 /*yield*/, response.text()];
                    case 2:
                        _a = _c.apply(_b, [_e.sent(), null, 2]);
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, response.text()];
                    case 4:
                        _a = _e.sent();
                        _e.label = 5;
                    case 5:
                        responseBody = _a;
                        logBody(responseBody);
                        console.log('[TargomoClient End]');
                        throw new Error(responseBody);
                    case 6:
                        responseValue = null;
                        if (!(method === 'JSONP')) return [3 /*break*/, 8];
                        return [4 /*yield*/, response.text()];
                    case 7:
                        data = _e.sent();
                        start = data.indexOf('(');
                        end = data.lastIndexOf(')');
                        if (start > -1 && end > -1) {
                            responseValue = JSON.parse(data.substring(start + 1, end));
                        }
                        else {
                            responseValue = JSON.parse(data);
                        }
                        return [3 /*break*/, 11];
                    case 8:
                        if (!(method === 'POST-RAW')) return [3 /*break*/, 10];
                        return [4 /*yield*/, response.text()];
                    case 9:
                        responseValue = _e.sent();
                        return [3 /*break*/, 11];
                    case 10:
                        responseValue = response.json();
                        _e.label = 11;
                    case 11:
                        if (!(this.options && this.options.debug)) return [3 /*break*/, 13];
                        console.log('  [Body]');
                        _d = logBody;
                        return [4 /*yield*/, responseValue];
                    case 12:
                        _d.apply(void 0, [_e.sent()]);
                        console.log('[TargomoClient End]');
                        _e.label = 13;
                    case 13: return [2 /*return*/, responseValue];
                }
            });
        });
    };
    RequestsUtil.prototype.fetchData = function (url, method, payload, headers) {
        if (method === void 0) { method = 'GET'; }
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetch(url, method, payload, headers)];
                    case 1:
                        result = _a.sent();
                        if (!result.data) {
                            console.warn('No data object was transmitted by ' + url + ' \nReturning raw response');
                            return [2 /*return*/, result];
                        }
                        else {
                            return [2 /*return*/, result.data];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     *
     * @param cache
     * @param url
     * @param method
     * @param payload
     */
    RequestsUtil.prototype.fetchCached = function (cache, url, method, payload, headers) {
        var _this = this;
        if (method === void 0) { method = 'GET'; }
        if (cache !== false) {
            if (cache === true || !cache) {
                cache = CACHE;
            }
            var key = JSON.stringify({ url: url, method: method, payload: payload });
            return cache.get(key, function () { return _this.fetch(url, method, payload, headers); });
        }
        else {
            return this.fetch(url, method, payload, headers);
        }
    };
    /**
     *
     * @param cache
     * @param url
     * @param method
     * @param payload
     */
    RequestsUtil.prototype.fetchCachedData = function (cache, url, method, payload, headers) {
        var _this = this;
        if (method === void 0) { method = 'GET'; }
        if (cache !== false) {
            if (cache === true || !cache) {
                cache = CACHE;
            }
            var key = JSON.stringify({ url: url, method: method, payload: payload });
            return cache.get(key, function () { return _this.fetchData(url, method, payload, headers); });
        }
        else {
            return this.fetchData(url, method, payload, headers);
        }
    };
    return RequestsUtil;
}());
function requests(client, options) {
    // const requestTimeout = options && options.requestTimeout || client && client.config && client.config.requestTimeout // TODO....problem
    return new RequestsUtil({ debug: client && client.config && client.config.debug }); // {timeout: requestTimeout})
}

/**
 * @Topic Benchmarks
 */
var BenchmarksClient = /** @class */ (function () {
    function BenchmarksClient(client) {
        this.client = client;
    }
    /**
     *
     */
    BenchmarksClient.prototype.fetch = function (group, conditions, bounds) {
        return __awaiter(this, void 0, void 0, function () {
            var boundsData, data, url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        boundsData = {
                            'west': bounds.southWest.lng,
                            'south': bounds.southWest.lat,
                            'east': bounds.northEast.lng,
                            'north': bounds.northEast.lat
                        };
                        data = {
                            bounds: boundsData,
                            benchmarks: conditions.map(function (item) { return ({
                                source: item.source,
                                minEnd: item.minEnd,
                                minStart: item.minStart,
                                factor: item.factor,
                            }); })
                        };
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.tilesUrl)
                            .part('benchmarks/scores_cumulative/')
                            .version()
                            .part('/' + encodeURIComponent('' + group))
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this.client).fetch(url, 'POST', data)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     *
     */
    BenchmarksClient.prototype.metadata = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.tilesUrl)
                            .part('benchmarks/meta/')
                            .version()
                            .part('/' + encodeURIComponent('' + key))
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this.client).fetch(url)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return BenchmarksClient;
}());

(function (UrlUtil) {
    var TargomoUrl = /** @class */ (function () {
        function TargomoUrl(client) {
            this.client = client;
            this.url = '';
            this.firstParamPlaced = false;
        }
        TargomoUrl.prototype.host = function (value) {
            if (this.url.length === 0 && value[value.length - 1] !== '/') {
                value += '/';
            }
            return this.part(value);
        };
        TargomoUrl.prototype.part = function (value) {
            this.url += value;
            return this;
        };
        TargomoUrl.prototype.version = function () {
            if (this.client.config.version !== null && this.client.config.version !== undefined) {
                this.part('v' + this.client.config.version);
            }
            else if (this.url[this.url.length - 1] === '/') {
                this.url = this.url.substr(0, this.url.length - 1);
            }
            return this;
        };
        TargomoUrl.prototype.params = function (value) {
            var _this = this;
            var keys = Object.keys(value);
            keys.forEach(function (key) {
                if (value[key] instanceof Array) {
                    value[key].forEach(function (v) {
                        _this.param(key, v);
                    });
                }
                else {
                    _this.param(key, value[key]);
                }
            });
            return this;
        };
        TargomoUrl.prototype.param = function (name, value) {
            if (!this.firstParamPlaced) {
                this.firstParamPlaced = true;
                this.url += '?' + name + '=' + value;
            }
            else {
                this.url += '&' + name + '=' + value;
            }
        };
        TargomoUrl.prototype.key = function () {
            return this.params({ key: this.client.serviceKey });
        };
        TargomoUrl.prototype.toString = function () {
            return this.url;
        };
        return TargomoUrl;
    }());
    UrlUtil.TargomoUrl = TargomoUrl;
})(exports.UrlUtil || (exports.UrlUtil = {}));

var GeocodeEsriClient = /** @class */ (function () {
    function GeocodeEsriClient() {
    }
    /**
     *  Geocoding with esri service
     * @param query
     * @param center
     * @param language
     * @param country
     * @param magicKey
     */
    GeocodeEsriClient.prototype.geocode = function (query, center, language, country, magicKey) {
        return __awaiter(this, void 0, void 0, function () {
            var params, url, jsonResult, results;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            singleLine: query,
                            f: 'json',
                            countryCode: country,
                            maxLocations: 5,
                        };
                        if (center) {
                            params.location = center.lng + "," + center.lat;
                        }
                        if (magicKey) {
                            params.magicKey = magicKey;
                        }
                        url = new exports.UrlUtil.TargomoUrl()
                            .part('https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates')
                            .params(params)
                            .toString();
                        return [4 /*yield*/, requests().fetch(url)];
                    case 1:
                        jsonResult = _a.sent();
                        results = jsonResult.candidates.map(function (result) {
                            var location = {
                                lat: result.location.y,
                                lng: result.location.x,
                                description: result.address
                            };
                            return location;
                        });
                        return [2 /*return*/, results];
                }
            });
        });
    };
    /**
     *
     * @param query
     * @param center
     * @param language
     * @param country
     * @param suggestionsCount
     */
    GeocodeEsriClient.prototype.suggest = function (query, center, language, country, suggestionsCount) {
        if (suggestionsCount === void 0) { suggestionsCount = 5; }
        return __awaiter(this, void 0, void 0, function () {
            var params, url, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            // token: '',
                            // forStorage: false,
                            // singleLine: query,
                            text: query,
                            f: 'json',
                            countryCode: country,
                            // maxLocations: 5,
                            maxSuggestions: suggestionsCount
                        };
                        if (center) {
                            params.location = center.lng + "," + center.lat;
                        }
                        url = new exports.UrlUtil.TargomoUrl()
                            .part('https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/suggest')
                            .params(params)
                            .toString();
                        return [4 /*yield*/, requests().fetch(url)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response.suggestions];
                }
            });
        });
    };
    /**
     * Makes a reverse geocode request to the esri geocoder
     *
     * @param location
     * @param language
     */
    GeocodeEsriClient.prototype.reverseGeocode = function (location, language) {
        return __awaiter(this, void 0, void 0, function () {
            var params, url, response, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            // token: '',
                            // forStorage: false,
                            f: 'json',
                        };
                        params.location = location.lng + "," + location.lat;
                        url = new exports.UrlUtil.TargomoUrl()
                            .part('https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode')
                            .params(params)
                            .toString();
                        return [4 /*yield*/, requests().fetch(url)];
                    case 1:
                        response = _a.sent();
                        if (response && response.address) {
                            result = {
                                address: response.address.Match_addr,
                                city: response.address.City,
                                countryCode: response.address.CountryCode,
                                location: response.address.Loc_name,
                                region: response.address.Region,
                                subregion: response.address.Subregion,
                                zip: response.address.Postal
                            };
                            return [2 /*return*/, result];
                        }
                        else {
                            return [2 /*return*/, {}];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    return GeocodeEsriClient;
}());

var GeocodePhotonClient = /** @class */ (function () {
    function GeocodePhotonClient(client) {
        this.client = client;
    }
    GeocodePhotonClient.prototype.geocode = function (query, center, language) {
        return __awaiter(this, void 0, void 0, function () {
            var url, response, results;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl()
                            .host(this.client.config.photonGeocoderUrl)
                            .part('api')
                            .params({
                            q: encodeURIComponent(query),
                            limit: 5
                        })
                            .toString();
                        if (center) {
                            url += '&lat=' + center.lat + '&lon=' + center.lng;
                        }
                        if (language) {
                            url += '&lang=' + encodeURIComponent(language);
                        }
                        return [4 /*yield*/, requests().fetch(url)];
                    case 1:
                        response = _a.sent();
                        response.features.forEach(function (feature, index, array) {
                            if (feature.properties.osm_key == 'boundary') {
                                array.splice(index, 1);
                            }
                        });
                        results = response.features.map(function (result) {
                            result.value = result.properties.osm_id;
                            result.description = _this.buildPlaceDescription(result.properties);
                            return result;
                        });
                        return [2 /*return*/, results];
                }
            });
        });
    };
    GeocodePhotonClient.prototype.buildPlaceDescription = function (properties) {
        var join = function (texts, middle) {
            if (middle === void 0) { middle = ' '; }
            return texts.filter(function (text) { return !!text; }).join(middle).trim();
        };
        var parts = function (fields, middle) { return join(fields.map(function (key) { return properties[key]; }), middle); };
        var address1 = parts(['street', 'housenumber'], ' ');
        var address2 = join([parts(['postcode', 'city'], ' '), properties.country], ', ');
        var result = {
            title: '',
            meta1: '',
            meta2: '',
            full: '' // join([parts(['name', 'street', 'housenumber'], ' '), parts(['postcode', 'city'], ', ')])
        };
        if (properties.name !== undefined) {
            result.title = properties.name;
            result.meta1 = address1;
            result.meta2 = address2;
        }
        else {
            result.title = address1;
            result.meta1 = address2;
        }
        if (properties.name !== address1) {
            result.full = result.title;
        }
        if (result.meta1 && properties.name !== address1) {
            result.full += ', ' + result.meta1;
        }
        if (result.meta1 && properties.name === address1) {
            result.full += result.meta1;
        }
        result.full = join([result.full, result.meta2], ', ');
        return result;
    };
    return GeocodePhotonClient;
}());

var UseCacheRequestOptions = /** @class */ (function () {
    function UseCacheRequestOptions() {
    }
    return UseCacheRequestOptions;
}());
var BaseRequestOptions = /** @class */ (function () {
    function BaseRequestOptions() {
        /**
         * @General Determines the dimension of the edges' weight, i.e.
         * @Format time (distance in seconds) or distance (distance in meters)
         * @Default `'time'`
         */
        this.edgeWeight = 'time';
    }
    return BaseRequestOptions;
}());
var TravelRequestOptions = /** @class */ (function (_super) {
    __extends(TravelRequestOptions, _super);
    function TravelRequestOptions() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Time-frame duration in seconds
         */
        _this.transitFrameDuration = undefined;
        /**
         * Date of the transit request in the format `YYYYMMDD`
         */
        _this.transitFrameDate = 20170801;
        /**
         * Start time of the transit request in seconds from midnight
         */
        _this.transitFrameTime = 39600;
        /**
         * Maximum transfer segements in a route
         */
        _this.transitMaxTransfers = -1;
        /**
         * Route types to avoid. https://developers.google.com/transit/gtfs/reference/#routestxt
         */
        _this.transitAvoidTransitRouteTypes = [];
        _this.walkSpeed = {};
        _this.bikeSpeed = {};
        return _this;
    }
    return TravelRequestOptions;
}(BaseRequestOptions));

/**
 * An object the contains a configuration set for making requests to the r360 services backend
 */
var TravelRequestPayload = /** @class */ (function (_super) {
    __extends(TravelRequestPayload, _super);
    function TravelRequestPayload(options) {
        var _this = _super.call(this) || this;
        Object.assign(_this, options);
        if (options.transitFrameDateTime != null) {
            var date = void 0;
            if (options.transitFrameDateTime instanceof Date) {
                date = options.transitFrameDateTime;
            }
            else {
                date = new Date(options.transitFrameDateTime);
            }
            var transitFrameDate = date ? ((date.getFullYear() * 10000) + (date.getMonth() + 1) * 100 + date.getDate()) : undefined;
            var transitFrameTime = date ? ((date.getHours() * 3600) + (date.getMinutes() * 60)) : undefined;
            _this.transitFrameDate = transitFrameDate || _this.transitFrameDate;
            _this.transitFrameTime = transitFrameTime || _this.transitFrameTime;
        }
        return _this;
    }
    TravelRequestPayload.prototype.buildTargetsCfg = function (targets) {
        return targets.map(function (original) {
            return {
                lat: original.lat,
                lng: original.lng,
                id: original.id,
            };
        });
    };
    TravelRequestPayload.prototype.buildSourcesCfg = function (sources) {
        var _this = this;
        return sources.map(function (original) {
            var source = {
                lat: original.lat,
                lng: original.lng,
                id: original.id,
                tm: original.tm
            };
            if (!source.tm) {
                switch (_this.travelType) {
                    case 'car':
                        source.tm = {
                            car: _this.rushHour ? {
                                rushHour: _this.rushHour
                            } : {}
                        };
                        break;
                    case 'walk':
                        source.tm = {
                            walk: _this.walkSpeed
                        };
                        break;
                    case 'bike':
                        source.tm = {
                            bike: _this.bikeSpeed
                        };
                        break;
                    case 'transit':
                        source.tm = {
                            transit: {
                                frame: {
                                    date: _this.transitFrameDate,
                                    time: _this.transitFrameTime,
                                    duration: _this.transitFrameDuration
                                },
                                maxTransfers: _this.transitMaxTransfers
                            }
                        };
                }
            }
            return source;
        });
    };
    return TravelRequestPayload;
}(TravelRequestOptions));

var MultigraphRequestPayload = /** @class */ (function (_super) {
    __extends(MultigraphRequestPayload, _super);
    function MultigraphRequestPayload(sources, options, targets) {
        var _this = _super.call(this, options) || this;
        _this.sources = _this.buildSourcesCfg(sources);
        if (targets) {
            _this.targets = _this.buildTargetsCfg(targets);
        }
        _this.multigraph = options.multigraph;
        return _this;
    }
    return MultigraphRequestPayload;
}(TravelRequestPayload));

/**
 * @Topic Multigraph
 */
var MultigraphClient = /** @class */ (function () {
    function MultigraphClient(client) {
        this.client = client;
    }
    /**
  
     */
    MultigraphClient.prototype.fetch = function (sources, options, targets) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/multigraph')
                            .key()
                            .toString();
                        cfg = new MultigraphRequestPayload(sources, options, targets);
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', cfg)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    MultigraphClient.prototype.fetchOverview = function (sources, options, targets) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/multigraph/overview')
                            .key()
                            .toString();
                        cfg = new MultigraphRequestPayload(sources, options, targets);
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', cfg)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    MultigraphClient.prototype.getTiledMultigraphUrl = function (sources, options, format, targets) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg, objectCache;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/objectcache/add')
                            .key()
                            .toString();
                        cfg = new MultigraphRequestPayload(sources, options, targets);
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', cfg)];
                    case 1:
                        objectCache = _a.sent();
                        return [2 /*return*/, new exports.UrlUtil.TargomoUrl(this.client)
                                .part(this.client.serviceUrl)
                                .version()
                                .part('/multigraph/{z}/{x}/{y}.' + format)
                                .key()
                                .params({
                                cfgUuid: objectCache.uuid
                            })
                                .toString()];
                }
            });
        });
    };
    return MultigraphClient;
}());

var OptimizationRequestPayload = /** @class */ (function () {
    function OptimizationRequestPayload(serviceUrl, serviceKey, sources, options) {
        this.description = options.description || '';
        this.serviceUrl = serviceUrl;
        this.serviceKey = serviceKey;
        this.email = options.email || 'developers@targomo.com';
        this.sendMail = false;
        this.callbackUrl = options.callbackUrl || 'https://localhost/'; // TODO: was this donig anything?
        this.pointsPerSolution = options.pointsPerSolution;
        this.maxSolutions = options.maxSolutions || 1;
        this.travelType = options.travelType;
        this.edgeWeight = options.edgeWeight;
        this.maxEdgeWeight = options.maxEdgeWeight;
        this.statisticGroupId = options.statisticGroup;
        if (options.statistic instanceof Number || typeof options.statistic === 'number') {
            this.statisticId = +options.statistic;
        }
        else {
            this.statisticId = options.statistic.id;
        }
        var sourcesObject = {};
        sources.forEach(function (source) {
            sourcesObject[source.id] = {
                id: source.id,
                x: source.lng,
                y: source.lat
            };
        });
        this.sources.push(sourcesObject);
    }
    return OptimizationRequestPayload;
}());

/**
 * Results of an optimization simulation run
 */
var OptimizationResult = /** @class */ (function () {
    function OptimizationResult(raw) {
        this.raw = raw;
        this.id = raw.id;
        this.maxPossibleValue = raw.maxPossibleValue;
        this.solutions = raw.simulationResults.map(function (simulationResult) {
            var sources = {};
            simulationResult.sourcePoints.forEach(function (point) {
                sources[point.id] = point.optimal;
            });
            return {
                id: simulationResult.id,
                startTime: simulationResult.startTime,
                endTime: simulationResult.endTime,
                maxValue: simulationResult.maxValue,
                numberOfDesiredPoints: simulationResult.numberOfDesiredPoints,
                sources: sources
            };
        });
    }
    return OptimizationResult;
}());

/**
 * @Topic Optimizations
 */
var OptimizationsClient = /** @class */ (function () {
    function OptimizationsClient(client) {
        this.client = client;
    }
    /**
     * Initiates a an optimimization simulation. Given a list of locations and simulation parameters it tries to
     * derive a subset of these locations that are optimal.
     *
     * @param sources
     * @param options
     */
    // NOTE: we can't have unit tests for this....
    OptimizationsClient.prototype.create = function (sources, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!sources.length) {
                            return [2 /*return*/, null];
                        }
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('simulation/start/')
                            .key()
                            .params({
                            serviceUrl: encodeURIComponent(this.client.serviceUrl)
                        })
                            .toString();
                        cfg = new OptimizationRequestPayload(this.client.serviceUrl, this.client.serviceKey, sources, options);
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', cfg)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result && +result.id];
                }
            });
        });
    };
    /**
     * Checks if the given optimization simulation have completed and have results ready for retrieval
     *
     * @param optimizationId
     */
    OptimizationsClient.prototype.ready = function (optimizationId) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                if (!(optimizationId instanceof Array)) {
                    optimizationId = [optimizationId];
                }
                url = new exports.UrlUtil.TargomoUrl(this.client)
                    .host(this.client.config.statisticsUrl)
                    .part('simulation/ready/')
                    .key()
                    .params({
                    serviceUrl: encodeURIComponent(this.client.serviceUrl),
                    simulationId: optimizationId
                })
                    .toString();
                return [2 /*return*/, requests(this.client).fetch(url)];
            });
        });
    };
    /**
     * Retrieve the results of an optimization simulation
     *
     * @param optimizationId
     */
    OptimizationsClient.prototype.fetch = function (optimizationId) {
        return __awaiter(this, void 0, void 0, function () {
            var url, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('simulation/' + optimizationId + '/')
                            .key()
                            .params({
                            serviceUrl: encodeURIComponent(this.client.serviceUrl)
                        })
                            .toString();
                        _a = OptimizationResult.bind;
                        return [4 /*yield*/, requests(this.client).fetch(url)];
                    case 1: return [2 /*return*/, new (_a.apply(OptimizationResult, [void 0, _b.sent()]))()];
                }
            });
        });
    };
    return OptimizationsClient;
}());

var POIRequestPayload = /** @class */ (function (_super) {
    __extends(POIRequestPayload, _super);
    function POIRequestPayload(client, source, options) {
        var _this = _super.call(this, options) || this;
        _this.osmTypes = [];
        _this.sources = _this.buildSourcesCfg([source]);
        _this.osmTypes = options.osmTypes;
        _this.format = options.format;
        _this.serviceKey = client.serviceKey;
        _this.serviceUrl = client.serviceUrl;
        return _this;
    }
    return POIRequestPayload;
}(TravelRequestPayload));

/**
 * An object representing a point (poi/marker) which is returned from overpass queries in this module
 */
// TODO: move elsewhere...or maybe not used in public library...things in here are too specific
var OSMLatLng = /** @class */ (function () {
    function OSMLatLng(id, lng, lat, properties) {
        this.id = id;
        this.lng = lng;
        this.lat = lat;
        this.properties = properties;
        // TODO: think...this is convenient to how we have things in mapbox widget...but maybe should not be done in a public api
        if (this.properties) {
            this.properties['marker-size'] = 1;
        }
    }
    OSMLatLng.prototype.toString = function () {
        return this.properties ? this.properties['name'] : '';
    };
    OSMLatLng.prototype.copy = function () {
        var result = new OSMLatLng(this.id, this.lat, this.lng, __assign({}, this.properties));
        for (var key in this) {
            if (key != 'properties') {
                result[key] = this[key];
            }
        }
        return result;
    };
    return OSMLatLng;
}());
function parseOSMLocation(item) {
    var lat = item.lat;
    var lng = item.lon;
    if (lat === undefined && item.center) {
        lat = item.center.lat;
        lng = item.center.lon;
    }
    return new OSMLatLng(item.id, lng, lat, item.tags);
}
/**
 *
 */
// TODO: better method names
/**
 * @Topic Points of Interest
 */
var PointsOfInterestClient = /** @class */ (function () {
    // Idea is this will be instantiated internally in Targomoclient,. and will receive instance of parent in its constructor
    function PointsOfInterestClient(client) {
        this.client = client;
    }
    // TODO move queryRaw and query to common lib
    /**
     * Query the overpass service with a raw overpass query string (in other words you supply the exact query)
     *
     * @param query
     */
    PointsOfInterestClient.prototype.queryRaw = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, requests(this.client).fetch(this.client.config.overpassUrl + '/api/interpreter', 'POST-RAW', query)];
                    case 1:
                        result = _a.sent();
                        result = JSON.parse(result);
                        return [2 /*return*/, result.elements.filter(function (item) { return !!item.tags; }).map(function (item) { return parseOSMLocation(item); })];
                }
            });
        });
    };
    /**
     * Query the overpass servive for given categories (way[type]=tag and node[way]=tag) within a given bounding box
     *
     * @param categories
     * @param boundingBox
     */
    PointsOfInterestClient.prototype.query = function (categories, boundingBox) {
        function asQueryElement(query) {
            if (query.tag === '*' || query.tag == null) {
                return "\"" + query.type + "\"";
            }
            else if (query.type && query.tag) {
                return "\"" + query.type + "\"=\"" + query.tag + "\"";
            }
            else {
                throw new Error('invalid query' + JSON.stringify(query));
            }
        }
        var params = [];
        categories.forEach(function (category) {
            boundingBox.forEach(function (box) {
                params.push("\n      way[" + asQueryElement(category) + "]\n        (" + box.southWest.lat + "," + box.southWest.lng + "," + box.northEast.lat + "," + box.northEast.lng + ");\n      node[" + asQueryElement(category) + "]\n        (" + box.southWest.lat + "," + box.southWest.lng + "," + box.northEast.lat + "," + box.northEast.lng + ");\n        ");
            });
        });
        var data = "\n      [out:json];\n      (\n      " + params.join('') + "\n      );\n      out center;\n    ";
        return this.queryRaw(data);
    };
    /**
     * Make an overpass query to a given url (full url including the query parameters)
     *
     * The results will be parsed and returned as a list of OSMLatLng objects
     */
    // TODO: ...this was used in GH...think what shape of this make best sense for a public library
    PointsOfInterestClient.prototype.queryGetCustom = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, requests(this.client).fetch(url)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.elements.map(function (item) { return parseOSMLocation(item); })];
                }
            });
        });
    };
    /**
     * Makes a request to the r360 poi service.
     * Returns a list of OSMLatLng locations of the categories specified by `osmTypes` that are reachable within the given travel options
     */
    PointsOfInterestClient.prototype.reachable = function (source, /// LatLng
    options) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.client.config.poiUrl + "/reachability";
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', new POIRequestPayload(this.client, source, options))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return PointsOfInterestClient;
}());

/**
 * A map coordinate
 */
var LatLng = /** @class */ (function () {
    function LatLng() {
    }
    return LatLng;
}());
/**
 * A map bounding box
 */
var BoundingBox = /** @class */ (function () {
    function BoundingBox() {
    }
    return BoundingBox;
}());

(function (StatisticsGroups) {
    StatisticsGroups[StatisticsGroups["GERMANY_ZENSUS_100M_STATISTICS"] = 9] = "GERMANY_ZENSUS_100M_STATISTICS";
    StatisticsGroups[StatisticsGroups["GERMANY_ZENSUS_200M_STATISTICS"] = 2] = "GERMANY_ZENSUS_200M_STATISTICS";
    StatisticsGroups[StatisticsGroups["GERMANY_ZENSUS_500M_STATISTICS"] = 11] = "GERMANY_ZENSUS_500M_STATISTICS";
    StatisticsGroups[StatisticsGroups["GERMANY_ZENSUS_1000M_STATISTICS"] = 3] = "GERMANY_ZENSUS_1000M_STATISTICS";
    StatisticsGroups[StatisticsGroups["GERMANY_ZENSUS_2000M_STATISTICS"] = 10] = "GERMANY_ZENSUS_2000M_STATISTICS";
    StatisticsGroups[StatisticsGroups["NORWAY_STATISTICS"] = 4] = "NORWAY_STATISTICS";
    StatisticsGroups[StatisticsGroups["CENSUS_BRANDENBURG_POPULATION"] = 12] = "CENSUS_BRANDENBURG_POPULATION";
    StatisticsGroups[StatisticsGroups["CANADA_BLOCK_STATISTICS"] = 8] = "CANADA_BLOCK_STATISTICS";
    StatisticsGroups[StatisticsGroups["CANADA_AREA_STATISTICS"] = 5] = "CANADA_AREA_STATISTICS";
    StatisticsGroups[StatisticsGroups["BERLIN_STATISTICS"] = 6] = "BERLIN_STATISTICS";
})(exports.StatisticsGroups || (exports.StatisticsGroups = {}));
var TravelSpeedValues = /** @class */ (function () {
    function TravelSpeedValues() {
    }
    return TravelSpeedValues;
}());
/**
 *A result object for a specific statistic
 */
var StatisticValues = /** @class */ (function () {
    function StatisticValues(values) {
        this.values = values;
        this.total = 0;
        for (var key in this.values) {
            this.total += this.values[key];
        }
    }
    return StatisticValues;
}());

(function (SRID) {
    SRID[SRID["SRID_3857"] = 3857] = "SRID_3857";
    SRID[SRID["SRID_4326"] = 4326] = "SRID_4326";
})(exports.SRID || (exports.SRID = {}));

(function (MultigraphRequestAggregation) {
    MultigraphRequestAggregation["NONE"] = "none";
    MultigraphRequestAggregation["SUM"] = "sum";
    MultigraphRequestAggregation["MAX"] = "max";
    MultigraphRequestAggregation["MIN"] = "min";
    MultigraphRequestAggregation["MEAN"] = "mean";
    MultigraphRequestAggregation["MEDIAN"] = "median";
    MultigraphRequestAggregation["NEAREST"] = "nearest";
    MultigraphRequestAggregation["UNION"] = "routing_union";
    MultigraphRequestAggregation["MATH"] = "math";
    MultigraphRequestAggregation["GRAVITATION"] = "gravitation_huff";
})(exports.MultigraphRequestAggregation || (exports.MultigraphRequestAggregation = {}));

(function (MultigraphRequestLayer) {
    MultigraphRequestLayer["IDENTITY"] = "identity";
    MultigraphRequestLayer["TILE"] = "tile";
    MultigraphRequestLayer["HEXAGON"] = "hexagon";
    MultigraphRequestLayer["CUSTOM_GEOMETRIES"] = "custom_geometries";
})(exports.MultigraphRequestLayer || (exports.MultigraphRequestLayer = {}));

var sphericalMercator = new /** @class */ (function () {
    function class_1() {
        this.R = 6378137; // constant for Earth's radius
    }
    class_1.prototype.project = function (latlng) {
        var d = Math.PI / 180;
        var max = 1 - 1E-15;
        var sin = Math.max(Math.min(Math.sin(latlng.lat * d), max), -max);
        return {
            x: this.R * latlng.lng * d,
            y: this.R * Math.log((1 + sin) / (1 - sin)) / 2
        };
    };
    class_1.prototype.unproject = function (point) {
        var d = 180 / Math.PI;
        return {
            lat: (2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
            lng: point.x * d / this.R
        };
    };
    return class_1;
}());

/**
 * Some reusable functions that deal with lat/lng gemoetry calculations
 */
var EARTH_RADIUS_KM = 6371.01;
var RADIANS = Math.PI / 180;
// const DEGREES = 180 / Math.PI
/**
 * Return whether a lat/lng point is contained within a bounding box
 */
function contains(bBox, point) {
    return point.lat >= bBox.southWest.lat && point.lat <= bBox.northEast.lat &&
        point.lng >= bBox.southWest.lng && point.lng <= bBox.northEast.lng;
}
/**
 * Returns the distance in kilometers between two lat/lng points
 */
function calculateDistance(from, to) {
    var fromLat = RADIANS * from.lat;
    var fromLng = RADIANS * from.lng;
    var toLat = RADIANS * to.lat;
    var toLng = RADIANS * to.lng;
    return Math.acos(Math.sin(fromLat) * Math.sin(toLat) +
        Math.cos(fromLat) * Math.cos(toLat) *
            Math.cos(fromLng - toLng)) * EARTH_RADIUS_KM;
}
/**
 *
 * Creates a bounding box around a point
 *
 * @param from
 * @param distance distance in km
 */
function boundingBox(from, distance) {
    distance = distance * 1000;
    var lat = from.lat;
    var lng = from.lng;
    var latRadians = lat * RADIANS;
    var DELTA_LAT_KM = 110.574235;
    var DEGREES_LONG_KM = 110.572833 * Math.cos(latRadians);
    var deltaLat = distance / 1000.0 / DELTA_LAT_KM;
    var deltaLong = distance / 1000.0 / DEGREES_LONG_KM;
    var topLat = lat + deltaLat;
    var bottomLat = lat - deltaLat;
    var leftLng = lng - deltaLong;
    var rightLng = lng + deltaLong;
    return {
        northEast: {
            lat: topLat, lng: rightLng
        },
        southWest: {
            lat: bottomLat, lng: leftLng
        }
    };
}
/**
 * Give a list of locations return only those that are in proximity (predefined based on given TravelOptions)
 * to any location in the  `from` list
 * The use of this is to reduce the inputs to reachability and other requests (pre-filtering out remote targets) for perfromance reasons
 *
 * @param locations  The list to be filtered
 * @param from  results will be in proximity to these
 * @param options traveloptions (affect the distance around the `from` list that will be considered)
 */
function locationsWithinTravelOptions(locations, from, options) {
    var maxEdgeWeight = options.maxEdgeWeight;
    var speed;
    switch (options.travelType) {
        case 'walk':
            speed = 10;
            break;
        case 'bike':
            speed = 25;
            break;
        case 'transit':
            speed = 150;
            break;
        default:
            speed = 120;
            break;
    }
    var distanceKm = (options.edgeWeight === 'distance')
        ? Math.round(maxEdgeWeight / 1000)
        : (speed * maxEdgeWeight / 3600);
    return locationsWithinDistance(locations, from, distanceKm);
}
function getSpeed(options) {
    switch (options.travelType) {
        case 'walk': return 10;
        case 'bike': return 25;
        case 'transit': return 150;
        default: return 120;
    }
}
/**
 * Creates a bounding box around a location, with parametres about the distance calculated (based on predefined internal logic)
 * from a give TravelOptions
 *
 * @param from
 * @param options
 */
function boundingBoxWithinTravelOptions(from, options) {
    var maxEdgeWeight = options.maxEdgeWeight;
    var speed = getSpeed(options);
    var distanceKm = (options.edgeWeight === 'distance')
        ? Math.round(maxEdgeWeight / 1000)
        : (speed * maxEdgeWeight / 3600);
    return boundingBox(from, distanceKm);
}
/**
 * Create a bounding box from an Array of latlng locations
 *
 * @param locations location array to get the bbox from
 */
function boundingBoxFromLocationArray(locations) {
    var bbox = locations.reduce(function (acc, val) {
        acc.northEast.lat = (val.lat > acc.northEast.lat) ? val.lat : acc.northEast.lat;
        acc.northEast.lng = (val.lng > acc.northEast.lng) ? val.lng : acc.northEast.lng;
        acc.southWest.lat = (val.lat < acc.southWest.lat) ? val.lat : acc.southWest.lat;
        acc.southWest.lng = (val.lng < acc.southWest.lng) ? val.lng : acc.southWest.lng;
        return acc;
    }, {
        northEast: {
            lat: locations[0].lat, lng: locations[0].lng
        },
        southWest: {
            lat: locations[0].lat, lng: locations[0].lng
        }
    });
    return bbox;
}
/**
 * Creates a bounding box around a list location, with parameters about the distance calculated * (based on predefined internal logic)
 * from a give TravelOptions.
 * The bounding box returned will be the maximum bounding box that will include all bounding boxes generated for each location
 *
 * @param sources
 * @param options
 */
function boundingBoxListWithinTravelOptions(sources, options) {
    var maxEdgeWeight = options.maxEdgeWeight;
    var speed = getSpeed(options);
    var distanceKm = (options.edgeWeight === 'distance')
        ? Math.round(maxEdgeWeight / 1000)
        : (speed * maxEdgeWeight / 3600);
    var boundingBoxResult = {
        northEast: {
            lat: -Infinity, lng: -Infinity
        },
        southWest: {
            lat: Infinity, lng: Infinity
        }
    };
    sources.forEach(function (source) {
        var box = boundingBox(source, distanceKm);
        boundingBoxResult.northEast.lat = Math.max(boundingBoxResult.northEast.lat, box.northEast.lat);
        boundingBoxResult.northEast.lng = Math.max(boundingBoxResult.northEast.lng, box.northEast.lng);
        boundingBoxResult.southWest.lat = Math.min(boundingBoxResult.southWest.lat, box.southWest.lat);
        boundingBoxResult.southWest.lng = Math.min(boundingBoxResult.southWest.lng, box.southWest.lng);
    });
    return boundingBoxResult;
}
/**
 * Given a list of locations return only those that are within `distanceKm` to any location in the
 * `from` list, and which are not included in the `from` locations
 *
 * @param locations
 * @param from
 * @param distanceKm
 */
function locationsWithinDistance(locations, from, distanceKm) {
    if (from instanceof Array) {
        return locationsWithinDistanceInclusive(locations, from, distanceKm).filter(function (location) { return !from.some(function (item) { return item == location; }); });
    }
    else {
        return locationsWithinDistanceInclusive(locations, from, distanceKm).filter(function (location) { return from != location; });
    }
}
/**
 * Given a list of locations return only those that are within `distanceKm` to any location in the  `from` list
 *
 * @param locations
 * @param from
 * @param distanceKm
 */
function locationsWithinDistanceInclusive(locations, from, distanceKm) {
    if (from instanceof Array) {
        return locations.filter(function (location) { return from.some(function (point) { return calculateDistance(location, point) <= distanceKm; }); });
    }
    else {
        return locations.filter(function (location) { return calculateDistance(location, from) <= distanceKm; });
    }
}
/**
 *
 * @param point
 * @param elevation
 */
function webMercatorToLatLng(point, elevation) {
    var latlng = sphericalMercator.unproject(point);
    if (elevation != undefined) {
        // x,y,z given so we have elevation data
        return { lat: latlng.lat, lng: latlng.lng, elevation: elevation };
    }
    else {
        // no elevation given, just unproject coordinates to lat/lng
        return latlng;
    }
}
/**
 *
 * @param latlng
 */
function latLngToWebMercator(latlng) {
    var point = sphericalMercator.project(latlng);
    // point.x *= 6378137
    // point.y *= 6378137
    return point;
}

// Barrel for geometry module. See https://angular.io/guide/glossary#barrel



var geometryModule = Object.freeze({
	contains: contains,
	calculateDistance: calculateDistance,
	boundingBox: boundingBox,
	locationsWithinTravelOptions: locationsWithinTravelOptions,
	boundingBoxWithinTravelOptions: boundingBoxWithinTravelOptions,
	boundingBoxFromLocationArray: boundingBoxFromLocationArray,
	boundingBoxListWithinTravelOptions: boundingBoxListWithinTravelOptions,
	locationsWithinDistance: locationsWithinDistance,
	locationsWithinDistanceInclusive: locationsWithinDistanceInclusive,
	webMercatorToLatLng: webMercatorToLatLng,
	latLngToWebMercator: latLngToWebMercator
});

/**
 * Represents a continuous segment of a route using one travel mode
 */
var RouteSegment = /** @class */ (function () {
    function RouteSegment(client, segment) {
        var _this = this;
        this.points = [];
        this.type = segment.type;
        this.travelTime = segment.travelTime;
        /*
        * TODO don't call it length! in route length refers to the array length.
        * Call it distance instead
        */
        this.distance = segment.length / 1000;
        this.warning = segment.warning;
        this.elevationGain = segment.elevationGain;
        this.transitSegment = false;
        this.startName = segment.startname;
        this.endName = segment.endname;
        // build the geometry
        segment.points.forEach(function (point) {
            _this.points.push(webMercatorToLatLng({ x: point[1], y: point[0] }, point[2]));
        });
        // in case we have a transit route, we set information which are only available
        // for transit segments like depature station and route short sign
        if (segment.isTransit) {
            this.transitSegment = true;
            this.routeType = segment.routeType;
            this.routeShortName = segment.routeShortName;
            this.routeLongName = segment.routeLongName;
            this.startName = segment.startname;
            this.endName = segment.endname;
            this.departureTime = segment.departureTime;
            this.arrivalTime = segment.arrivalTime;
            this.tripHeadSign = segment.tripHeadSign;
        }
    }
    return RouteSegment;
}());

/**
 *
 */
var Route = /** @class */ (function () {
    function Route(client, travelTime, segments, meta) {
        var _this = this;
        this.travelTime = travelTime;
        this.routeSegments = [];
        this.targetHeight = undefined;
        this.sourceHeight = undefined;
        this.sourceId = undefined;
        this.targetId = undefined;
        this.length = undefined;
        var transfers = 0;
        var points = [];
        // the server delivers the route from target to source
        segments.reverse().forEach(function (segment) {
            var routeSegment = new RouteSegment(client, segment);
            _this.routeSegments.push(routeSegment);
            if (routeSegment.type === 'TRANSFER') {
                transfers++;
            }
            points = points.concat(routeSegment.points.reverse());
        });
        this.points = points;
        this.transfers = transfers;
        if (typeof meta !== 'undefined') {
            this.sourceId = meta.source_id;
            this.targetId = meta.target_id;
            this.length = meta.length;
        }
        var elevationDifferences = this.calculateElevationDifferences(this.points);
        this.targetHeight = elevationDifferences.targetHeight;
        this.sourceHeight = elevationDifferences.sourceHeight;
        this.uphillMeter = elevationDifferences.uphillMeter;
        this.downhillMeter = elevationDifferences.downhillMeter;
        this.totalElevationDifference = Math.abs(this.sourceHeight - this.targetHeight);
        this.departureTime = this.calculateDepartureTime();
        this.arrivalTime = this.calculateArrivalTime();
        this.distance = this.calculateDistance();
        this.elevationGain = this.calculateElevationGain();
    }
    Route.prototype.calculateDistance = function () {
        var distance = 0;
        for (var i = 0; i < this.routeSegments.length; i++) {
            distance += this.routeSegments[i].distance;
        }
        return distance;
    };
    Route.prototype.calculateElevationGain = function () {
        var distance = undefined;
        for (var i = 0; i < this.routeSegments.length; i++) {
            if (isFinite(this.routeSegments[i].elevationGain)) {
                distance = (distance || 0) + this.routeSegments[i].elevationGain;
            }
        }
        return distance;
    };
    // TODO: check again what this does
    Route.prototype.calculateElevationDifferences = function (points) {
        var previousHeight = undefined;
        var targetHeight = undefined;
        var sourceHeight = undefined;
        var uphillMeter = 0;
        var downhillMeter = 0;
        for (var i = this.points.length - 1; i >= 0; i--) {
            if (i == 0) {
                targetHeight = this.points[i].elevation;
            }
            if (i == this.points.length - 1) {
                sourceHeight = this.points[i].elevation;
            }
            if (typeof previousHeight != 'undefined') {
                // we go up
                if (previousHeight > this.points[i].elevation) {
                    uphillMeter += (previousHeight - this.points[i].elevation);
                }
                else if (previousHeight < this.points[i].elevation) {
                    // and down
                    downhillMeter += (this.points[i].elevation - previousHeight);
                }
            }
            previousHeight = this.points[i].elevation;
        }
        return { targetHeight: targetHeight, sourceHeight: sourceHeight, uphillMeter: uphillMeter, downhillMeter: downhillMeter };
    }; // check why this was like this in original
    Route.prototype.calculateDepartureTime = function () {
        var travelTime = 0;
        for (var i = 0; i < this.routeSegments.length; i++) {
            var segment = this.routeSegments[i];
            if (segment.departureTime != null) {
                return (segment.departureTime - travelTime);
            }
            else {
                travelTime += (segment.travelTime || 0);
            }
        }
        return undefined;
    };
    Route.prototype.calculateArrivalTime = function () {
        var travelTime = 0;
        for (var i = this.routeSegments.length - 1; i >= 0; i--) {
            var segment = this.routeSegments[i];
            if (segment.arrivalTime != null) {
                return (segment.arrivalTime + travelTime);
            }
            else {
                travelTime += (segment.travelTime || 0);
            }
        }
        return undefined;
    };
    return Route;
}());

var StatisticsResult = /** @class */ (function () {
    function StatisticsResult(result, statistics) {
        function dataToStatisticgroup(values) {
            var statisticsGroup = {};
            // Convert to map of named statistics, instead of index based ones
            for (var _i = 0, statistics_1 = statistics; _i < statistics_1.length; _i++) {
                var statistic = statistics_1[_i];
                statisticsGroup[statistic.name] = new StatisticValues(values[statistic.id]);
            }
            return statisticsGroup;
        }
        var individualStatistics = {};
        if (result.individualStatistics) {
            for (var key in result.individualStatistics) {
                if (result.individualStatistics[key] && result.individualStatistics[key].statistics) {
                    individualStatistics[key] = dataToStatisticgroup(result.individualStatistics[key].statistics);
                }
            }
        }
        this.statistics = dataToStatisticgroup(result.statistics), this.individualStatistics = individualStatistics, this.raw = result;
    }
    return StatisticsResult;
}());

/**
 * Lifecycle of a Multigraph:
 *
 * 1. CREATED
 * 2. ROUTING
 * 3. MERGING
 * 4. AGGREGATING
 * 5. COMPLETED / FAILED
 */

(function (MultigraphStatus) {
    MultigraphStatus["CREATED"] = "CREATED";
    MultigraphStatus["ROUTING"] = "ROUTING";
    MultigraphStatus["MERGING"] = "MERGING";
    MultigraphStatus["AGGREGATING"] = "AGGREGATING";
    MultigraphStatus["COMPLETED"] = "COMPLETED";
    MultigraphStatus["FAILED"] = "FAILED";
})(exports.MultigraphStatus || (exports.MultigraphStatus = {}));

/**
 * @General The reponse of the request if the optimization was successfully carried out. It contains the original request body information
 * (plus potential mitigated values). The result of the fleet planning optimization is stored in "tours" and additional helpful information
 * with regards to the execution (e.g. messages, mitigated errors) are stored in "resultStatus".
 * All elements in the return body (including stores, orders, transports) now have an id field which can be ignored by the client.
 */
var FpResult = /** @class */ (function () {
    function FpResult() {
    }
    return FpResult;
}());

var StatisticsGeometryResult = /** @class */ (function () {
    function StatisticsGeometryResult(result, statistics) {
        this.values = {};
        var statsticsMap = {};
        statistics.forEach(function (statistic) {
            statsticsMap[statistic.id] = statistic.name;
        });
        this.raw = result;
        var values = this.values;
        for (var key in result) {
            var row = result[key];
            var aggregationKey = (row.aggregation || '').toLowerCase();
            values[aggregationKey] = values[aggregationKey] || {};
            var statistic = statsticsMap[row.statisticId];
            values[aggregationKey][statistic] = { value: row.value };
        }
    }
    return StatisticsGeometryResult;
}());

// Barrel for types module. See https://angular.io/guide/glossary#barrel

var PolygonPayloadOptions = /** @class */ (function () {
    function PolygonPayloadOptions() {
        this.minPolygonHoleSize = 10000000;
        this.buffer = 50;
        this.simplify = 50;
        this.srid = exports.SRID.SRID_4326;
        this.quadrantSegments = 2;
        this.intersectionMode = 'union';
        this.decimalPrecision = 6;
    }
    return PolygonPayloadOptions;
}());
var PolygonRequestPayload = /** @class */ (function (_super) {
    __extends(PolygonRequestPayload, _super);
    function PolygonRequestPayload(client, sources, options) {
        var _this = _super.call(this, options) || this;
        _this.polygon = new PolygonPayloadOptions();
        _this.sources = _this.buildSourcesCfg(sources);
        _this.polygon.values = options.travelEdgeWeights;
        _this.polygon.serializer = options.serializer;
        _this.polygon.simplify = options.simplify;
        _this.polygon.srid = options.srid;
        _this.polygon.buffer = options.buffer;
        _this.polygon.minPolygonHoleSize = options.minPolygonHoleSize;
        _this.polygon.quadrantSegments = options.quadrantSegments;
        _this.polygon.intersectionMode = options.intersectionMode;
        _this.polygon.decimalPrecision = options.decimalPrecision;
        return _this;
    }
    return PolygonRequestPayload;
}(TravelRequestPayload));

/**
 *
 */
var ProjectedBounds = /** @class */ (function () {
    function ProjectedBounds(bounds) {
        this.southWest = new ProjectedPoint(Infinity, Infinity);
        this.northEast = new ProjectedPoint(-Infinity, -Infinity);
        if (bounds) {
            this.southWest = new ProjectedPoint(bounds.southWest.x, bounds.southWest.y);
            this.northEast = new ProjectedPoint(bounds.northEast.x, bounds.northEast.y);
        }
    }
    ProjectedBounds.prototype.expandPoint = function (x, y) {
        this.southWest.x = Math.min(this.southWest.x, x);
        this.northEast.x = Math.max(this.northEast.x, x);
        this.southWest.y = Math.min(this.southWest.y, y);
        this.northEast.y = Math.max(this.northEast.y, y);
    };
    ProjectedBounds.prototype.expand = function (bounds) {
        this.expandPoint(bounds.northEast.x, bounds.northEast.y);
        this.expandPoint(bounds.southWest.x, bounds.southWest.y);
    };
    return ProjectedBounds;
}());
/**
 *
 */
var ProjectedPoint = /** @class */ (function () {
    function ProjectedPoint(x, y) {
        this.x = x;
        this.y = y;
    }
    return ProjectedPoint;
}());
/**
 *
 */
var ProjectedLineString = /** @class */ (function () {
    function ProjectedLineString(coordinates) {
        var _this = this;
        this.bounds3857 = new ProjectedBounds();
        this.points = coordinates.map(function (coordinate) {
            _this.bounds3857.expandPoint(coordinate[0], coordinate[1]);
            var pair = sphericalMercator.project({ lat: coordinate[0], lng: coordinate[1] });
            return new ProjectedPoint(pair.x, pair.y);
        });
    }
    return ProjectedLineString;
}());
/**
 *
 */
var ProjectedPolygon = /** @class */ (function () {
    function ProjectedPolygon(data) {
        var _this = this;
        this.bounds3857 = new ProjectedBounds();
        this.travelTime = data.travelTime;
        this.area = data.area;
        this.lineStrings = [new ProjectedLineString(data.outerBoundary)];
        this.bounds3857.expand(this.lineStrings[0].bounds3857);
        if (data.innerBoundary) {
            data.innerBoundary.forEach(function (innerBoundary) {
                var lineString = new ProjectedLineString(innerBoundary);
                _this.lineStrings.push(lineString);
                _this.bounds3857.expand(lineString.bounds3857);
            });
        }
    }
    return ProjectedPolygon;
}());

/**
 * @Topic Polygons
 */
var PolygonsClient = /** @class */ (function () {
    function PolygonsClient(client) {
        this.client = client;
    }
    PolygonsClient.prototype.fetch = function (sources, options) {
        return __awaiter(this, void 0, void 0, function () {
            var cfg, result, boundedPolys;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cfg = new PolygonRequestPayload(this.client, sources, options);
                        return [4 /*yield*/, this._executeFetch(sources, options, cfg)];
                    case 1:
                        result = _a.sent();
                        if (options.serializer === 'json') {
                            boundedPolys = PolygonArray.create(result, result.metadata);
                            return [2 /*return*/, boundedPolys];
                        }
                        else if (options.serializer === 'geojson') {
                            return [2 /*return*/, result];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    PolygonsClient.prototype._executeFetch = function (sources, options, cfg) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/polygon')
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg)];
                    case 1:
                        result = _a.sent();
                        result.metadata = options;
                        return [2 /*return*/, result];
                }
            });
        });
    };
    return PolygonsClient;
}());
/**
 * Class to extend Array for polygons result to add maxBounds method to array results
 */
var PolygonArray = /** @class */ (function (_super) {
    __extends(PolygonArray, _super);
    function PolygonArray(items) {
        return _super.apply(this, items) || this;
    }
    PolygonArray.create = function (items, metadata) {
        var newProto = Object.create(PolygonArray.prototype);
        items.forEach(function (polygons) { return newProto.push(polygons); });
        if (metadata) {
            newProto.metadata = metadata;
        }
        return newProto;
    };
    PolygonArray.prototype.getMaxBounds = function () {
        var boundsPoints = [];
        this.forEach(function (svgPolygons) {
            var bounds3857;
            svgPolygons.polygons.forEach(function (polygonData) {
                var polygon = new ProjectedPolygon(polygonData);
                if (bounds3857) {
                    bounds3857.expand(polygon.bounds3857);
                }
                else {
                    bounds3857 = polygon.bounds3857;
                }
            });
            boundsPoints.push(webMercatorToLatLng(bounds3857.northEast, null));
            boundsPoints.push(webMercatorToLatLng(bounds3857.southWest, null));
        });
        return boundingBoxFromLocationArray(boundsPoints);
    };
    return PolygonArray;
}(Array));

var TimeRequestPayload = /** @class */ (function (_super) {
    __extends(TimeRequestPayload, _super);
    function TimeRequestPayload(client, sources, targets, options) {
        var _this = _super.call(this, options) || this;
        _this.sources = _this.buildSourcesCfg(sources);
        _this.targets = _this.buildTargetsCfg(targets);
        return _this;
    }
    return TimeRequestPayload;
}(TravelRequestPayload));

// TODO: decide on method names...or keep previous names
/**
 * @Topic Reachability
 */
var ReachabilityClient = /** @class */ (function () {
    function ReachabilityClient(client) {
        this.client = client;
    }
    /**
     *
     * @param sources
     * @param targets
     * @param options
     */
    ReachabilityClient.prototype.individual = function (sources, targets, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/time')
                            .key()
                            .toString();
                        cfg = new TimeRequestPayload(this.client, sources, targets, options);
                        return [4 /*yield*/, requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Makes a reachability request to the r360 services, and returns the raw results of the request
     *
     * @param sources
     * @param targets
     * @param options
     */
    ReachabilityClient.prototype.combined = function (sources, targets, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/reachability')
                            .key()
                            .toString();
                        cfg = new TimeRequestPayload(this.client, sources, targets, options);
                        return [4 /*yield*/, requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg)];
                    case 1: 
                    // TODO: add timeout
                    return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Makes a reachability request to the r360 services and returns the number of locations that are reachable within the given parameters
     *
     * @param sources
     * @param targets
     * @param options
     */
    ReachabilityClient.prototype.count = function (sources, targets, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.locations(sources, targets, options)];
                    case 1: 
                    // TODO: sopmething like this was used somewhere think
                    // (maybe autoprop)....however since it is trivial...maybe we should not have it anymore
                    return [2 /*return*/, (_a.sent()).length];
                }
            });
        });
    };
    /**
     * Makes a reachability requests to the r360 services and returns the input targets decorated with the resulting travel time
     *
     * @param sources
     * @param targets
     * @param options
     */
    ReachabilityClient.prototype.locations = function (sources, targets, options) {
        return __awaiter(this, void 0, void 0, function () {
            var map, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        map = {};
                        targets.forEach(function (place) { return map[String(place.id)] = -1; });
                        return [4 /*yield*/, this.combined(sources, targets, options)];
                    case 1:
                        response = _a.sent();
                        response.forEach(function (target) {
                            var id = String(target.id);
                            if (!map[id]) {
                                console.warn('NOT FOUND', String(target.id));
                            }
                            else {
                                if (target.travelTime > -1) {
                                    if (map[id] > -1) {
                                        map[id] = Math.min(map[id], target.travelTime);
                                    }
                                    else {
                                        map[id] = target.travelTime;
                                    }
                                }
                            }
                        });
                        return [2 /*return*/, targets.filter(function (place) {
                                var id = String(place.id);
                                place.travelTime = map[id];
                                return map[id] > -1;
                            })];
                }
            });
        });
    };
    return ReachabilityClient;
}());

var RouteRequestPayload = /** @class */ (function (_super) {
    __extends(RouteRequestPayload, _super);
    function RouteRequestPayload(client, sources, targets, options) {
        var _this = _super.call(this, options) || this;
        _this.sources = _this.buildSourcesCfg(sources);
        _this.targets = _this.buildTargetsCfg(targets);
        _this.pathSerializer = options.pathSerializer;
        if (typeof options.recommendations === 'boolean') {
            options.recommendations = options.recommendations ? 1 : 0;
        }
        if (Number.isInteger(options.recommendations) && _this.sources) {
            _this.sources.forEach(function (source) {
                if (source.tm != null) {
                    for (var mode in source.tm) {
                        source.tm[mode].recommendations = options.recommendations;
                    }
                }
            });
        }
        return _this;
    }
    return RouteRequestPayload;
}(TravelRequestPayload));

/**
 * @Topic Routes
 */
var RoutesClient = /** @class */ (function () {
    function RoutesClient(client) {
        this.client = client;
    }
    RoutesClient.prototype.fetch = function (sources, targets, options) {
        return __awaiter(this, void 0, void 0, function () {
            var cfg, result;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cfg = new RouteRequestPayload(this.client, sources, targets, options);
                        return [4 /*yield*/, this._executeFetch(sources, targets, options, cfg)];
                    case 1:
                        result = _a.sent();
                        if (!options.pathSerializer || options.pathSerializer === 'compact') {
                            return [2 /*return*/, result.routes.map(function (meta) {
                                    return new Route(_this.client, meta.travelTime, meta.segments, meta);
                                })];
                        }
                        else if (options.pathSerializer === 'geojson') {
                            return [2 /*return*/, result.routes];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    RoutesClient.prototype._executeFetch = function (sources, targets, options, cfg) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .part(this.client.serviceUrl)
                            .version()
                            .part('/route')
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg, {
                                // Headers are here because something needs to be fixed in the service endpoint
                                'Accept': 'application/json,application/javascript,*/*'
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    return RoutesClient;
}());

/**
 * @Topic Similarity
 */
var SimilarityClient = /** @class */ (function () {
    function SimilarityClient(client) {
        this.client = client;
    }
    /**
     *
     */
    SimilarityClient.prototype.metadata = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.tilesUrl)
                            .part('similarity/meta/')
                            .version()
                            .part('/' + encodeURIComponent('' + key))
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this.client).fetch(url)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     *
     */
    SimilarityClient.prototype.fetch = function (group, cell, conditions, bounds, normalizeOnViewport) {
        return __awaiter(this, void 0, void 0, function () {
            var boundsData, data, urlObject, url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        boundsData = {
                            'west': bounds.southWest.lng,
                            'south': bounds.southWest.lat,
                            'east': bounds.northEast.lng,
                            'north': bounds.northEast.lat
                        };
                        data = {
                            bounds: boundsData,
                            refCellId: cell,
                            scores: conditions.map(function (item) { return ({
                                source: item.source,
                                minutes: item.minutes,
                                factor: item.factor || 1
                            }); })
                        };
                        urlObject = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.tilesUrl)
                            .part('similarity/scores_cumulative/')
                            .version()
                            .part('/' + encodeURIComponent('' + group))
                            .key();
                        url = normalizeOnViewport ? urlObject.params({ normalizeOnViewport: !!normalizeOnViewport }).toString() : urlObject.toString();
                        return [4 /*yield*/, requests(this.client).fetch(url, 'POST', data)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return SimilarityClient;
}());

function isStatisticsRequestOptions(value) {
    return value.statistics;
}
var StatisticsRequestPayload = /** @class */ (function () {
    function StatisticsRequestPayload(client, sources, options) {
        this.inactiveSources = [];
        this.getClosestSources = false;
        this.serviceUrl = client.serviceUrl;
        this.serviceKey = client.serviceKey;
        this.useCache = options.useCache == undefined ? true : options.useCache;
        this.sources = sources.map(function (source) { return ({ id: source.id, y: source.lat, x: source.lng }); });
        this.iFeelLucky = options.iFeelLucky;
        this.travelType = options.travelType;
        this.edgeWeight = options.edgeWeight;
        this.maxEdgeWeight = options.maxEdgeWeight;
        this.frame = options.transitFrameDuration;
        this.time = options.transitFrameTime;
        this.date = options.transitFrameDate;
        this.maxTransfers = options.transitMaxTransfers;
        this.maxWalkingTimeFromSource = options.transitMaxWalkingTimeFromSource;
        this.avoidTransitRouteTypes = options.transitAvoidTransitRouteTypes;
        this.rushHour = options.rushHour;
        if (options.inactiveSources) {
            this.inactiveSources = options.inactiveSources.map(function (source) { return ({ id: source.id, y: source.lat, x: source.lng }); });
        }
        var statisticsIndices = [];
        if (isStatisticsRequestOptions(options)) {
            this.omitIndividualStatistics = options.omitIndividualStatistics;
            statisticsIndices = options.statistics.map(function (statistic) {
                if (statistic instanceof Number || typeof statistic === 'number') {
                    return +statistic;
                }
                else {
                    return statistic.id;
                }
            });
        }
        this.statisticGroupId = +options.statisticsGroup;
        this.statisticIds = statisticsIndices;
        if (options.closestSources) {
            this.getClosestSources = true;
        }
    }
    return StatisticsRequestPayload;
}());

var StatisticsGeometryRequestPayload = /** @class */ (function () {
    function StatisticsGeometryRequestPayload(client, geometry, options) {
        var statisticsIndices = options.statistics.map(function (statistic) {
            if (statistic instanceof Number || typeof statistic === 'number') {
                return +statistic;
            }
            else {
                return statistic.id;
            }
        });
        this.statisticGroupId = +options.statisticsGroup;
        this.statisticIds = statisticsIndices;
        this.intersectionGeometry = {
            data: geometry,
            crs: options.crs || 4326
        };
    }
    return StatisticsGeometryRequestPayload;
}());

/**
 * @Topic Statistics
 */
var StatisticsClient = /** @class */ (function () {
    function StatisticsClient(client) {
        this.client = client;
        this.statisticsMetadataCache = new SimpleLRU(200);
        this.statisticsEnsemblesCache = new SimpleLRU(200);
    }
    /**
     *
     * @param sources
     * @param options
     */
    StatisticsClient.prototype.combined = function (sources, // sources: LatLng[],
    options) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.dependent(sources, options)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result && result.statistics];
                }
            });
        });
    };
    /**
    * Make a statistics request to the r360 services
    */
    StatisticsClient.prototype.individual = function (sources, // sources: LatLng[],
    options) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.dependent(sources, options)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result && result.individualStatistics];
                }
            });
        });
    };
    /**
    * Make a statistics request to the r360 services
    */
    StatisticsClient.prototype.travelTimes = function (sources, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!sources.length) {
                            return [2 /*return*/, null];
                        }
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('traveltimes')
                            .params({
                            serviceUrl: this.client.serviceUrl
                        })
                            .toString();
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', new StatisticsRequestPayload(this.client, sources, options))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     *
     * @param sources
     * @param options
     */
    StatisticsClient.prototype.dependent = function (sources, // was LatLng[]
    options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!sources.length) {
                            return [2 /*return*/, null];
                        }
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('charts/dependent')
                            .params({
                            serviceUrl: this.client.serviceUrl
                        })
                            .toString();
                        return [4 /*yield*/, requests(this.client, options)
                                .fetch(url, 'POST', new StatisticsRequestPayload(this.client, sources, options))];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new StatisticsResult(result, options.statistics)];
                }
            });
        });
    };
    /**
     *
     * @param sources
     * @param options
     */
    StatisticsClient.prototype.geometry = function (geometry$$1, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!geometry$$1) {
                            return [2 /*return*/, null];
                        }
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('values/geometry')
                            .params({
                            serviceUrl: this.client.serviceUrl
                        })
                            .toString();
                        return [4 /*yield*/, requests(this.client, options)
                                .fetch(url, 'POST', new StatisticsGeometryRequestPayload(this.client, geometry$$1, options))];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new StatisticsGeometryResult(result, options.statistics)];
                }
            });
        });
    };
    /**
     *
     * @param group
     */
    StatisticsClient.prototype.metadata = function (group) {
        return __awaiter(this, void 0, void 0, function () {
            var server, key, cacheKey;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        server = this.client.config.tilesUrl;
                        key = (typeof group == 'number') ? group : group.id;
                        cacheKey = server + '-' + key;
                        return [4 /*yield*/, this.statisticsMetadataCache.get(cacheKey, function () { return __awaiter(_this, void 0, void 0, function () {
                                var url, result;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            url = new exports.UrlUtil.TargomoUrl(this.client)
                                                .host(this.client.config.tilesUrl)
                                                .part('statistics/meta/')
                                                .version()
                                                .part('/' + key + '')
                                                .key()
                                                .toString();
                                            return [4 /*yield*/, requests(this.client).fetch(url)];
                                        case 1:
                                            result = _a.sent();
                                            if (!result.name && result.names && result.names.en) {
                                                result.name = result.names.en;
                                            }
                                            if (result.stats && result.stats.length) {
                                                result.stats.forEach(function (stat) {
                                                    if (!stat.name && stat.names && stat.names.en) {
                                                        stat.name = stat.names.en;
                                                    }
                                                });
                                            }
                                            return [2 /*return*/, result];
                                    }
                                });
                            }); })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     *
     */
    StatisticsClient.prototype.metadataKey = function (group, statistic) {
        return __awaiter(this, void 0, void 0, function () {
            var endpoint, _i, _a, attribute;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.metadata(group)];
                    case 1:
                        endpoint = _b.sent();
                        for (_i = 0, _a = endpoint.stats; _i < _a.length; _i++) {
                            attribute = _a[_i];
                            if (statistic.id == attribute.statistic_id || (attribute.names && attribute.names.en == statistic.name)) {
                                return [2 /*return*/, attribute];
                            }
                        }
                        return [2 /*return*/, null];
                }
            });
        });
    };
    /**
     * Potentially decorate a layer route with excluded statistics.
     */
    StatisticsClient.prototype.tileRoute = function (group, include) {
        var key = (typeof group == 'number') ? group : group.id;
        var urlObject = new exports.UrlUtil.TargomoUrl(this.client)
            .host(this.client.config.tilesUrl)
            .part('statistics/tiles/')
            .version()
            .part('/' + key + '/{z}/{x}/{y}.mvt')
            .key();
        return include && include.length > 0 ?
            urlObject.params({ columns: encodeURIComponent(include.map(function (row) { return +row.id; }).join(',')) }).toString() :
            urlObject.toString();
    };
    /**
     *
     * @param sources
     * @param options
     */
    StatisticsClient.prototype.ensembles = function () {
        return __awaiter(this, void 0, void 0, function () {
            var cacheKey;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cacheKey = this.client.config.tilesUrl;
                        return [4 /*yield*/, this.statisticsEnsemblesCache.get(cacheKey, function () { return __awaiter(_this, void 0, void 0, function () {
                                var url, result, id, ensemble;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            url = new exports.UrlUtil.TargomoUrl(this.client)
                                                .host(this.client.config.tilesUrl)
                                                .part('ensemble/list/')
                                                .version()
                                                .key()
                                                .toString();
                                            return [4 /*yield*/, requests(this.client).fetch(url, 'GET')
                                                // FIXME: workaround for server results
                                            ];
                                        case 1:
                                            result = _a.sent();
                                            // FIXME: workaround for server results
                                            for (id in result) {
                                                if (result[id]) {
                                                    ensemble = result[id];
                                                    ensemble.id = +ensemble.id;
                                                    if (ensemble.groups && ensemble.groups.length) {
                                                        ensemble.groups.forEach(function (group) {
                                                            group.hierarchy = +group.hierarchy;
                                                            group.id = +group.id;
                                                        });
                                                    }
                                                }
                                            }
                                            return [2 /*return*/, result];
                                    }
                                });
                            }); })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return StatisticsClient;
}());

var StatefulMultigraphRequestPayload = /** @class */ (function (_super) {
    __extends(StatefulMultigraphRequestPayload, _super);
    function StatefulMultigraphRequestPayload(client, sources, options) {
        var _this = _super.call(this, client, sources, options) || this;
        // This request only works if only recognized attributes are sent
        delete _this.inactiveSources;
        delete _this.statisticGroupId;
        delete _this.statisticIds;
        delete _this.getClosestSources;
        delete _this.useCache;
        if (options) {
            if (options.multigraph.preAggregationPipeline) {
                _this.multiGraphPreAggregationPipeline = options.multigraph.preAggregationPipeline;
            }
            if (options.multigraph.referencedStatisticIds) {
                _this.multiGraphReferencedStatisticIds = options.multigraph.referencedStatisticIds;
            }
            if (options.multigraph.aggregation) {
                _this.multiGraphAggregationType = options.multigraph.aggregation.type || null;
                _this.multiGraphAggregationIgnoreOutliers = options.multigraph.aggregation.ignoreOutliers || null;
                _this.multiGraphAggregationOutlierPenalty = options.multigraph.aggregation.outlierPenalty || null;
                _this.multiGraphAggregationMinSourcesRatio = options.multigraph.aggregation.minSourcesRatio || null;
                _this.multiGraphAggregationMinSourcesCount = options.multigraph.aggregation.minSourcesCount || null;
                _this.multiGraphAggregationMaxResultValueRatio = options.multigraph.aggregation.maxResultValueRatio || null;
                _this.multiGraphAggregationMaxResultValue = options.multigraph.aggregation.maxResultValue || null;
                _this.multiGraphAggregationFilterValuesForSourceOrigins =
                    options.multigraph.aggregation.filterValuesForSourceOrigins || null;
                _this.multiGraphAggregationInputParameters = options.multigraph.aggregation.aggregationInputParameters || null;
                _this.multiGraphAggregationMathExpression = options.multigraph.aggregation.mathExpression || null;
                _this.multiGraphAggregationGravitationExponent = options.multigraph.aggregation.gravitationExponent || null;
                _this.multiGraphAggregationPostAggregationFactor = options.multigraph.aggregation.postAggregationFactor || null;
            }
            _this.multiGraphSerializationFormat = options.multigraph.serialization.format;
            _this.multiGraphSerializationDecimalPrecision = options.multigraph.serialization.decimalPrecision;
            _this.multiGraphSerializationMaxGeometryCount = options.multigraph.serialization.maxGeometryCount;
            _this.multiGraphDomainType = options.multigraph.domain.type;
            _this.multiGraphDomainEdgeAggregationType = options.multigraph.domain.edgeAggregationType;
            _this.multiGraphDomainStatisticGroupId = options.multigraph.domain.statisticGroupId;
            if (options.multigraph.layer) {
                _this.multiGraphLayerType = options.multigraph.layer.type;
                _this.multiGraphLayerGeometryDetailPerTile = options.multigraph.layer.geometryDetailPerTile;
                _this.multiGraphLayerMinGeometryDetailLevel = options.multigraph.layer.minGeometryDetailLevel;
                _this.multiGraphLayerMaxGeometryDetailLevel = options.multigraph.layer.maxGeometryDetailLevel;
                _this.multiGraphLayerGeometryDetailLevel = options.multigraph.layer.geometryDetailLevel;
                _this.multiGraphLayerCustomGeometryMergeAggregation = options.multigraph.layer.customGeometryMergeAggregation;
            }
        }
        return _this;
    }
    return StatefulMultigraphRequestPayload;
}(StatisticsRequestPayload));

/**
 * @Topic Stateful Multigraph
 */
var StatefulMultigraphClient = /** @class */ (function () {
    function StatefulMultigraphClient(client) {
        this.client = client;
    }
    /**
     * Creates a new multigraph tile set for the given sources and parameters.
     * Returns an id for the given aggregation to be used in subsequent mvt requests.
     *
     * @param sources
     * @param options
     */
    StatefulMultigraphClient.prototype.create = function (sources, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('multigraph')
                            .key()
                            .params({ serviceUrl: this.client.serviceUrl })
                            .toString();
                        cfg = new StatefulMultigraphRequestPayload(this.client, sources, options);
                        return [4 /*yield*/, requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST-RAW', JSON.stringify(cfg), { Accept: 'text/plain' })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Runs a "monolith" multigraph request for the given sources and parameters.
     * This performs the usual routing and then performs a global aggregation
     * into a single value per layer.
     *
     * @param sources
     * @param options
     */
    StatefulMultigraphClient.prototype.monolith = function (sources, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('multigraph/monolith')
                            .key()
                            .params({ serviceUrl: this.client.serviceUrl })
                            .toString();
                        cfg = new StatefulMultigraphRequestPayload(this.client, sources, options);
                        return [4 /*yield*/, requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg, {
                                Accept: 'application/json',
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Returns Info about the current State of the multigraph calculation
     *
     * **Multigraph Lifecycle**
     * 1. CREATED
     * 2. ROUTING
     * 3. MERGING
     * 4. AGGREGATING
     * 5. COMPLETED / FAILED
     *
     * @param multigraphId UUID of the multigraph
     */
    StatefulMultigraphClient.prototype.info = function (multigraphId) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('multigraph/' + multigraphId)
                            .key()
                            .params({ serviceUrl: this.client.serviceUrl })
                            .toString();
                        return [4 /*yield*/, requests(this.client).fetch(url, 'GET')];
                    case 1:
                        result = _a.sent();
                        if (result.boundingBoxNorthEast && result.boundingBoxSouthWest) {
                            result.boundingBox = {
                                northEast: {
                                    lat: result.boundingBoxNorthEast.y,
                                    lng: result.boundingBoxNorthEast.x,
                                },
                                southWest: {
                                    lat: result.boundingBoxSouthWest.y,
                                    lng: result.boundingBoxSouthWest.x,
                                },
                            };
                            delete result.boundingBoxNorthEast;
                            delete result.boundingBoxSouthWest;
                        }
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Redo Multigraph with UUID `multigraphId`
     *
     * @param multigraphId
     */
    StatefulMultigraphClient.prototype.redo = function (multigraphId) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.statisticsUrl)
                            .part('multigraph/' + multigraphId + '/update')
                            .key()
                            .params({ serviceUrl: this.client.serviceUrl })
                            .toString();
                        return [4 /*yield*/, requests(this.client).fetch(url, 'PATCH')];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    StatefulMultigraphClient.prototype.getTiledMultigraphUrl = function (multigraphId, format) {
        return new exports.UrlUtil.TargomoUrl(this.client)
            .host(this.client.config.statisticsUrl)
            .part('multigraph/' + multigraphId + '/{z}/{x}/{y}.' + format)
            .key()
            .params({ serviceUrl: this.client.serviceUrl })
            .toString();
    };
    return StatefulMultigraphClient;
}());

/**
 * @Topic Fleetplanner
 * @General This is the entry point for the Fleetplanner service.
 * The Fleetplanner service enables the configurable calculation of
 * efficient routing for multi-vehicle, multi-destination delivery scenarios.
 *
 * This service solves the Vehicle Routing Problem(VRP) which is similar to the traveling salesman problem. The difference between the two
 * problems, is that the VRP concerns multiple vehicles; a fleet of vehicles.
 * The VRP is about finding the optimal combination of routes for all of the vehicles.
 *
 * The VRP can be extended with additional factors that make the problem more complex. For example, deadlines can
 * be introduced. Every location has a deadline. In an optimal scenario, all the deadlines should be met. However, it is
 * not always possible to meet all deadlines with the number of vehicles that are available. In that case, the goal of the
 * VRP is to either meet as many deadlines, or to optimize the total sum of expired deadline times.
 *
 * Another way the VRP can be extended is by introducing weight and volumes to the orders that need to be delivered and having
 * vehicles with a maximum load weight and volume capacity.
 *
 * More in-depth/detailed information about the Fleetplanner service can be found at https://docs.targomo.com/fleetplanner/
*/
var FleetsClient = /** @class */ (function () {
    function FleetsClient(client) {
        this.client = client;
    }
    /**
     * @General Start a new request to compute optimized routes with the provided information.
     * @Performance Depending on the options, the execution time of this call can vary significantly.
     * This function makes a http POST request to the Targomo REST service for the Fleetplanner.
     * Every call to this function will be recorded based on your API key.
     * All your usage statistics are accessible on https://account.targomo.com/statistics.
     * @Exceptions This function can return the same exceptions as described on https://docs.targomo.com/fleetplanner/
     * @Example
     * ``` js
     * const stores = [{ uuid: '1', address: { lat: 52.474257, lng: 13.378094 } }];
     * const orders = [{ storeUuid: '1', address: { lat: 52.4, lng: 13.4 } },
     *                 { storeUuid: '1', address: { lat: 52.6, lng: 13.6 } },
     *                 { storeUuid: '1', address: { lat: 52.6, lng: 13.3 } }];
     * const transports = [{ vehicle: { storeUuid: '1', maxVolume: 100, maxWeight: 100 } }];
     * const options = { optimizationAlgorithm: 'CONSTRAINT_SATISFACTION', maxEdgeWeight: 3000, travelType: 'car' }
     * targomoClient.fleets.fetch(stores, orders, transports, options).then(result => {
     *     console.log(result.tours);
     * });
     * ```
     *
     * @Param stores
     * The stores, or otherwise called 'depots' from which their respective vehicles start their routes.
     * A store has a relation with zero or more orders, and zero or more vehicles.
     * @Param orders
     * The orders that need to be serviced by a vehicle from the store which is concerns this order.
     * An order has a relation with one store.
     * ##### Performance
     * The amount of orders has a significant on the time it takes to optimize the routes.
     * When using the default settings for optimizationTime and unimprovedWaitingTime in combination with more than 100 orders,
     * you can expect the results to be less optimized.
     * In this case, the algorithm doesn't have enough time to completely finish the optimization for this amount of orders.
     * Raise the optimizationTime option when sending a request with a high amount of orders.
     * @Param transports
     * The transports (vehicles). Each of which are assigned to a certain store.
     * @Param options
     * ##### Performance
     * Various different options within this options object can have a significant noticable impact on the request duration.
     */
    FleetsClient.prototype.fetch = function (stores, orders, transports, options) {
        return __awaiter(this, void 0, void 0, function () {
            var url, cfg, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this.client)
                            .host(this.client.config.fleetsUrl)
                            .version()
                            .part('/api/key-auth/optimizations')
                            .key()
                            .toString();
                        cfg = this._createPayload(this.client, stores, orders, transports, options);
                        return [4 /*yield*/, requests(this.client, options).fetch(url, 'POST', cfg)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    FleetsClient.prototype._createPayload = function (client, stores, orders, transports, options) {
        var payload = {
            optimizationTime: options.optimizationTime,
            optimizationAlgorithm: options.optimizationAlgorithm,
            optimizationMetadata: {
                costMatrixSource: options.costMatrixSource,
                geojsonCreation: options.geojsonCreation,
                unimprovedWaitingTime: options.unimprovedWaitingTime,
                filterOrdersWithMissedDeadline: options.filterOrdersWithMissedDeadline,
                filterOrdersOutsideOfValidWorkingHours: options.filterOrdersOutsideOfValidWorkingHours,
                prohibitFilteringOfOrdersWithDeadlinesEarlierEqualsThan: options.prohibitFilteringOfOrdersWithDeadlinesEarlierEqualsThan,
                secondsToPenaltyRatioForDeadlineMissed: options.secondsToPenaltyRatioForDeadlineMissed,
                secondsToPenaltyRatioForOutOfWorkingHours: options.secondsToPenaltyRatioForOutOfWorkingHours,
                timeConstraintPenaltyToTravelCostRatio: options.timeConstraintPenaltyToTravelCostRatio,
                longestTourPenaltyFactor: options.longestTourPenaltyFactor,
                nonParallelOrdersByTags: options.nonParallelOrdersByTags,
                travelOptions: {
                    travelType: options.travelType,
                    serviceKey: client.serviceKey,
                    serviceUrl: client.serviceUrl,
                    travelTimeFactors: options.travelTimeFactors,
                    fallbackServiceUrl: '',
                    edgeWeight: options.edgeWeight,
                    maxEdgeWeight: options.maxEdgeWeight,
                    elevation: options.elevation,
                    rushHour: options.rushHour
                }
            },
            stores: stores,
            transports: transports,
            orders: orders
        };
        return payload;
    };
    return FleetsClient;
}());

/**
 * @Topic Basemaps
 * @General This is the entry point for using the basemaps provided by Targomo.
 * @Alternative If you wish to use our basemaps with Leaflet. Please take a look at the targomo-js-extensions library.
 * We have a Leaflet extension for using our basemaps in that library.
*/
var BasemapsClient = /** @class */ (function () {
    function BasemapsClient(client) {
        this.client = client;
        /**
         * @General A lookup list of all the basemap names that we provide.
         * Soon we will have a code example in which you can see what the different basemaps look like.
         * @Alternative Use the basemapNames getter if you want to get a list of keys which you can use to get the GLStyleURL.
        */
        this.basemapsLookup = {
            'Bright': 'osm-bright-gl-style',
            'Light': 'positron-gl-style',
            'Light No-Labels': 'positron-nolabels-gl-style',
            'Dark': 'dark-matter-gl-style',
            'Dark No-Labels': 'dark-matter-nolabels-gl-style',
            'Gray': 'gray-gl-style',
            'Gray No-Labels': 'gray-nolabels-gl-style',
            'Light blue': 'blueberry-gl-style',
            'Dark blue': 'fiord-color-gl-style',
            'Dark blue No-Labels': 'fiord-color-nolabels-gl-style',
            'Basic': 'klokantech-basic-gl-style',
            'Toner': 'toner-gl-style',
        };
    }
    Object.defineProperty(BasemapsClient.prototype, "basemapNames", {
        /**
         * @Format Note that the basemap names start with a capital letter.
         * @Return A list of basemap names which can be used to pass as a parameter in the getGLStyleURL method.
        */
        get: function () {
            return Object.keys(this.basemapsLookup);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @General Get a GL style URL which can be used in Mapbox.
     * @Exceptions This method can throw the error "valid style name required to access Targomo basemap".
     * This error is thrown when the passed basremapName does not exist in basemapsLookup.
     * Make sure that you get the basemapName with the basemapNames accessor when this error is thrown.
     * @Example
     * ``` js
     * const basemaps = targomoClient.basemaps;
     * const basemapNames = basemaps.basemapNames;
     * const name = basemapNames[0];
     * const styleURL = basemaps.getStyleURL(name);
     * yourMapboxMap.setStyle(styleUrl);
     * ```
     * @Return Url for mapbox-gl style.
     * @Param basemapName
     * A string of valid basemap name (which you can get from the basemapNames accessor)
    */
    BasemapsClient.prototype.getGLStyleURL = function (basemapName) {
        if (!basemapName || !this.basemapsLookup[basemapName]) {
            throw new Error('valid style name required to access Targomo basemap');
        }
        return new exports.UrlUtil.TargomoUrl(this.client)
            .host(this.client.config.basemapsUrl)
            .part(this.basemapsLookup[basemapName] + '.json')
            .params({ key: this.client.serviceKey })
            .toString();
    };
    return BasemapsClient;
}());

/**
 * @Topic Geocoding
 */
var GeocodingClients = /** @class */ (function () {
    function GeocodingClients(esri, photon) {
        this.esri = esri;
        this.photon = photon;
    }
    return GeocodingClients;
}());
var TargomoClient = /** @class */ (function () {
    /**
     * Create a new Targomo client
     * @param region Service region name or full service URL. See: https://developers.route360.net/availability/
     * @param serviceKey Your targomo service key
     * @param additionalOptions additional options, defaults will be used if not provided
     */
    function TargomoClient(region, serviceKey, options) {
        this.serviceKey = serviceKey;
        if (!region) {
            throw new TypeError('Region parameter is missing');
        }
        this.config = new ClientConfig(options);
        if (!region.includes('http') && !region.includes('localhost') && !region.includes('/')) {
            this.serviceUrl = 'https://api.targomo.com/' + region + '/';
        }
        else {
            this.serviceUrl = region;
        }
        this.pois = new PointsOfInterestClient(this);
        this.statistics = new StatisticsClient(this);
        this.reachability = new ReachabilityClient(this);
        this.optimizations = new OptimizationsClient(this);
        this.geocoding = new GeocodingClients(new GeocodeEsriClient(), new GeocodePhotonClient(this));
        this.polygons = new PolygonsClient(this);
        this.routes = new RoutesClient(this);
        this.similarity = new SimilarityClient(this);
        this.benchmarks = new BenchmarksClient(this);
        this.statefulMultigraph = new StatefulMultigraphClient(this);
        this.multigraph = new MultigraphClient(this);
        this.basemaps = new BasemapsClient(this);
        this.fleets = new FleetsClient(this);
    }
    Object.defineProperty(TargomoClient.prototype, "endpoint", {
        /**
         * Extracts the endpoint part from the serviceUrl (for example `germany`)
         */
        get: function () {
            var items = this.serviceUrl.split('/').filter(function (item) { return !!item; });
            return items[items.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    TargomoClient.prototype.metadata = function () {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = new exports.UrlUtil.TargomoUrl(this)
                            .part(this.serviceUrl)
                            .version()
                            .part('/metadata/network')
                            .key()
                            .toString();
                        return [4 /*yield*/, requests(this).fetch(url)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return TargomoClient;
}());

// Barrel for API functions see https://angular.io/guide/glossary#barrel

var geometry = geometryModule; // NOTE: this does not export types, however we have none in there for now

exports.geometry = geometry;
exports.PointsOfInterestClient = PointsOfInterestClient;
exports.ClientConfig = ClientConfig;
exports.BenchmarksClient = BenchmarksClient;
exports.GeocodeEsriClient = GeocodeEsriClient;
exports.GeocodePhotonClient = GeocodePhotonClient;
exports.MultigraphClient = MultigraphClient;
exports.OptimizationsClient = OptimizationsClient;
exports.PolygonsClient = PolygonsClient;
exports.PolygonArray = PolygonArray;
exports.ReachabilityClient = ReachabilityClient;
exports.RoutesClient = RoutesClient;
exports.SimilarityClient = SimilarityClient;
exports.StatisticsClient = StatisticsClient;
exports.GeocodingClients = GeocodingClients;
exports.TargomoClient = TargomoClient;
exports.FleetsClient = FleetsClient;
exports.LatLng = LatLng;
exports.BoundingBox = BoundingBox;
exports.TravelSpeedValues = TravelSpeedValues;
exports.StatisticValues = StatisticValues;
exports.UseCacheRequestOptions = UseCacheRequestOptions;
exports.BaseRequestOptions = BaseRequestOptions;
exports.TravelRequestOptions = TravelRequestOptions;
exports.Route = Route;
exports.RouteSegment = RouteSegment;
exports.StatisticsResult = StatisticsResult;
exports.FpResult = FpResult;
exports.OptimizationResult = OptimizationResult;
exports.StatisticsGeometryResult = StatisticsGeometryResult;
exports.RequestsUtil = RequestsUtil;
exports.requests = requests;
exports.SimpleLRU = SimpleLRU;
exports.SimpleCache = SimpleCache;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=targomo-core.umd.js.map
