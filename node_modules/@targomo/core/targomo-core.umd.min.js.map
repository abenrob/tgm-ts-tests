{"version":3,"file":"targomo-core.umd.min.js","sources":["../../node_modules/whatwg-fetch/fetch.js","../../src/api/clientConfig.ts","../../src/util/cache.ts","../../src/util/requestUtil.ts","../../src/api/benchmarks.ts","../../src/util/urlUtil.ts","../../src/api/geocode.ts","../../src/api/geocodePhoton.ts","../../src/types/requestOptions.ts","../../src/api/payload/travelRequestPayload.ts","../../src/api/payload/multigraphRequestPayload.ts","../../src/api/multigraph.ts","../../src/api/payload/optimizationRequestPayload.ts","../../src/types/responses/optimizationResult.ts","../../src/api/optimizations.ts","../../src/api/payload/poiRequestPayload.ts","../../src/api/pointsOfInterest.ts","../../src/types/types.ts","../../src/types/options/multigraphRequestOptions.ts","../../src/geometry/projection.ts","../../src/geometry/geometry.ts","../../src/types/responses/multigraphInfo.ts","../../src/types/responses/routeSegment.ts","../../src/types/responses/route.ts","../../src/types/responses/statisticsResult.ts","../../src/types/responses/FleetResult.ts","../../src/types/responses/statisticsGeometryResult.ts","../../src/api/payload/polygonRequestPayload.ts","../../src/types/projectedPolygon.ts","../../src/api/polygons.ts","../../src/api/payload/timeRequestPayload.ts","../../src/api/reachability.ts","../../src/api/payload/routeRequestPayload.ts","../../src/api/routes.ts","../../src/api/similarity.ts","../../src/api/payload/statisticsRequestPayload.ts","../../src/api/payload/statisticsGeometryRequestPayload.ts","../../src/api/statistics.ts","../../src/api/payload/statefulMultigraphRequestPayload.ts","../../src/api/statefulMultigraph.ts","../../src/api/fleets.ts","../../src/api/basemaps.ts","../../src/api/targomoClient.ts","../../src/index.ts"],"sourcesContent":["(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status === undefined ? 200 : options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n","// TODO: or rename to ClientDefaults maybe to make it more clear\n// TODO: add more defaults here ...ex same stuff as in r360-js\n\n\nexport interface ClientOptions {\n  serverUrl?: string\n  statisticsUrl?: string\n  tilesUrl?: string\n  poiUrl?: string\n  mapTilesUrl?: string\n  photonGeocoderUrl?: string\n  overpassUrl?: string\n  fleetsUrl?: string\n  requestTimeout?: number\n  version?: number\n  routeTypes?: {routeType: string | number, color: string, haloColor: string}[]\n  debug?: boolean\n}\n\nexport class ClientConfig implements ClientOptions {\n\n  serverUrl: string = 'https://api.targomo.com/'\n  statisticsUrl: string = 'https://api.targomo.com/statistics/'\n  tilesUrl: string = 'https://api.targomo.com/vector-statistics/'\n  poiUrl: string = 'https://api.targomo.com/pointofinterest/'\n  mapTilesUrl: string = 'https://maps.targomo.com/'\n  photonGeocoderUrl: string = 'https://api.targomo.com/geocode/'\n  overpassUrl: string = 'https://api.targomo.com/overpass/'\n  fleetsUrl: string = 'https://api.targomo.com/fleetplanner/'\n  basemapsUrl: string = 'https://maps.targomo.com/styles/'\n  requestTimeout: 20000\n  version: number = 1\n  debug: boolean = false\n\n  // routeTypes  = [\n  //   // non transit\n  //   { routeType : 'WALK'     , color : 'red',       haloColor : 'white'},\n  //   { routeType : 'BIKE'     , color : '#558D54',   haloColor : 'white'},\n  //   { routeType : 'CAR'      , color : '#558D54',   haloColor : 'white'},\n  //   { routeType : 'TRANSFER' , color : '#C1272D',   haloColor : 'white'},\n\n  //   // berlin\n  //   { routeType : 102        , color : '#006837',   haloColor : 'white' },\n  //   { routeType : 400        , color : '#156ab8',   haloColor : 'white' },\n  //   { routeType : 900        , color : 'red',       haloColor : 'white' },\n  //   { routeType : 700        , color : '#A3007C',   haloColor : 'white' },\n  //   { routeType : 1000       , color : 'blue',      haloColor : 'white' },\n  //   { routeType : 109        , color : '#006F35',   haloColor : 'white' },\n  //   { routeType : 100        , color : 'red',       haloColor : 'white' },\n\n  //   // new york\n  //   { routeType : 1          , color : 'red',       haloColor : 'red'},\n  //   { routeType : 2          , color : 'blue',      haloColor : 'blue'},\n  //   { routeType : 3          , color : 'yellow',    haloColor : 'yellow'},\n  //   { routeType : 0          , color : 'green',     haloColor : 'green'},\n  //   { routeType : 4          , color : 'orange',    haloColor : 'orange'},\n  //   { routeType : 5          , color : 'red',       haloColor : 'red'},\n  //   { routeType : 6          , color : 'blue',      haloColor : 'blue'},\n  //   { routeType : 7          , color : 'yellow',    haloColor : 'yellow' }\n  // ]\n\n  constructor(options: ClientOptions) {\n    Object.assign(this, options)\n  }\n\n}\n","class SimpleLRUEntry<T> {\n  constructor(public value: Promise<T>, public key: string, public previous: SimpleLRUEntry<T>, public next: SimpleLRUEntry<T>) {}\n}\n\nexport interface Cache<T> {\n  get(key: string, factory?: () => Promise<T>): Promise<T>\n}\n\n/**\n * Extremely simple LRU (to avoid includinng another library)...However when more functionality is needed then an existing library is better\n */\nexport class SimpleLRU<T> implements Cache<T> {\n  private map: {[index: string]: SimpleLRUEntry<T>} = {}\n  private size: number = 0\n  private newest: SimpleLRUEntry<T>\n  private oldest: SimpleLRUEntry<T>\n\n  constructor(private capacity: number = 0) {\n  }\n\n  /**\n   * If a value for a given key is contained in the cache then return that value\n   * otherwise create/store and return a new value, by calling the given `factory` function\n   *\n   * @param key\n   * @param factory\n   */\n  async get(key: string, factory?: () => Promise<T>): Promise<T> {\n    const found = this.map[key]\n    if (found !== undefined) {\n      if (this.oldest == found && found.next) {\n        this.oldest = found.next\n      }\n\n      if (found.next) {\n        found.next.previous = found.previous\n      }\n\n      if (found.previous) {\n        found.previous.next = found.next\n      }\n\n      found.previous = this.newest\n      found.next = null\n      this.newest = found\n\n      try {\n        return await found.value\n      } catch (e) {\n        this.map[key] = undefined\n        return this.get(key, factory)\n      }\n    } else if (factory) {\n      const promise = factory()\n      const entry = this.map[key] = new SimpleLRUEntry<T>(promise, key, this.newest, null)\n      const value = await promise\n\n      if (this.newest) {\n        this.newest.next = entry\n      }\n\n      this.newest = entry\n\n      if (this.capacity) {\n        if (this.size >= this.capacity) {\n          const current = this.oldest\n\n          if (current) {\n            this.oldest = current.next\n            delete this.map[current.key]\n          }\n\n        } else {\n          this.size++\n        }\n      }\n\n      if (!this.oldest) {\n        this.oldest = this.newest\n      }\n\n      return value\n    } else {\n      return undefined\n    }\n  }\n}\n\n\n/**\n * Even simpler unlimited cache\n */\nexport class SimpleCache<T> implements Cache<T> {\n  private map: {[index: string]: T} = {}\n\n  async get(key: any, factory?: () => Promise<T>): Promise<T> {\n    let keyString: string\n\n    if (typeof key === 'string') {\n      keyString = key\n    } else {\n      keyString = JSON.stringify(key)\n    }\n\n    if (this.map[keyString] != undefined) {\n      return this.map[keyString]\n    } else {\n      const value = await factory()\n      this.map[keyString] = value\n      return value\n    }\n  }\n}\n","import { Cache, SimpleCache } from '../util/cache'\nimport { TargomoClient } from '../api/index';\n\nconst CACHE = new SimpleCache<any>()\n\nfunction logBody(body: any) {\n  if (body instanceof String || typeof body === 'string') {\n    console.log(body)\n  } else {\n    console.log(JSON.stringify(body, null, 2))\n  }\n}\n\nexport class RequestsUtil {\n\n  constructor(private options?: {debug?: boolean, timeout?: number}) {\n  }\n\n  async fetch(url: string, method: string = 'GET', payload?: any, headers: { [index: string]: string } = {}) {\n    let requestMethod = method\n\n    if (method !== 'JSONP') {\n      headers['Accept'] = headers['Accept'] ? headers['Accept'] : 'application/json'\n    } else {\n      requestMethod = 'GET'\n    }\n\n    if (method === 'POST-RAW') {\n      requestMethod = 'POST'\n    }\n\n    if (requestMethod === 'PUT' || requestMethod === 'POST') {\n      headers['Content-Type'] = 'application/json'\n    }\n\n    const requestHeaders = new Headers(headers)\n    const requestOptions: RequestInit = {\n      method: requestMethod,\n      headers: requestHeaders\n    }\n\n    if (method === 'POST-RAW') {\n      requestOptions.body = payload\n    } else if (method !== 'GET' && method !== 'JSONP') {\n      requestOptions.body = JSON.stringify(payload)\n    }\n\n    const response: Response = await fetch(url, requestOptions)\n\n    if ((this.options && this.options.debug) || response.status >= 400) {\n      console.log('[TargomoClient Begin]')\n      console.log('[Request]', requestOptions.method, url)\n      console.log(`  [Headers]`)\n      requestHeaders.forEach((value: string, key: string) => {\n        console.log(`    ${key} = ${value}`)\n      })\n\n      if (requestOptions.body) {\n        console.log(`  [Body]`)\n        console.log(requestOptions.body)\n      }\n\n      console.log('[Response]')\n      console.log('    status = ', response.status)\n      console.log('    statusText = ', response.statusText)\n\n      console.log(`  [Headers]`)\n\n      response.headers.forEach((value: string, key: string) => {\n        console.log(`    ${key} = ${value}`)\n      })\n    }\n\n    if (response.status >= 400) {\n      console.log(`  [Body]`)\n      const responseBody = response.headers.get('content-type') === 'application/json'\n                            ? JSON.stringify(await response.text(), null, 2)\n                            : await response.text()\n\n      logBody(responseBody)\n      console.log('[TargomoClient End]')\n\n      throw new Error(responseBody)\n    } else {\n      let responseValue: any = null\n      if (method === 'JSONP') {\n        const data = await response.text()\n        let start = data.indexOf('(')\n        let end = data.lastIndexOf(')')\n\n        if (start > -1 && end > -1) {\n          responseValue = JSON.parse(data.substring(start + 1, end))\n        } else {\n          responseValue = JSON.parse(data)\n        }\n      } else if (method === 'POST-RAW') {\n        responseValue = await response.text()\n      } else {\n        responseValue = response.json()\n      }\n\n\n      if (this.options && this.options.debug) {\n        console.log('  [Body]')\n        logBody(await responseValue)\n        console.log('[TargomoClient End]')\n      }\n\n      return responseValue\n    }\n  }\n\n  async fetchData(url: string, method: string = 'GET', payload?: any, headers?: { [index: string]: string }) {\n    // No error handling here, it is done in this.fetch()\n    const result: any = await this.fetch(url, method, payload, headers)\n    if (!result.data) {\n      console.warn('No data object was transmitted by ' + url + ' \\nReturning raw response')\n      return result\n    } else {\n      return result.data\n    }\n  }\n\n  /**\n   *\n   * @param cache\n   * @param url\n   * @param method\n   * @param payload\n   */\n  fetchCached<T>(cache: boolean | Cache<T>,\n    url: string,\n    method: string = 'GET',\n    payload?: any,\n    headers?: { [index: string]: string }) {\n    if (cache !== false) {\n      if (cache === true || !cache) {\n        cache = CACHE\n      }\n\n      const key = JSON.stringify({ url, method, payload })\n      return cache.get(key, () => this.fetch(url, method, payload, headers))\n    } else {\n      return this.fetch(url, method, payload, headers)\n    }\n  }\n\n  /**\n   *\n   * @param cache\n   * @param url\n   * @param method\n   * @param payload\n   */\n  fetchCachedData<T>(cache: boolean | Cache<T>,\n    url: string,\n    method: string = 'GET',\n    payload?: any,\n    headers?: { [index: string]: string }) {\n    if (cache !== false) {\n      if (cache === true || !cache) {\n        cache = CACHE\n      }\n\n      const key = JSON.stringify({ url, method, payload })\n      return cache.get(key, () => this.fetchData(url, method, payload, headers))\n    } else {\n      return this.fetchData(url, method, payload, headers)\n    }\n  }\n}\n\nexport function requests(client?: TargomoClient, options?: { requestTimeout?: number }): RequestsUtil {\n  // const requestTimeout = options && options.requestTimeout || client && client.config && client.config.requestTimeout // TODO....problem\n  return new RequestsUtil({debug: client && client.config && client.config.debug}) // {timeout: requestTimeout})\n}\n","import { TargomoClient } from './targomoClient'\nimport { StatisticsGroupId, BenchmarkCriteria, BoundingBox, UrlUtil } from '../index';\nimport { requests} from '../util/requestUtil';\n\n/**\n * @Topic Benchmarks\n */\nexport class BenchmarksClient {\n  constructor(private client: TargomoClient) {\n  }\n\n\n  /**\n   *\n   */\n  async fetch(group: StatisticsGroupId, conditions: BenchmarkCriteria[], bounds: BoundingBox): Promise<any> {\n    // TODO: have a \"Payload\" object\n    const boundsData = {\n      'west': bounds.southWest.lng,\n      'south': bounds.southWest.lat,\n      'east': bounds.northEast.lng,\n      'north': bounds.northEast.lat\n    }\n\n    const data = {\n      bounds: boundsData,\n      benchmarks: conditions.map(item => ({\n        source: item.source,\n        minEnd: item.minEnd,\n        minStart: item.minStart,\n        factor: item.factor,\n      }))\n    }\n\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.tilesUrl)\n      .part('benchmarks/scores_cumulative/')\n      .version()\n      .part('/' + encodeURIComponent('' + group))\n      .key()\n      .toString();\n\n    return await requests(this.client).fetch(url, 'POST', data)\n  }\n\n  /**\n   *\n   */\n  async metadata(key: StatisticsGroupId): Promise<any[]> {\n\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.tilesUrl)\n      .part('benchmarks/meta/')\n      .version()\n      .part('/' + encodeURIComponent('' + key))\n      .key()\n      .toString();\n\n    return await requests(this.client).fetch(url)\n  }\n}\n\n","import { TargomoClient } from '..';\n\nexport namespace UrlUtil {\n\n  export class TargomoUrl {\n    private url = '';\n    private firstParamPlaced = false;\n\n    constructor(private client?: TargomoClient) { }\n\n\n    host(value: string) {\n      if (this.url.length === 0 && value[value.length - 1] !== '/') {\n        value += '/';\n      }\n      return this.part(value);\n    }\n\n    part(value: string) {\n      this.url += value;\n      return this;\n    }\n\n    version() {\n      if (this.client.config.version !== null && this.client.config.version !== undefined) {\n        this.part('v' + this.client.config.version);\n      } else if (this.url[this.url.length - 1] === '/' ) {\n        this.url = this.url.substr(0, this.url.length - 1);\n      }\n\n      return this;\n    }\n\n    params(value: any) {\n      const keys = Object.keys(value);\n      keys.forEach(key => {\n        if (value[key] instanceof Array) {\n          value[key].forEach((v: any) => {\n            this.param(key, v);\n          });\n        } else {\n          this.param(key, value[key]);\n        }\n      });\n      return this;\n    }\n\n    private param(name: string, value: any) {\n      if (!this.firstParamPlaced) {\n        this.firstParamPlaced = true;\n        this.url += '?' + name + '=' + value;\n      } else {\n        this.url += '&' + name + '=' + value;\n      }\n    }\n\n    key() {\n      return this.params({key: this.client.serviceKey});\n    }\n\n    toString(): string {\n      return this.url;\n    }\n  }\n}\n\n","import { LatLng } from '../index'\nimport { requests} from '../util/requestUtil'\nimport { UrlUtil } from '../util/urlUtil'\n\nexport class GeocodeEsriClient {\n  constructor() {\n  }\n\n  /**\n   *  Geocoding with esri service\n   * @param query\n   * @param center\n   * @param language\n   * @param country\n   * @param magicKey\n   */\n  async geocode(\n    query: string,\n    center?: LatLng,\n    language?: string,\n    country?: string,\n    magicKey?: string\n  ): Promise<{ lat: number, lng: number, description: string }[]> {\n    const params: any = {\n      singleLine: query,\n      f: 'json',\n      countryCode: country,\n      maxLocations: 5,\n    }\n\n    if (center) {\n      params.location = `${center.lng},${center.lat}`\n    }\n\n    if (magicKey) {\n      params.magicKey = magicKey\n    }\n\n    const url = new UrlUtil.TargomoUrl()\n      .part('https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates')\n      .params(params)\n      .toString();\n    const jsonResult = await requests().fetch(url)\n\n    const results = jsonResult.candidates.map(function (result: any) {\n      const location = {\n        lat: result.location.y,\n        lng: result.location.x,\n        description: result.address\n      }\n      return location\n    })\n\n    return results\n  }\n\n\n  /**\n   *\n   * @param query\n   * @param center\n   * @param language\n   * @param country\n   * @param suggestionsCount\n   */\n  async suggest(query: string, center?: LatLng, language?: string, country?: string, suggestionsCount: number = 5): Promise<any[]> {\n    const params: any = {\n      // token: '',\n      // forStorage: false,\n      // singleLine: query,\n      text: query,\n      f: 'json',\n      countryCode: country,\n      // maxLocations: 5,\n      maxSuggestions: suggestionsCount\n    }\n\n    if (center) {\n      params.location = `${center.lng},${center.lat}`\n    }\n    const url = new UrlUtil.TargomoUrl()\n      .part('https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/suggest')\n      .params(params)\n      .toString();\n    const response = await requests().fetch(url)\n\n    return response.suggestions\n  }\n\n  /**\n   * Makes a reverse geocode request to the esri geocoder\n   *\n   * @param location\n   * @param language\n   */\n  async reverseGeocode(location: LatLng, language?: string): Promise<any> {\n    const params: any = {\n      // token: '',\n      // forStorage: false,\n      f: 'json',\n    }\n\n    params.location = `${location.lng},${location.lat}`\n\n    const url = new UrlUtil.TargomoUrl()\n      .part('https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode')\n      .params(params)\n      .toString();\n\n    const response = await requests().fetch(url)\n    if (response && response.address) {\n      const result = {\n        address: response.address.Match_addr,\n        city: response.address.City,\n        countryCode: response.address.CountryCode,\n        location: response.address.Loc_name,\n        region: response.address.Region,\n        subregion: response.address.Subregion,\n        zip: response.address.Postal\n      }\n\n      return result\n    } else {\n      return {}\n    }\n  }\n}\n","import { TargomoClient } from './targomoClient'\nimport { GeoSearchDescription, LatLng, UrlUtil } from '../index';\nimport { requests} from '../util/requestUtil';\n\nexport class GeocodePhotonClient {\n  constructor(private client: TargomoClient) {\n  }\n\n  async geocode(query: string, center?: LatLng, language?: string): Promise<any[]> {\n\n\n    let url = new UrlUtil.TargomoUrl()\n      .host(this.client.config.photonGeocoderUrl)\n      .part('api')\n      .params({\n        q: encodeURIComponent(query),\n        limit: 5\n      })\n      .toString();\n\n    if (center) {\n      url += '&lat=' + center.lat + '&lon=' + center.lng\n    }\n\n    if (language) {\n      url += '&lang=' + encodeURIComponent(language)\n    }\n\n    const response = await requests().fetch(url)\n\n    response.features.forEach(function(feature: any, index: any, array: any) {\n      if (feature.properties.osm_key == 'boundary')  {\n        array.splice(index, 1)\n      }\n    })\n\n    const results = response.features.map((result: any) => {\n      result.value = result.properties.osm_id\n      result.description = this.buildPlaceDescription(result.properties)\n      return result\n    })\n\n    return results\n  }\n\n  private buildPlaceDescription(properties: any): GeoSearchDescription {\n    const join = (texts: string[], middle: string = ' ') => texts.filter(text => !!text).join(middle).trim()\n    const parts = (fields: string[], middle: string) => join(fields.map(key => properties[key]), middle)\n\n    const address1 = parts(['street', 'housenumber'], ' ')\n    const address2 = join([parts(['postcode', 'city'], ' '), properties.country], ', ')\n\n    const result = {\n      title: '',\n      meta1: '',\n      meta2: '',\n      full:  '' // join([parts(['name', 'street', 'housenumber'], ' '), parts(['postcode', 'city'], ', ')])\n    }\n\n    if (properties.name !== undefined) {\n      result.title = properties.name\n      result.meta1 = address1\n      result.meta2 = address2\n    } else {\n      result.title = address1\n      result.meta1 = address2\n    }\n\n    if (properties.name !== address1) {\n      result.full = result.title\n    }\n\n    if (result.meta1 && properties.name !== address1) {\n      result.full += ', ' + result.meta1\n    }\n\n    if (result.meta1 && properties.name === address1) {\n      result.full +=  result.meta1\n    }\n\n    result.full = join([result.full, result.meta2], ', ')\n\n    return result\n  }\n}\n","import {\n  TravelSpeedValues,\n  TravelType,\n  TravelTimeFactors\n} from './types'\n\n\nexport class UseCacheRequestOptions {\n  useClientCache: boolean;\n}\n\nexport class BaseRequestOptions {\n  requestTimeout?: number;\n\n  /**\n   * @General Determines the dimension of the edges' weight, i.e.\n   * @Format time (distance in seconds) or distance (distance in meters)\n   * @Default `'time'`\n   */\n  edgeWeight?: 'time' | 'distance' = 'time';\n\n  /*\n   * @General The maximum distance \"depth\" of the built network.\n   * @Format in seconds (for edgeWeight = time) or meters (for edgeWeight = distance).\n   * @Performance If it is set too low routes between points won't be found.\n   * If it is set high the routing/time service will take longer.\n   * @Default `1800`\n   */\n  maxEdgeWeight?: number;\n\n  /**\n   * @General Whether or not the an elevetion heuristic will be used (e.g. downhill with bike quicker then uphill).\n   * @Default `false`\n   */\n  elevation?: boolean;\n\n  /**\n   * @General Specifies factors with which the travel times of the edges are adjusted.\n   * This may be necessary in certain areas where the travel time calculation is\n   * almost always off by a certain factor, e.g. Paris rush hour.\n   * Transit travel times are not affected by the travelTimeFactors\n   * @Example\n   * ``` js\n   * \"travelTimeFactors\" : { \"all\":0.5, \"motorway\":1.5, .... (other specific edge classes possible) },..\n   * ```\n   * @Min Minimum allowed cumulative travel time factor is `0.5`\n   * @Max Maximum allowed cumulative travel time factor is `100.0`\n   * @Format\n   * Travel time factor of 1.5 means 50% more time is needed\n   * (on top of a specified one, e.g. for the example above 1.5*0.5=0.75 - the final applied travel time factor for 'motorway' edges)\n   * @Nullable All elements are optional\n   */\n  travelTimeFactors?: TravelTimeFactors;\n\n}\n\n\nexport class TravelRequestOptions extends BaseRequestOptions {\n\n  /**\n   * Date and time of a transit request. Should either be a `Date` or a string/number that can be used in the constructor of `Date`.\n   * Using this option overrides `transitFrameDate` and `transitFrameTime`.\n   */\n  transitFrameDateTime?: string | number | Date;\n\n  /**\n   * Time-frame duration in seconds\n   */\n  transitFrameDuration?: number = undefined\n\n  /**\n   * Date of the transit request in the format `YYYYMMDD`\n   */\n  transitFrameDate?: number = 20170801\n\n  /**\n   * Start time of the transit request in seconds from midnight\n   */\n  transitFrameTime?: number = 39600\n\n  /**\n   * Maximum transfer segements in a route\n   */\n  transitMaxTransfers?: number = -1\n\n  /**\n   * Maximum time in seconds to walk to the first station\n   */\n  transitMaxWalkingTimeFromSource?: -1\n\n  /**\n   * Route types to avoid. https://developers.google.com/transit/gtfs/reference/#routestxt\n   */\n  transitAvoidTransitRouteTypes?: number[] = []\n\n  travelType?: TravelType;\n\n  /**\n   * @General Enable the rush hour mode to simulate a more crowded street. Warning this is a paid feature so not\n   * all plans are allowed to enable it.\n   * @Default `false`\n   */\n  rushHour?: boolean;\n\n  walkSpeed?: TravelSpeedValues = {}\n  bikeSpeed?: TravelSpeedValues = {}\n}\n","import { TravelRequestOptions } from './../../types/requestOptions';\nimport { LatLngId, LatLngIdTravelMode } from '../../index'\n\n/**\n * An object the contains a configuration set for making requests to the r360 services backend\n */\nexport class TravelRequestPayload extends TravelRequestOptions {\n  sources: LatLngIdTravelMode[];\n  targets: LatLngId[];\n\n  constructor(options?: TravelRequestOptions) {\n    super();\n    Object.assign(this, options)\n\n    if (options.transitFrameDateTime != null) {\n      let date;\n      if (options.transitFrameDateTime instanceof Date) {\n        date = options.transitFrameDateTime\n      } else {\n        date = new Date(<any>options.transitFrameDateTime)\n      }\n      const transitFrameDate = date ? ((date.getFullYear() * 10000) + (date.getMonth() + 1) * 100 + date.getDate()) : undefined\n      const transitFrameTime = date ? ((date.getHours() * 3600) + (date.getMinutes() * 60)) : undefined\n\n      this.transitFrameDate = transitFrameDate || this.transitFrameDate\n      this.transitFrameTime = transitFrameTime || this.transitFrameTime\n    }\n  }\n\n  protected buildTargetsCfg(targets: LatLngId[]): LatLngId[] {\n    return targets.map(original => {\n      return {\n        lat: original.lat,\n        lng: original.lng,\n        id: original.id,\n      }\n    })\n  }\n\n  protected buildSourcesCfg(sources: LatLngIdTravelMode[]): LatLngIdTravelMode[] {\n    return sources.map(original => {\n      const source = {\n        lat: original.lat,\n        lng: original.lng,\n        id: original.id,\n        tm: original.tm\n      }\n\n      if (!source.tm) {\n        switch (this.travelType) {\n          case 'car':\n            source.tm = {\n              car: this.rushHour ? {\n                rushHour: this.rushHour\n              } : {}\n            }\n            break\n          case 'walk':\n            source.tm = {\n              walk: this.walkSpeed\n            }\n            break\n          case 'bike':\n            source.tm = {\n              bike: this.bikeSpeed\n            }\n            break\n          case 'transit':\n            source.tm = {\n              transit: {\n                frame: {\n                  date: this.transitFrameDate,\n                  time: this.transitFrameTime,\n                  duration: this.transitFrameDuration\n                },\n                maxTransfers: this.transitMaxTransfers\n              }\n            }\n        }\n\n      }\n      return source\n    })\n  }\n}\n","import { TravelRequestPayload } from './travelRequestPayload';\nimport {\n  LatLngIdTravelMode,\n  MultigraphSpecificRequestOptions,\n  LatLngId,\n  MultigraphRequestOptions\n} from '../..';\n\n\nexport class MultigraphRequestPayload extends TravelRequestPayload {\n    multigraph: MultigraphSpecificRequestOptions;\n\n    constructor(sources: LatLngIdTravelMode[], options: MultigraphRequestOptions, targets?: LatLngId[]) {\n        super(options);\n        this.sources = this.buildSourcesCfg(sources);\n        if (targets) {\n            this.targets = this.buildTargetsCfg(targets);\n        }\n\n        this.multigraph = options.multigraph;\n\n    }\n}\n","import { TargomoClient } from '.';\nimport { UrlUtil, LatLngIdTravelMode, LatLngId, requests, MultigraphRequestOptions } from '..';\nimport { MgResult, MgOverviewResult } from '../types/responses/multigraphResult';\nimport { MultigraphRequestPayload } from './payload/multigraphRequestPayload';\n\n/**\n * @Topic Multigraph\n */\nexport class MultigraphClient {\n  constructor(private client: TargomoClient) {\n  }\n\n  /**\n\n   */\n  async fetch(sources: LatLngIdTravelMode[], options: MultigraphRequestOptions, targets?: LatLngId[]): Promise<MgResult> {\n\n    let url = new UrlUtil.TargomoUrl(this.client)\n      .part(this.client.serviceUrl)\n      .version()\n      .part('/multigraph')\n      .key()\n      .toString();\n\n    const cfg = new MultigraphRequestPayload(sources, options, targets);\n    const result = await requests(this.client, options).fetch(url, 'POST', cfg);\n    return result;\n  }\n\n  async fetchOverview(sources: LatLngIdTravelMode[], options: MultigraphRequestOptions, targets?: LatLngId[]): Promise<MgOverviewResult> {\n\n    let url = new UrlUtil.TargomoUrl(this.client)\n      .part(this.client.serviceUrl)\n      .version()\n      .part('/multigraph/overview')\n      .key()\n      .toString();\n\n    const cfg = new MultigraphRequestPayload(sources, options, targets);\n    const result = await requests(this.client, options).fetch(url, 'POST', cfg);\n    return result;\n  }\n\n  async getTiledMultigraphUrl(\n    sources: LatLngIdTravelMode[],\n    options: MultigraphRequestOptions,\n    format: 'geojson' | 'json' | 'mvt',\n    targets?: LatLngId[]): Promise<string> {\n\n    let url = new UrlUtil.TargomoUrl(this.client)\n      .part(this.client.serviceUrl)\n      .version()\n      .part('/objectcache/add')\n      .key()\n      .toString();\n\n    const cfg = new MultigraphRequestPayload(sources, options, targets);\n      // TODO ObjectCache should have its own client\n    const objectCache: any = await requests(this.client, options).fetch(url, 'POST', cfg);\n    return new UrlUtil.TargomoUrl(this.client)\n      .part(this.client.serviceUrl)\n      .version()\n      .part('/multigraph/{z}/{x}/{y}.' + format)\n      .key()\n      .params({\n        cfgUuid: objectCache.uuid\n      })\n      .toString();\n  }\n}\n","import { OptimizationRequestOptions } from '../../types/options/optimizationRequestOptions'\nimport { LatLngId, TravelType } from '../../types/types';\n\nexport class OptimizationRequestPayload {\n  description: string\n  statisticGroupId: number\n  serviceUrl: string\n  serviceKey: string\n  email: string\n  sendMail: boolean\n  callbackUrl: string\n  pointsPerSolution: number\n  maxSolutions: number\n  statisticId: number\n  travelType: TravelType\n  edgeWeight?: 'time' | 'distance'\n  maxEdgeWeight: number\n  sources: {[id: string]: { id: string, x: number, y: number }}[]\n\n  constructor(serviceUrl: string, serviceKey: string, sources: LatLngId[], options: OptimizationRequestOptions) {\n    this.description = options.description || ''\n    this.serviceUrl = serviceUrl\n    this.serviceKey = serviceKey\n    this.email = options.email || 'developers@targomo.com'\n    this.sendMail = false\n    this.callbackUrl = options.callbackUrl || 'https://localhost/' // TODO: was this donig anything?\n    this.pointsPerSolution = options.pointsPerSolution\n    this.maxSolutions = options.maxSolutions || 1\n    this.travelType = options.travelType\n    this.edgeWeight = options.edgeWeight\n    this.maxEdgeWeight = options.maxEdgeWeight\n    this.statisticGroupId = options.statisticGroup\n\n    if (options.statistic instanceof Number || typeof options.statistic === 'number') {\n      this.statisticId = +options.statistic\n    } else {\n      this.statisticId = options.statistic.id\n    }\n    const sourcesObject: {\n      [id: string]: {\n        id: string\n        x: number\n        y: number\n      }\n    } = {};\n    sources.forEach(source => {\n      sourcesObject[source.id] = {\n        id: source.id,\n        x: source.lng,\n        y: source.lat\n      }\n    });\n    this.sources.push(sourcesObject);\n  }\n}\n\n\n","/**\n *\n */\nexport interface OptimizationResultSolution {\n  id: number\n  startTime: number\n  endTime: number\n\n  /**\n   * Maximum statistic value (based on the input statistic) encoutenred in this simulation run\n   */\n  maxValue: number\n\n  /**\n   * How many points were wanted per solution, as specifified when the simulation was started\n   */\n  numberOfDesiredPoints: number\n\n  /**\n   * For each point in the original set show whether it is includes in the simulation subset or not\n   */\n  sources: {[id: string]: boolean}\n}\n\n/**\n * Results of an optimization simulation run\n */\nexport class OptimizationResult {\n  id: number\n  maxPossibleValue: number\n\n  /**\n   * The individual simulation solutions. The maximum number of these is `maxSolutions` supplied when the simulation started,\n   * however their number can also be lower if no more results could be generated\n   */\n  solutions: OptimizationResultSolution[]\n\n  constructor(readonly raw: any) {\n    this.id = raw.id\n    this.maxPossibleValue = raw.maxPossibleValue\n\n    this.solutions = raw.simulationResults.map((simulationResult: any) => {\n      const sources: {[id: string]: boolean} = {}\n\n      simulationResult.sourcePoints.forEach((point: any) => {\n        sources[point.id] = point.optimal\n      })\n\n      return {\n        id: simulationResult.id,\n        startTime: simulationResult.startTime,\n        endTime: simulationResult.endTime,\n        maxValue: simulationResult.maxValue,\n        numberOfDesiredPoints: simulationResult.numberOfDesiredPoints,\n        sources\n      }\n    })\n  }\n}\n","import { TargomoClient } from './targomoClient'\nimport { UrlUtil} from '../util';\nimport { requests} from '../util/requestUtil';\nimport { OptimizationRequestOptions } from '../types/options/optimizationRequestOptions';\nimport { LatLngId } from '../types/types';\nimport { OptimizationRequestPayload } from './payload/optimizationRequestPayload';\nimport { OptimizationResult } from '../types/responses/optimizationResult';\n\n/**\n * @Topic Optimizations\n */\nexport class OptimizationsClient {\n  constructor(private client: TargomoClient) {\n  }\n\n  /**\n   * Initiates a an optimimization simulation. Given a list of locations and simulation parameters it tries to\n   * derive a subset of these locations that are optimal.\n   *\n   * @param sources\n   * @param options\n   */\n  // NOTE: we can't have unit tests for this....\n  async create(sources: LatLngId[], options: OptimizationRequestOptions): Promise<any> {\n    if (!sources.length) {\n      return null\n    }\n\n\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.statisticsUrl)\n      .part('simulation/start/')\n      .key()\n      .params({\n        serviceUrl: encodeURIComponent(this.client.serviceUrl)\n      })\n      .toString();\n\n    const cfg = new OptimizationRequestPayload(this.client.serviceUrl, this.client.serviceKey, sources, options)\n\n    const result = await requests(this.client, options).fetch(url, 'POST', cfg)\n    return result && +result.id\n  }\n\n  /**\n   * Checks if the given optimization simulation have completed and have results ready for retrieval\n   *\n   * @param optimizationId\n   */\n  async ready(optimizationId: number | number[]): Promise<{[id: string]: boolean}> {\n    if (!(optimizationId instanceof Array)) {\n      optimizationId = [optimizationId]\n    }\n\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.statisticsUrl)\n      .part('simulation/ready/')\n      .key()\n      .params({\n        serviceUrl: encodeURIComponent(this.client.serviceUrl),\n        simulationId: optimizationId\n      })\n      .toString();\n\n    return requests(this.client).fetch(url)\n  }\n\n  /**\n   * Retrieve the results of an optimization simulation\n   *\n   * @param optimizationId\n   */\n  async fetch(optimizationId: number) {\n\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.statisticsUrl)\n      .part('simulation/' + optimizationId + '/')\n      .key()\n      .params({\n        serviceUrl: encodeURIComponent(this.client.serviceUrl)\n      })\n      .toString();\n\n    return new OptimizationResult(await requests(this.client).fetch(url))\n  }\n}\n","import { LatLngId, OSMType} from '../../types'\nimport { TargomoClient } from '../targomoClient'\nimport { POIRequestOptions } from '../../types/options/poiRequestOptions'\nimport {TravelRequestPayload} from './travelRequestPayload'\n\nexport class POIRequestPayload extends TravelRequestPayload {\n  osmTypes: OSMType[] = []\n  serviceKey: string\n  serviceUrl: string\n  format: 'json' | 'geojson'\n\n  constructor(client: TargomoClient, source: LatLngId, options: POIRequestOptions) {\n    super(options)\n    this.sources = this.buildSourcesCfg([source])\n    this.osmTypes = options.osmTypes\n    this.format = options.format;\n    this.serviceKey = client.serviceKey\n    this.serviceUrl = client.serviceUrl\n  }\n}\n","import { BoundingBox, LatLngId, LatLngIdProperties, LatLngProperties } from '../types';\nimport { POIRequestOptions } from '../types/options/poiRequestOptions';\nimport { requests } from '../util/requestUtil';\nimport { POIRequestPayload } from './payload/poiRequestPayload';\nimport { TargomoClient } from './targomoClient';\n\n/**\n * An object representing a point (poi/marker) which is returned from overpass queries in this module\n */\n// TODO: move elsewhere...or maybe not used in public library...things in here are too specific\nexport class OSMLatLng implements LatLngProperties {\n  constructor(readonly id: number,\n              readonly lng: number,\n              readonly lat: number,\n              readonly properties: {[index: string]: any}) {\n\n    // TODO: think...this is convenient to how we have things in mapbox widget...but maybe should not be done in a public api\n    if (this.properties) {\n      this.properties['marker-size'] = 1\n    }\n  }\n\n  toString() {\n    return this.properties ? this.properties['name'] : ''\n  }\n\n  copy() {\n    const result = new OSMLatLng(this.id, this.lat, this.lng, {...this.properties})\n\n    for (let key in this) {\n      if (key != 'properties') {\n        (<any>result)[key] = this[key]\n      }\n    }\n\n    return result\n  }\n}\n\nfunction parseOSMLocation(item: any): OSMLatLng {\n  let lat = item.lat\n  let lng = item.lon\n\n  if (lat === undefined && item.center) {\n    lat = item.center.lat\n    lng = item.center.lon\n  }\n\n  return new OSMLatLng(item.id, lng, lat, item.tags)\n}\n\n/**\n *\n */\n// TODO: better method names\n/**\n * @Topic Points of Interest\n */\nexport class PointsOfInterestClient {\n  // Idea is this will be instantiated internally in Targomoclient,. and will receive instance of parent in its constructor\n  constructor(private client: TargomoClient) {\n  }\n\n\n  // TODO move queryRaw and query to common lib\n\n  /**\n   * Query the overpass service with a raw overpass query string (in other words you supply the exact query)\n   *\n   * @param query\n   */\n  async queryRaw(query: string): Promise<OSMLatLng[]> {\n    let result = await requests(this.client).fetch(this.client.config.overpassUrl + '/api/interpreter', 'POST-RAW', query)\n    result = JSON.parse(result)\n    return result.elements.filter((item: any) => !!item.tags).map((item: any) => parseOSMLocation(item))\n  }\n\n  /**\n   * Query the overpass servive for given categories (way[type]=tag and node[way]=tag) within a given bounding box\n   *\n   * @param categories\n   * @param boundingBox\n   */\n  query(categories: {type: string, tag: string}[], boundingBox: BoundingBox[]): Promise<OSMLatLng[]> {\n    function asQueryElement(query: {type: string, tag: string}) {\n    if (query.tag === '*' || query.tag == null) {\n      return `\"${query.type}\"`\n    } else if (query.type && query.tag) {\n      return `\"${query.type}\"=\"${query.tag}\"`\n    } else {\n        throw new Error('invalid query' + JSON.stringify(query))\n      }\n    }\n\n    let params: string[] = []\n    categories.forEach(category => {\n      boundingBox.forEach(box => {\n        params.push(`\n      way[${asQueryElement(category)}]\n        (${box.southWest.lat},${box.southWest.lng},${box.northEast.lat},${box.northEast.lng});\n      node[${asQueryElement(category)}]\n        (${box.southWest.lat},${box.southWest.lng},${box.northEast.lat},${box.northEast.lng});\n        `)\n      })\n    })\n\n    const data = `\n      [out:json];\n      (\n      ${params.join('')}\n      );\n      out center;\n    `\n\n    return this.queryRaw(data)\n  }\n\n  /**\n   * Make an overpass query to a given url (full url including the query parameters)\n   *\n   * The results will be parsed and returned as a list of OSMLatLng objects\n   */\n  // TODO: ...this was used in GH...think what shape of this make best sense for a public library\n  async queryGetCustom(url: string): Promise<OSMLatLng[]> {\n    const result = await requests(this.client).fetch(url)\n    return result.elements.map((item: any) => parseOSMLocation(item))\n  }\n\n  /**\n   * Makes a request to the r360 poi service.\n   * Returns a list of OSMLatLng locations of the categories specified by `osmTypes` that are reachable within the given travel options\n   */\n  async reachable(source: LatLngId, /// LatLng\n                         options: POIRequestOptions): Promise<{[index: string]: LatLngIdProperties}> {\n     // TODO:different return type (todo: check server doesn't return array)\n    const url = `${this.client.config.poiUrl}/reachability`\n    return await requests(this.client, options).fetch(url, 'POST', new POIRequestPayload(this.client, source, options))\n  }\n}\n\n","/**\n * A map coordinate\n */\nexport class LatLng {\n  lat: number\n  lng: number\n  elevation?: number\n}\n\n\n\n/**\n * A map bounding box\n */\nexport class BoundingBox {\n  northEast: LatLng\n  southWest: LatLng\n}\n\n/**\n * Types for the `properties` part of a LatLngProperties object. The defined, non exhaustive, list contains some of the properties that\n * have meaning in various @targomo/client components\n */\nexport interface LatLngPropertiesObject {\n  'marker-type'?: string\n  'marker-size'?: number\n\n  /**\n   * Used by @targomo/client components to decide if a marker representing the location is active\n   */\n  'marker-active'?: boolean\n\n  /**\n   * Used by @targomo/client components to decide if a marker representing the location is draggable\n   */\n  'marker-draggable'?: boolean\n\n  /**\n   * Used by @targomo/client components to decide if a marker representing the location is clickable\n   */\n  'marker-clickable'?: boolean\n\n  [index: string]: any\n}\n\n/**\n * A location on a map that\n */\nexport interface LatLngProperties extends LatLng {\n  properties: LatLngPropertiesObject\n}\n\nexport interface LatLngIdProperties extends LatLngProperties {\n  id: any\n}\n\n\n/**\n *\n */\nexport type ReachableTile = { [tileId: number]: number }\n\n/**\n * The available statistics groups of the statistic service and the vector tiles service\n */\nexport type StatisticsGroupId = number | StatisticsGroups\n\nexport enum StatisticsGroups {\n  GERMANY_ZENSUS_100M_STATISTICS = 9,\n  GERMANY_ZENSUS_200M_STATISTICS = 2,\n  GERMANY_ZENSUS_500M_STATISTICS = 11,\n  GERMANY_ZENSUS_1000M_STATISTICS = 3,\n  GERMANY_ZENSUS_2000M_STATISTICS = 10,\n  NORWAY_STATISTICS = 4,\n  CENSUS_BRANDENBURG_POPULATION = 12,\n  CANADA_BLOCK_STATISTICS = 8,\n  CANADA_AREA_STATISTICS = 5,\n  BERLIN_STATISTICS = 6,\n}\n\n/**\n *\n */\nexport type TravelSpeed = 'slow' | 'medium' | 'fast'\n\n/**\n *\n */\nexport type TravelType = 'walk' | 'car' | 'bike' | 'transit'\n\n\nexport class TravelSpeedValues {\n  speed?: number\n  uphill?: number\n  downhill?: number\n}\n\n/**\n *\n */\nexport type EdgeWeightType = 'time' | 'distance'\n\n/**\n * @hidden\n */\nexport interface GeoSearchDescription {\n  title: string\n  meta1: string\n  meta2: string\n  full: string\n}\n\n/**\n * A specific statistics Item for making a statistics request on a StatisticsGroup\n */\nexport interface StatisticsItem {\n  id: number\n  name: string\n  label?: string,\n  chart?: boolean,\n  type?: 'value' | 'percent' | 'average',\n  meta?: StatisticsItemMeta\n  groupId?: StatisticsGroupId\n  groupMeta?: StatisticsGroupMeta\n}\n\nexport interface StatisticsGroupEnsemble {\n  id: number\n  name: string\n  groups: {\n    id: number,\n    hierarchy: number,\n    minZoomRecommendation: number\n  }[]\n}\n\n/**\n *\n */\nexport interface LabelStatisticsItem extends StatisticsItem {\n  label: string\n}\n\n/**\n *\n */\nexport interface ExtendedStatisticsItem extends LabelStatisticsItem {\n  /**\n   * Can this statistic be displayed as a chart\n   */\n  chart: boolean\n\n  /**\n   * What kind of value does this statistic represent\n   */\n  type: 'value' | 'percent' | 'average'\n}\n\n/**\n * A number of travelTime -> value returned by a statistics call\n */\nexport interface RawStatisticsValues {\n  [time: number]: number\n}\n\n/**\n *A result object for a specific statistic\n */\nexport class StatisticValues {\n  readonly total: number\n\n  constructor(readonly values: RawStatisticsValues) {\n    this.total = 0\n    for (const key in this.values) {\n      this.total += this.values[key]\n    }\n  }\n\n  // total: number\n  // percent: number\n  // average: number\n}\n\nexport interface MatrixOptimizationOptions {\n  pointsPerSolution: number,\n  maxSolutions: number,\n  statistic: StatisticsItem,\n  name?: string\n  description?: string\n  statisticsGroup: StatisticsGroupId\n}\n\n/**\n * A map of name->Statistics object returned from a statistics request\n */\nexport type StatisticsList = { [statisticKeyId: string]: StatisticValues }\n\nexport enum SRID {\n  SRID_3857 = 3857,\n  SRID_4326 = 4326\n}\n\n/**\n *\n */\nexport interface BenchmarkCriteria {\n  source: string,\n  minEnd: number,\n  minStart: number\n  factor: number\n}\n\n/**\n *\n */\nexport interface SimilarityCriteria {\n  source: string,\n  minutes: number,\n  factor: number\n}\n\n/**\n * A lat, lng position with the addition of an id\n */\nexport interface LatLngId {\n  id: any\n  lat: number\n  lng: number\n}\n\n/**\n * A LatLngId decorated with a travel time, usually return from an r360 service\n */\nexport interface LatLngIdTravelTime extends LatLngId {\n  travelTime?: number\n}\n\n/**\n * Describes metadata about a single statistic in a StatisticsGroup\n */\nexport interface StatisticsItemMeta {\n\n  statistic_id: number\n\n  /**\n   * Minimum cell value for this StatisticsItem\n   */\n  min: number\n\n  /**\n   * Minimum cell value for this StatisticsItem\n   */\n  max: number\n\n  /**\n   * Average cell value for this StatisticsItem\n   */\n  avg: number\n\n  /**\n   * Sum of all cell values for this StatisticsItem\n   */\n  sum: number\n\n  /**\n   * Standard deviation for this StatisticsItem\n   */\n  std: number\n\n  /**\n   * Indicates if the cell values are to be seen as absolute or relative values\n   */\n  type: 'ABSOLUTE' | 'PERCENT'\n\n  /**\n   * Names of the StatisticsItem in different languages\n   */\n  names: {\n    en: string,\n    [langCode: string]: string\n  }\n\n  /**\n   * Description of the StatisticsItem in different languages\n   */\n  descriptions: { [langCode: string]: string }\n\n  /**\n   * Breakpoints based on different statistical clustering approaches\n   */\n  breakpoints: {\n    equal_interval?: {\n      c9: number[],\n      c7: number[],\n      c5: number[],\n      [n: string]: number[]\n    },\n    kmeans?: {\n      c9: number[],\n      c7: number[],\n      c5: number[],\n      [n: string]: number[]\n    },\n    [method: string]: {\n      c9: number[],\n      c7: number[],\n      c5: number[],\n      [n: string]: number[]\n    }\n  }\n}\n\n/**\n * Describes metadata about a specific StatisticsSet (details https://service.route360.net/vector-statistics/statistics/list/v1)\n */\nexport interface StatisticsGroupMeta {\n\n  id: number\n\n  /**\n   * Minimum map zoom level to display the group on a map\n   */\n  min_zoom: number,\n\n  /**\n   * TODO\n   */\n  table: string\n\n  /**\n   * SRID projection\n   */\n  srid: SRID\n\n  /**\n   * TODO\n   */\n  type: string\n\n  /**\n   * TODO\n   */\n  source: string\n\n  created: Date,\n  license: string,\n  modified: Date,\n  numberofpoints: number,\n  version: string,\n  bounding_box: {\n    top_right: LatLng,\n    bottom_left: LatLng\n  },\n\n  /**\n * Description of the StatisticsGroup in different languages\n */\n  names: {\n    [langCode: string]: string\n  },\n\n  /**\n * Description of the StatisticsGroup in different languages\n */\n  descriptions: {\n    [langCode: string]: string\n  },\n  ignorevalues: number[],\n  stats: StatisticsItemMeta[]\n}\n\n/**\n * Padding object\n */\nexport interface PaddingObject {\n  top?: number,\n  bottom?: number,\n  left?: number,\n  right?: number\n}\n\n/**\n * Options object for setBounds function\n * @param {PaddingObject} padding The padding to apply to map on bounds fit.\n */\nexport interface SetBoundsOptions {\n  padding?: PaddingObject\n}\n\n/**\n * Object that will be passed to a request as source\n */\nexport interface LatLngIdTravelMode extends LatLngId {\n  tm?: {car: {rushHour?: boolean}} | {walk: TravelSpeedValues} | {bike: TravelSpeedValues}| {transit: TransitTravelModeOptions}\n}\n\nexport interface TransitTravelModeOptions {\n  frame?: {date?: number, time?: number, duration?: number}\n  maxTransfers?: number;\n}\n\n/**\n * Osm Type (OSM map feature tags. See: http://wiki.openstreetmap.org/wiki/Map_Features)\n */\nexport interface OSMType {\n  key: string\n  value: string\n}\n\n\nexport interface ReachabilityResult {\n  id: string\n  source: string\n  travelTime: number\n}\n\nexport interface TimeResult {  /**\n  * @General This field defines what travel type is used for Targomo Time Service\n  * (or Routing Service if geojsonCreation = ROUTING_SERVICE).\n  */\n //  travelType: TravelType\n  id: string\n  targets: {\n    id: string\n    travelTime: number\n  }[]\n}\n\n/**\n * @General A store (also called 'depot' sometimes) to which the respective vehicles/transports and orders are associated.\n * Each store will be optimized individually and independently.\n */\nexport interface FpStore {\n  /**\n   * @General Unique ID that is required to be set so that Order and Vehicle can reference to their respective store.\n   * @Nullable No.\n   */\n  uuid: string;\n  /**\n   * @General Name of the store.\n   * @Format Cannot be longer than 256 chars.\n   */\n  name?: string;\n  /**\n   * @General Location of the store.\n   * @Format For store addresses the geocoordinates(lat, lng) must be present in the FpAddress object.\n   */\n  address: FpAddress;\n}\n\n/**\n * @General Stores, Orders, and Transports/Vehicles have addresses associated to determine their location.\n * @Performance Preferably these addresses are already geocoded in the WGS84 format (in lat, lng).\n * Otherwise, the geocoordinates are calculated during the request from the other address details (street, city, etc.).\n * This only happens for order addresses. For store and start or endDestination addresses geocoordinates (lat, lng) must exist already.\n */\nexport interface FpAddress {\n  /**\n   * @General A unique id which can be used to map the order entity back to the original after the request.\n   */\n  uuid?: string;\n  /**\n   * @General Amount of time it takes to carry out an order for this address in seconds.\n   * @default 0\n   * @Format Time in seconds.\n   * @Nullable This value is only important for addresses in orders.\n   */\n  avgHandlingTime?: number;\n  /**\n   * @General Latitude of the geocoordinates of the the address.\n   * @Nullable This is required for addresses in store and start or endDestination.\n   * @Format WGS84 format.\n   * @Default If no value is set the result will include a warning and the default of 1 second is assumed,\n   * i.e. after arrival the transport departs one second later.\n   */\n  lat?: number;\n  /**\n   * @General Longitude of the geocoordinates of the the address.\n   * @Nullable This is required for addresses in store and start or endDestination.\n   * @Format WGS84 format.\n   */\n  lng?: number;\n  name?: string;\n  street?: string;\n  streetDetails?: string;\n  postalCode?: string;\n  city?: string;\n  country?: string;\n  phone?: string;\n}\n\n/**\n * @General The order object describes the entities that need to be serviced by the transports of the same associated store.\n */\nexport interface FpOrder {\n  /**\n   * @General A unique id which can be used to map the order entity back to the original after the request.\n   */\n  uuid?: string;\n  /**\n   * @General To associate the order entity to a store.\n   * @Format This id must be identical with one of the uuids in the store objects.\n   * @Nullable No\n   */\n  storeUuid: string;\n  /**\n   * @General The location of the order.\n   * When specifying an order setting its address is mandatory.\n   * However, for the optimization only the fields lat, lng, and avgHandlingTime are of relevance.\n   * @Example\n   * ``` js\n   * address = {\n   *  lat: 13.380707532171671,\n   *  lng: 52.532420302239096,\n   *  avgHandlingTime: 300\n   * }\n   * ```\n   * @Performance It is sufficient to specify an order’s address without geo-coordinates.\n   * The missing information is derived from the address details via geocoding.\n   * This can lead to small runtime impairments for many addresses, since the geocoding accesses an external service.\n   * The resulting geodata must not be saved.\n   */\n  address: FpAddress;\n  /**\n   * @General The deadline (time and date) for an order to be serviced.\n   * The optimization algorithm tries to minimize the amount of deadlines that are not kept.\n   * Deadline will be ignored if visitingTimes were set.\n   * @Format Expressed according to ISO 8601.\n   * @Default null\n   */\n  deadline?: string;\n\n  /**\n   * @General The user can specify within what time intervals the order can be serviced via visitingTimes.\n   * The actual planned visits have to be within these time intervals - this includes the time at the premise (see address.avgHandlingTime).\n   * The start of the first interval as well as the end of the last interval can be null or undefined, which means there are no total lower\n   * or upper boundaries only breaks in which the order cannot be serviced.\n   * @Example\n   * ``` js\n   * visitingTimes = [{\n   *  end: \"2012-04-23T18:00:00.000Z\"\n   * },{\n   *  start: \"2012-04-24T08:00:00.000Z\"\n   * }]\n   * ```\n   * means that the order cannot be serviced between 23.04.2012, 6pm and 24.04.2012, 8am but at any other time before or after.\n   *\n   * The user can also define just lower or upper boundaries for orders with only setting one or the other:\n   * start or end of a single visiting time interval, e.g.\n   * `visitingTimes = [{ end: \"2012-04-23T18:00:00.000Z\" }]`\n   * means that the order must have been serviced/visited before the specified time (including the handling time at the address).\n   * @Alternative If only an upper boundary for the visit is important the user can also simply choose to define this via the deadline\n   * parameter. The difference here is that the handling time at the address is not included in the specified time,\n   * i.e. if the vehicle/transport arrives at the location before the deadline then this time constraint is met.\n   * For instance consider the visitingTimes from above: if the avgHandlingTime of this order's address is 300 (=5 minutes) then setting\n   * the deadline to \"2012-04-23T17:55:00.000Z\" would be equivalent with visiting times.\n   * Simplified: visitingTimes[0].end = deadline + address.avgHandlingTime.\n   * Note, that deadline and visitingTimes cannot both be set for one order. This will result in the deadline value to be ignored\n   * (+ warning) in favour of the visitingTimes.\n   * @Performance Generally, the optimization tries to fit all orders into the specified visiting hours/deadlines and within the valid\n   * working hours of the assigned vehicle. If this is not possible orders will be outside of these time constraints, i.e. after the last\n   * visiting end time (or deadline) or after the valid working hours of the vehicle. This will result in penalty points for not meeting\n   * the respective time constraints or to filtering out (i.e. not servicing) the orders depending on how the optimization was configured\n   * (see OptimizationMetadata).\n   * @Format Expressed according to ISO 8601.\n   * @Default []\n   */\n  visitingTimes?: {start: string, end: string}[];\n  /**\n   * @General The user can define a respective load to specify the use case specific characteristics of the order.\n   * @Example\n   * ``` js\n   * load = {\n   *  bottles: 12\n   *  weight: 5\n   *  crate: 1\n   * }\n   * ```\n   * @Min Greater than or equal to 0\n   * It is not allowed to have a single Order whose single load is smaller than the smallest minSingle of all of the load's\n   * loadRestrictions of the vehicles\n   * @Max Smaller than 2147483648\n   * It is not allowed to have a single Order whose single load is larger than the largest maxSingle of all of the load's\n   * loadRestrictions of the vehicles (or maxSum if the former is not specified)\n   * In addition, the total loads of all Orders of a Store must not exceed the total of all of the load's maxSum of its associated Vehicles.\n   * @Default If no value was defined for a load for which a load restriction exists, then that load is assumed to be 0.0.\n   * If no restrictions for a load in any of the vehicles of the associated store exist the value is ignored (i.e. removed from the list).\n   * @Format The physical units of the load values, e.g. for weight and volume, must match the units of the associated loadRestrictions\n   * in the Vehicle.\n   */\n  load?: {[key: string]: number};\n\n  /**\n   * @General The priority specifies the priority of an order. This has effects on:\n  * - Validation: If the order number or the total order volume/weight is too high, first orders with a lower rather than a higher\n  * priority are removed.\n  * - Optimization: It is preferable to try to keep the deadlines of orders with higher priority.\n  * Here, the priority of the order represents the number of penalty points it acquires for not meeting the order’s deadline.\n  * For example, not meeting a deadline of an order with priority 10 is penalty-equivalent with not meeting the deadline of\n  * 10 orders with priority 1. If the optimization is to have priority classes,\n  * i.e. orders of a higher priority class are more important than infinitely many orders of a lower priority class,\n  * we suggest the usage of a \"folding technique\": Consider you have 12 orders, 4 of each priority \"low\", \"medium\", and \"high\".\n  * The low priority orders are assigned the value 1, the orders with medium priority are assigned the value 5,\n  * and the orders with the high priority are assigned the value 25.\n  * With this configuration you could always ensure that the meeting of a deadline of one higher priority order is\n  * more important than the meeting of deadlines of all lower priority orders.\n  * ! Please note that this technique can cause \"NumberOverflow\" errors for too many classes and orders.\n  * @Default 1\n   */\n  priority?: number;\n\n  /**\n   * @General A potential service comment for that order.\n   * @Format Length cannot exceed 5000 chars.\n   */\n  comments?: string;\n\n  /**\n   * @General With demands an order can be annotated with a list of things that need to be met by the supplies of the servicing/visiting\n   * vehicle, i.e. all demands of an order have to be contained in the list of the supplies of a vehicle for the vehicle to be eligible\n   * to service this order.\n   * @Example\n   * `demands = [\"dangerous_goods\", \"region_germany\"]`\n   * Means that this order needs to be serviced by a transport that has at least \"dangerous_goods\" and \"region_germany\" in its list of\n   * supplies.\n   * @Default []\n   */\n  demands?: string[];\n\n  /*\n   * @General If a tag is listed in optimizationMetadata.nonParallelOrdersByTags then they restrict the optimization in a way that some\n   * orders are not allowed to be serviced in parallel when they have the same values for the specified tags. Using tags for that purpose\n   * makes sense if some orders share the same external resource which would have to be present at both locations.\n   * @Example\n   * ``` js\n   * \"tags\" : {\n   *  \"facility manager\":\"Max Mustermann\",\n   *  \"owner\": \"Muster AG\"\n   * }\n   * ```\n   * It means that if another order exists that has the same \"facility manager\":\"Max Mustermann\" or \"owner\": \"Muster AG\" (or both) then\n   * they cannot be serviced in parallel since for both visits the same facility manager and/or owner has to be present.\n   */\n  tags?: {[key: string]: string};\n}\n\n/**\n * @General A transport is the entity which services the orders and for which the optimization finds the best order allocations\n * as well as the best routes.\n */\nexport interface FpTransport {\n  /**\n   * @General The vehicle entity describes the fixed parameters of a transport.\n   */\n  vehicle: FpVehicle;\n  /**\n   * @General Metadata defining variable specifics for the vehicle/transports.\n   */\n  metadata?: FpTransportMetadata;\n}\n/**\n * @General The vehicle entity describes the fixed parameters of a transport.\n * Parameters name, plate, avgFuelConsumption, and fuelType are currently not relevant for the optimization.\n */\nexport interface FpVehicle {\n  /**\n   * @General A unique id which can be used to map the order entity back to the original after the request.\n   */\n  uuid?: string;\n  /**\n   * @General To associate the vehicle entity to a store.\n   * @Format This id must be identical with one of the uuids in the store objects.\n   * @Nullable No\n   */\n  storeUuid: string;\n\n  /**\n   * @General For each use case specific load key, for instance \"weight\", \"volume\", \"item\", the user can define restrictions\n   * @Example\n   * ``` js\n   * loadRestrictions = {\n   *  weight: { maxSum\": 100 },\n   *  volume: { maxSum\": 2000, \"minSingle\": 100, \"maxSingle\": 200 },\n   *  item: { minSum\": 10, \"maxSum\": 20 }\n   * }\n   * ```\n   */\n  loadRestrictions?: {\n    [key: string]: {\n      maxSum: number,\n      minSum: number,\n      minSingle: number,\n      maxSingle: number\n    }\n  }\n\n  /**\n   * @General Vehicles should be annotated with a priority to rank their importance with regards to their respective keeping time\n   * constraints, i.e. when valid working hours (from earliestDepartureTime until latestArrivalTime) are exceeded the penalty for not\n   * finishing the tour on time is multiplied by the factor priority. In this way vehicle with a higher are more likely having tours\n   * that are still within their specified working hours. For instance, the optimization would evaluate the meeting of the time constraints\n   * of a vehicle with the priority of 50 as high as meeting the time constraints of five vehicles with a priority of 10. That also applies\n   * when secondsToPenaltyRatioForOutOfWorkingHours is set.\n   * @Default If the priority is not specified the service will assume a priority of 1 and include a warning in the tour planning result.\n   */\n  priority: number;\n\n  /**\n   * @General With supplies a vehicle can be annotated with a list of items or expertise that it provides so it can fulfil the demands of\n   * orders, i.e. all demands of an order have to be contained in the list of the supplies of a vehicle for the vehicle to be eligible to\n   * service this order.\n   * @Example `supplies = [\"dangerous_goods\", \"normal_goods\", \"region_germany\", \"region_benelux\"]`\n   * Means that this vehicle can service any order that demands \"normal_goods\", \"dangerous_goods\", \"region_germany\", or\n   * \"region_benelux\" or any combination of that, e.g. its tour can include an order with dangerous goods in Germany.\n   */\n  supplies?: string[];\n\n  /**\n   * An optional parameter that is used in the route optimization. With this parameter all or some vehicles can be annotated with extra\n   * costs (in seconds if travel costs are travel times) that are added during the optimization if a tour for this vehicle was created.\n   * This can be used, for instance, to motivate the usage of certain vehicles over other vehicles (the preferred vehicle should have a\n   * smaller fixed cost), or to generally penalize the usage of many vehicles (e.g. if all vehicles have a value set of $300$ it means\n   * that the optimization tries to fulfil all requirements with as few cars as possible and only would add a tour/vehicle if the travel\n   * costs can be reduced by at least $300$ (or more deadlines can be met)).\n   * @Min If specified it has to be equal or greater than 0.\n   * @Default 0\n   */\n  fixedTravelCosts?: number;\n\n  name?: string;\n  plate?: string;\n  avgFuelConsumption?: number;\n  fuelType?: string;\n}\n\n/**\n * @General Metadata defining variable specifics for the vehicle/transports.\n * @Example The three parameters earliestDepartureTime, latestArrivalTime, and interruptionTimes constitute the transport's valid\n * working hours. In the example below the vehicle has a valid working hour from 8 to 18 with a 2 hour break from 12 to 14:\n * ``` js\n * metadata = {\n *  earliestDepartureTime: \"2012-04-23T08:00:00.000Z\",\n *  latestArrivalTime: \"2012-04-23T18:00:00.000Z\",\n *  interruptionTimes: [{\n *   start: \"2012-04-23T12:00:00.000Z\",\n *   end: \"2012-04-23T14:00:00.000Z\"\n *  }]\n * }\n * ```\n */\nexport interface FpTransportMetadata {\n  /**\n   * @General Specifies from when on the transport would be ready to service the orders,\n   * e.g. because right now it is still being refuelled.\n   * @Format Expressed according to ISO 8601\n   * @Default If no earliestDepartureTime is specified, it is assumed that the vehicle is immediately ready for departure.\n   */\n  earliestDepartureTime?: string;\n\n  /**\n   * @General latestArrivalTime can be set to when the tour for this transport/vehicle has to end at the latest.\n   * @Default If no value was set it is assumed that no latest end date for this transport/vehicle exists.\n   */\n  latestArrivalTime?: string;\n\n  /**\n   * @General Breaks within the working hours (from earliestDepartureTime to latestArrivalTime) can be set with interruptionTimes.\n   * In the specified interruption times the transport/vehicle cannot service orders or travel between them.\n   * If these breaks fall within the tour (-item) the result will contain these in the tourItem.interruptions parameter.\n   * @Format Both, start and end dates must be set for all time intervals of interruption times.\n   */\n  interruptionTimes?: {start: string, end: string}[]\n\n  /**\n   * @General The start location of the vehicle.\n   * @Default If no start address was specified,\n   * the address of the store referenced in the Vehicle is assumed to be the start address of the transport's tour.\n   * @Format For start addresses, the geocoordinates(lat, lng) must exist already.\n   */\n  start?: FpAddress ;\n  /**\n   * @General The field endDestinations contains the potential end points of the vehicle.\n   * @Performance If multiple endDestinations are specified, finding the best endpoint is part of the optimization.\n   * @Format The semantics for its configuration is:\n   * - List empty: The last delivered order is also the end point of the route.\n   * - One list entry: The route must end at this fixed end point.\n   * - Multiple list entries: The selection of the best end point is part of the optimization.\n   * For end destination addresses the geocoordinates(lat, lng) must exist already.\n   */\n  endDestinations?: FpAddress[];\n}\n/**\n * @General Specifies factors with which the travel times of the edges are adjusted.\n * This may be necessary in certain areas where the travel time calculation is\n * almost always off by a certain factor, e.g. Paris rush hour.\n * Transit travel times are not affected by the travelTimeFactors\n * @Example `\"travelTimeFactors\" : { \"all\":0.5, \"motorway\":1.5, .... (other specific edge classes possible) },..`\n * @Min Minimum allowed cumulative travel time factor is `0.5`\n * @Max Maximum allowed cumulative travel time factor is `100.0`\n * @Format\n * Travel time factor of 1.5 means 50% more time is needed\n * (on top of a specified one, e.g. for the example above 1.5*0.5=0.75 - the final applied travel time factor for 'motorway' edges)\n * @Nullable All elements are optional\n */\nexport interface TravelTimeFactors {\n  /**\n   * @General Has an effect on all edge classes (excluding transit travel times)\n   */\n  all: number,\n\n  motorway: number,\n  motorway_link: number,\n  trunk: number,\n  trunk_link: number,\n  primary: number,\n  primary_link: number,\n  secondary: number,\n  secondary_link: number,\n  tertiary: number,\n  residential: number,\n  tertiary_link: number,\n  road: number,\n  unclassified: number,\n  service: number,\n  living_street: number,\n  pedestrian: number,\n  track: number,\n  path: number,\n  cycleway: number,\n  footway: number,\n  steps: number,\n  unknown: number\n}\n","import { TravelRequestOptions, UseCacheRequestOptions } from '../requestOptions';\n\nexport enum MultigraphRequestAggregation {\n  NONE = 'none',\n  SUM = 'sum',\n  MAX = 'max',\n  MIN = 'min',\n  MEAN = 'mean',\n  MEDIAN = 'median',\n  NEAREST = 'nearest',\n  UNION = 'routing_union',\n  MATH = 'math',\n  GRAVITATION = 'gravitation_huff'\n}\n\nexport enum MultigraphRequestLayer {\n  IDENTITY = 'identity',\n  TILE = 'tile',\n  HEXAGON = 'hexagon',\n  CUSTOM_GEOMETRIES = 'custom_geometries'\n}\n\nexport interface MultigraphAggregationOptions {\n  type: MultigraphRequestAggregation\n  ignoreOutliers?: boolean\n  outlierPenalty?: number\n  minSourcesRatio?: number\n  minSourcesCount?: number\n  maxResultValue?: number\n  maxResultValueRatio?: number\n  filterValuesForSourceOrigins?: string[]\n  gravitationExponent?: number\n  mathExpression?: string\n  postAggregationFactor?: number\n  aggregationInputParameters?: {\n    [parameterName: string]: {\n      inputFactor?: number\n      gravitationAttractionStrength?: number\n      gravitationPositiveInfluence?: number\n    }\n  }\n}\n\n\nexport interface MultigraphSpecificRequestOptions {\n\n  preAggregationPipeline: {\n    [pipelineName: string]: MultigraphAggregationOptions\n  }\n\n  referencedStatisticIds: {\n    [parameterName: string]: number\n  }\n\n  aggregation: MultigraphAggregationOptions\n\n  serialization: {\n    format: 'geojson' | 'json' | 'mvt'\n    decimalPrecision?: number\n    maxGeometryCount?: number\n  }\n\n  domain: {\n    type: 'edge' | 'node' | 'statistic_geometry'\n    edgeAggregationType?: 'min' | 'max' | 'mean'\n    statisticGroupId?: number\n  }\n\n  layer: {\n    type: MultigraphRequestLayer\n    edgeAggregationType?: 'min' | 'max' | 'mean'\n    geometryDetailPerTile?: number\n    minGeometryDetailLevel?: number\n    maxGeometryDetailLevel?: number\n    geometryDetailLevel?: number\n    customGeometryMergeAggregation?: 'max' | 'mean' | 'min' | 'sum'\n  }\n\n  edgeClasses?: number[]\n}\n\nexport interface MultigraphRequestOptions extends TravelRequestOptions, UseCacheRequestOptions {\n  multigraph: MultigraphSpecificRequestOptions;\n\n}\n","import {LatLng} from '../types'\n\nexport interface Projection {\n  project(latlng: LatLng): {x: number, y: number}\n  unproject(point: {x: number, y: number}): LatLng\n}\n\nexport const sphericalMercator: Projection = new class {\n  private R = 6378137 // constant for Earth's radius\n\n  project(latlng: LatLng) {\n    let d = Math.PI / 180\n    let max = 1 - 1E-15\n    let sin = Math.max(Math.min(Math.sin(latlng.lat * d), max), -max)\n\n    return {\n      x: this.R * latlng.lng * d,\n      y: this.R * Math.log((1 + sin) / (1 - sin)) / 2\n    }\n  }\n\n  unproject(point: {x: number, y: number}) {\n    let d = 180 / Math.PI\n\n    return {\n      lat: (2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,\n      lng: point.x * d / this.R\n    }\n  }\n}\n","import { LatLng, BoundingBox, TravelType } from './../types/index'\nimport * as projection from './projection'\n\n/**\n * Some reusable functions that deal with lat/lng gemoetry calculations\n */\n\nconst EARTH_RADIUS_KM = 6371.01\nconst RADIANS = Math.PI / 180\n// const DEGREES = 180 / Math.PI\n\n/**\n * Return whether a lat/lng point is contained within a bounding box\n */\nexport function contains(bBox: BoundingBox, point: LatLng) {\n  return point.lat >= bBox.southWest.lat && point.lat <= bBox.northEast.lat &&\n    point.lng >= bBox.southWest.lng && point.lng <= bBox.northEast.lng\n}\n\n\n/**\n * Returns the distance in kilometers between two lat/lng points\n */\nexport function calculateDistance(from: LatLng, to: LatLng) {\n  const fromLat = RADIANS * from.lat\n  const fromLng = RADIANS * from.lng\n  const toLat = RADIANS * to.lat\n  const toLng = RADIANS * to.lng\n\n  return Math.acos(\n    Math.sin(fromLat) * Math.sin(toLat) +\n    Math.cos(fromLat) * Math.cos(toLat) *\n    Math.cos(fromLng - toLng)) * EARTH_RADIUS_KM\n}\n\n/**\n *\n * Creates a bounding box around a point\n *\n * @param from\n * @param distance distance in km\n */\nexport function boundingBox(from: LatLng, distance: number): BoundingBox {\n  distance = distance * 1000\n\n  const lat = from.lat\n  const lng = from.lng\n\n  const latRadians = lat * RADIANS\n\n  const DELTA_LAT_KM = 110.574235\n  const DEGREES_LONG_KM = 110.572833 * Math.cos(latRadians)\n\n  const deltaLat = distance / 1000.0 / DELTA_LAT_KM\n  const deltaLong = distance / 1000.0 / DEGREES_LONG_KM\n\n  const topLat = lat + deltaLat\n  const bottomLat = lat - deltaLat\n  const leftLng = lng - deltaLong\n  const rightLng = lng + deltaLong\n\n  return {\n    northEast: {\n      lat: topLat, lng: rightLng\n    },\n    southWest: {\n      lat: bottomLat, lng: leftLng\n    }\n  }\n}\n\n/**\n * Give a list of locations return only those that are in proximity (predefined based on given TravelOptions)\n * to any location in the  `from` list\n * The use of this is to reduce the inputs to reachability and other requests (pre-filtering out remote targets) for perfromance reasons\n *\n * @param locations  The list to be filtered\n * @param from  results will be in proximity to these\n * @param options traveloptions (affect the distance around the `from` list that will be considered)\n */\nexport function locationsWithinTravelOptions<T extends LatLng>(locations: T[], from: LatLng | LatLng[],\n  options: {\n    maxEdgeWeight: number,\n    edgeWeight: 'time' | 'distance',\n    travelType: TravelType\n  }) {\n  const maxEdgeWeight = options.maxEdgeWeight\n  let speed: number;\n  switch (options.travelType) {\n    case 'walk': speed = 10; break;\n    case 'bike': speed = 25; break;\n    case 'transit': speed = 150; break;\n    default: speed = 120; break;\n  }\n\n  const distanceKm = (options.edgeWeight === 'distance')\n    ? Math.round(maxEdgeWeight / 1000)\n    : (speed * maxEdgeWeight / 3600)\n  return locationsWithinDistance(locations, from, distanceKm)\n}\n\nfunction getSpeed(options: {\n  maxEdgeWeight: number,\n  edgeWeight: 'time' | 'distance',\n  travelType: TravelType\n}) {\n  switch (options.travelType) {\n    case 'walk': return 10\n    case 'bike': return 25\n    case 'transit': return 150\n    default: return 120\n  }\n}\n\n/**\n * Creates a bounding box around a location, with parametres about the distance calculated (based on predefined internal logic)\n * from a give TravelOptions\n *\n * @param from\n * @param options\n */\nexport function boundingBoxWithinTravelOptions<T extends LatLng>(\n  from: T,\n  options: {\n    maxEdgeWeight: number,\n    edgeWeight: 'time' | 'distance',\n    travelType: TravelType\n  }) {\n  const maxEdgeWeight = options.maxEdgeWeight\n  const speed: number = getSpeed(options)\n  const distanceKm = (options.edgeWeight === 'distance')\n    ? Math.round(maxEdgeWeight / 1000)\n    : (speed * maxEdgeWeight / 3600)\n  return boundingBox(from, distanceKm)\n}\n\n\n/**\n * Create a bounding box from an Array of latlng locations\n *\n * @param locations location array to get the bbox from\n */\nexport function boundingBoxFromLocationArray<T extends LatLng>(locations: T[]): BoundingBox {\n  const bbox = locations.reduce((acc, val) => {\n    acc.northEast.lat = (val.lat > acc.northEast.lat) ? val.lat : acc.northEast.lat\n    acc.northEast.lng = (val.lng > acc.northEast.lng) ? val.lng : acc.northEast.lng\n    acc.southWest.lat = (val.lat < acc.southWest.lat) ? val.lat : acc.southWest.lat\n    acc.southWest.lng = (val.lng < acc.southWest.lng) ? val.lng : acc.southWest.lng\n    return acc\n  }, {\n      northEast: {\n        lat: locations[0].lat, lng: locations[0].lng\n      },\n      southWest: {\n        lat: locations[0].lat, lng: locations[0].lng\n      }\n    })\n  return bbox\n}\n\n\n/**\n * Creates a bounding box around a list location, with parameters about the distance calculated * (based on predefined internal logic)\n * from a give TravelOptions.\n * The bounding box returned will be the maximum bounding box that will include all bounding boxes generated for each location\n *\n * @param sources\n * @param options\n */\nexport function boundingBoxListWithinTravelOptions(sources: LatLng[], options: {\n  maxEdgeWeight: number,\n  edgeWeight: 'time' | 'distance',\n  travelType: TravelType\n}): BoundingBox {\n  const maxEdgeWeight = options.maxEdgeWeight\n  const speed: number = getSpeed(options)\n  const distanceKm = (options.edgeWeight === 'distance')\n    ? Math.round(maxEdgeWeight / 1000)\n    : (speed * maxEdgeWeight / 3600)\n\n  const boundingBoxResult = {\n    northEast: {\n      lat: -Infinity, lng: -Infinity\n    },\n    southWest: {\n      lat: Infinity, lng: Infinity\n    }\n  }\n\n  sources.forEach(source => {\n    const box = boundingBox(source, distanceKm)\n\n    boundingBoxResult.northEast.lat = Math.max(boundingBoxResult.northEast.lat, box.northEast.lat)\n    boundingBoxResult.northEast.lng = Math.max(boundingBoxResult.northEast.lng, box.northEast.lng)\n    boundingBoxResult.southWest.lat = Math.min(boundingBoxResult.southWest.lat, box.southWest.lat)\n    boundingBoxResult.southWest.lng = Math.min(boundingBoxResult.southWest.lng, box.southWest.lng)\n  })\n\n  return boundingBoxResult\n}\n\n/**\n * Given a list of locations return only those that are within `distanceKm` to any location in the\n * `from` list, and which are not included in the `from` locations\n *\n * @param locations\n * @param from\n * @param distanceKm\n */\nexport function locationsWithinDistance<T extends LatLng>(locations: T[], from: LatLng | LatLng[], distanceKm: number) {\n  if (from instanceof Array) {\n    return locationsWithinDistanceInclusive(locations, from, distanceKm).filter(location => !from.some(item => item == location))\n  } else {\n    return locationsWithinDistanceInclusive(locations, from, distanceKm).filter(location => from != location)\n  }\n}\n\n/**\n * Given a list of locations return only those that are within `distanceKm` to any location in the  `from` list\n *\n * @param locations\n * @param from\n * @param distanceKm\n */\nexport function locationsWithinDistanceInclusive<T extends LatLng>(locations: T[], from: LatLng | LatLng[], distanceKm: number) {\n  if (from instanceof Array) {\n    return locations.filter(location => from.some(point => calculateDistance(location, point) <= distanceKm))\n  } else {\n    return locations.filter(location => calculateDistance(location, from) <= distanceKm)\n  }\n}\n\n\n/**\n *\n * @param point\n * @param elevation\n */\nexport function webMercatorToLatLng(point: { x: number, y: number }, elevation: number) {\n  let latlng = projection.sphericalMercator.unproject(point)\n\n  if (elevation != undefined) {\n    // x,y,z given so we have elevation data\n    return { lat: latlng.lat, lng: latlng.lng, elevation }\n  } else {\n    // no elevation given, just unproject coordinates to lat/lng\n    return latlng\n  }\n}\n\n/**\n *\n * @param latlng\n */\nexport function latLngToWebMercator(latlng: LatLng) {\n  const point = projection.sphericalMercator.project(latlng)\n  // point.x *= 6378137\n  // point.y *= 6378137\n  return point\n}\n","import { BoundingBox } from '..';\n\nexport interface MultigraphInfo {\n\n  /**\n   * id of the multigraph\n   */\n  id?: number\n\n  /**\n   * Number of sources used in the MG layer\n   */\n  amountSources: number\n\n  /**\n   * one of(CERATED,ROUTING,MERGING,AGGREGATING,COMPLETED,FAILED)\n   */\n  status: MultigraphStatus\n\n  /**\n   * 0 when CREATED, 0-1 when ROUTING, 1 when MERGING,AGGREGATING,COMPLETED\n   */\n  routingProgress: number\n\n  /**\n   * if this list contains more than one elements the aggregation values \"may\" be not absolutely correct (due to merging of the graphs)\n   * - can be mitigated with executing \"redo\" (which completely restarts the whole process for the aggregation\n   * - this value is set in MERGING, AGGREGATING, and COMPLETED\n   */\n  baseGraphIds?: number[]\n\n  /**\n   * only set when FAILED\n   */\n  errorMessage?: string\n\n  /**\n   * only set when COMPLETED\n   */\n  minValue?: number\n\n  /**\n   * only set when COMPLETED\n   */\n  maxValue?: number\n\n\n  /**\n   * travelOptions, that were used for this request. (only if detailed flag is used)\n  */\n  travelOptions?: any\n\n  /**\n   * bbox of mg layer\n  */\n  boundingBox?: BoundingBox\n}\n\n/**\n * Lifecycle of a Multigraph:\n *\n * 1. CREATED\n * 2. ROUTING\n * 3. MERGING\n * 4. AGGREGATING\n * 5. COMPLETED / FAILED\n */\nexport enum MultigraphStatus {\n  CREATED = 'CREATED',\n  ROUTING = 'ROUTING',\n  MERGING = 'MERGING',\n  AGGREGATING = 'AGGREGATING',\n  COMPLETED = 'COMPLETED',\n  FAILED = 'FAILED'\n}\n","import * as geometry from '../../geometry'\nimport { TargomoClient } from '../../api/targomoClient';\nimport { LatLng } from '../types';\n\n/**\n * Represents a continuous segment of a route using one travel mode\n */\nexport class RouteSegment {\n  readonly type: string\n\n  readonly points: LatLng[]\n  readonly travelTime: number\n  readonly distance: number\n  readonly warning: string\n  readonly elevationGain: number\n  readonly transitSegment: boolean\n  readonly startName: string\n  readonly endName: string\n\n  readonly routeType: any\n  readonly routeShortName: string\n  readonly routeLongName: string\n  readonly departureTime: number\n  readonly arrivalTime: number\n  readonly tripHeadSign: string\n\n  constructor(client: TargomoClient, segment: any) {\n    this.points          = []\n    this.type            = segment.type\n    this.travelTime      = segment.travelTime\n\n    /*\n    * TODO don't call it length! in route length refers to the array length.\n    * Call it distance instead\n    */\n    this.distance        = segment.length / 1000\n    this.warning         = segment.warning\n    this.elevationGain   = segment.elevationGain\n    this.transitSegment  = false\n    this.startName       = segment.startname\n    this.endName         = segment.endname\n\n    // build the geometry\n    segment.points.forEach((point: number[]) => {\n      this.points.push(geometry.webMercatorToLatLng({x: point[1], y: point[0]}, point[2]))\n    })\n\n    // in case we have a transit route, we set information which are only available\n    // for transit segments like depature station and route short sign\n    if ( segment.isTransit ) {\n      this.transitSegment = true\n      this.routeType      = segment.routeType\n      this.routeShortName = segment.routeShortName\n      this.routeLongName  = segment.routeLongName\n      this.startName      = segment.startname\n      this.endName        = segment.endname\n      this.departureTime  = segment.departureTime\n      this.arrivalTime    = segment.arrivalTime\n      this.tripHeadSign   = segment.tripHeadSign\n    }\n  }\n}\n","import { RouteSegment } from './routeSegment'\nimport { LatLng } from '../index';\nimport { TargomoClient } from '../../api/targomoClient';\n\n/**\n *\n */\nexport class Route {\n  readonly travelTime: number\n  readonly routeSegments: RouteSegment[]\n  readonly points: LatLng[]\n  readonly uphillMeter: number\n  readonly downhillMeter: number\n  readonly targetHeight: number\n  readonly sourceHeight: number\n  readonly sourceId: any\n  readonly targetId: any\n  readonly length: number\n  readonly transfers: any\n\n  readonly departureTime: number\n  readonly arrivalTime: number\n\n  readonly totalElevationDifference: number\n  readonly distance: number\n  readonly elevationGain: number\n\n  constructor(client: TargomoClient, travelTime: number, segments: any[], meta: any) {\n    this.travelTime      = travelTime\n    this.routeSegments   = []\n    this.targetHeight    = undefined\n    this.sourceHeight    = undefined\n    this.sourceId        = undefined\n    this.targetId        = undefined\n    this.length          = undefined\n\n    let transfers = 0\n    let points: LatLng[] = []\n    // the server delivers the route from target to source\n    segments.reverse().forEach((segment) => {\n      let routeSegment = new RouteSegment(client, segment)\n      this.routeSegments.push(routeSegment)\n\n      if (routeSegment.type === 'TRANSFER') {\n        transfers++\n      }\n\n      points = points.concat(routeSegment.points.reverse())\n    })\n\n    this.points          = points\n    this.transfers       = transfers\n\n    if (typeof meta !== 'undefined') {\n        this.sourceId = meta.source_id\n        this.targetId = meta.target_id\n        this.length   = meta.length\n    }\n\n    const elevationDifferences = this.calculateElevationDifferences(this.points)\n\n    this.targetHeight = elevationDifferences.targetHeight\n    this.sourceHeight = elevationDifferences.sourceHeight\n    this.uphillMeter = elevationDifferences.uphillMeter\n    this.downhillMeter = elevationDifferences.downhillMeter\n\n    this.totalElevationDifference =  Math.abs(this.sourceHeight - this.targetHeight)\n\n    this.departureTime = this.calculateDepartureTime()\n    this.arrivalTime = this.calculateArrivalTime()\n    this.distance = this.calculateDistance()\n    this.elevationGain = this.calculateElevationGain()\n  }\n\n   private calculateDistance() {\n    let distance = 0\n    for (let i = 0; i < this.routeSegments.length; i++) {\n      distance += this.routeSegments[i].distance\n    }\n    return distance\n  }\n\n  private calculateElevationGain() {\n    let distance = undefined\n    for (let i = 0; i < this.routeSegments.length; i++) {\n      if (isFinite(this.routeSegments[i].elevationGain)) {\n        distance = (distance || 0) + this.routeSegments[i].elevationGain\n      }\n    }\n    return distance\n  }\n\n  // TODO: check again what this does\n  private calculateElevationDifferences(points: LatLng[]) {\n    let previousHeight = undefined\n\n    let targetHeight = undefined\n    let sourceHeight = undefined\n\n    let uphillMeter     = 0\n    let downhillMeter   = 0\n\n    for (let i = this.points.length - 1; i >= 0 ; i--) {\n      if (i == 0) {\n        targetHeight = this.points[i].elevation\n      }\n\n      if (i == this.points.length - 1) {\n        sourceHeight = this.points[i].elevation\n      }\n\n      if (typeof previousHeight != 'undefined') {\n        // we go up\n        if (previousHeight > this.points[i].elevation) {\n          uphillMeter += (previousHeight - this.points[i].elevation)\n        } else if ( previousHeight < this.points[i].elevation ) {\n          // and down\n          downhillMeter += (this.points[i].elevation - previousHeight)\n        }\n      }\n\n      previousHeight = this.points[i].elevation\n    }\n\n    return {targetHeight, sourceHeight, uphillMeter, downhillMeter}\n  } // check why this was like this in original\n\n  private calculateDepartureTime() {\n    let travelTime = 0\n\n    for (let i = 0; i < this.routeSegments.length; i++) {\n      let segment = this.routeSegments[i]\n\n      if (segment.departureTime != null) {\n        return (segment.departureTime - travelTime)\n      } else {\n        travelTime += (segment.travelTime || 0)\n      }\n    }\n\n    return undefined\n  }\n\n  private calculateArrivalTime() {\n    let travelTime = 0\n\n    for (let i = this.routeSegments.length - 1; i >= 0; i--) {\n      let segment = this.routeSegments[i]\n\n      if (segment.arrivalTime != null) {\n        return (segment.arrivalTime + travelTime)\n      } else {\n        travelTime += (segment.travelTime || 0)\n      }\n    }\n\n    return undefined\n  }\n}\n","import {StatisticsItem, StatisticsList, StatisticValues} from '../types'\n\nexport class StatisticsResult {\n  readonly statistics: StatisticsList\n  readonly individualStatistics: {[id: string]: StatisticsList}\n  readonly raw: any\n\n  constructor(result: any, statistics: StatisticsItem[]) {\n    function dataToStatisticgroup(values: any) {\n      const statisticsGroup: StatisticsList = {}\n\n      // Convert to map of named statistics, instead of index based ones\n      for (let statistic of statistics) {\n        statisticsGroup[statistic.name] = new StatisticValues(values[statistic.id])\n      }\n\n      return statisticsGroup\n    }\n\n    const individualStatistics: {[id: string]: StatisticsList} = {}\n    if (result.individualStatistics) {\n      for (let key in result.individualStatistics) {\n        if (result.individualStatistics[key] && result.individualStatistics[key].statistics) {\n          individualStatistics[key] = dataToStatisticgroup(result.individualStatistics[key].statistics)\n        }\n      }\n    }\n\n    this.statistics = dataToStatisticgroup(result.statistics),\n    this.individualStatistics = individualStatistics,\n    this.raw = result\n  }\n}\n","import { FpVehicle, FpStore, FpAddress, FpOrder, FpTransport } from './../types';\nimport { FeatureCollection, LineString } from 'geojson';\nimport { FpRequestPayload, FpRequestMetadata } from '../../api/payload/fleetsRequestPayload';\n\n/**\n * @General The reponse of the request if the optimization was successfully carried out. It contains the original request body information\n * (plus potential mitigated values). The result of the fleet planning optimization is stored in \"tours\" and additional helpful information\n * with regards to the execution (e.g. messages, mitigated errors) are stored in \"resultStatus\".\n * All elements in the return body (including stores, orders, transports) now have an id field which can be ignored by the client.\n */\nexport class FpResult implements FpRequestPayload {\n    optimizationTime: number;\n    optimizationAlgorithm: 'NO_OPTIMIZATION' | 'GREEDY_TSP' | 'BRUTE_FORCE_TSP' | 'CONSTRAINT_SATISFACTION';\n    optimizationMetadata: FpRequestMetadata;\n    stores: FpStore[];\n    transports: FpTransport[];\n    orders: FpOrder[];\n    /**\n     * @General The ResultStatus contains errors that occurred during the evaluation, but could be mitigated by standard routines.\n     */\n    resultStatus: ResultStatus;\n    /**\n     * @General The main result of the optimizazion. For the available vehicles/transports tours are created that are optimized for fitting\n     * the weight and volume into the respective vehicles, for meeting as many as possible deadlines, and for having the shortest (quickest)\n     * overall tour durations (in that order).\n     */\n    tours: FpTour[];\n}\n\n/**\n * @General The ResultStatus contains errors that occurred during the evaluation, but could be mitigated by standard routines.\n * @Exceptions If the optimization request responds with status code 201, there were no errors and the optimization could be performed\n * without any ’intervention/assumptions’.\n * In 'messages' extra information about the time consumption of the individual steps of the optimization can be found.\n * If the server had to make any interventions or assumptions to correct the problem, the response status code of the request is\n * 202 and the mitigations are noted in ResultStatus.\n * The optimization result is transmitted in exactly the same way as with a 201 response, but now with the additional information,\n * which errors have occurred and how they were ’repaired’.\n * Examples of recoverable errors are:\n * If no geo-data was found for an address (i.e. no data was available or could be obtained via the geocoding service)\n * the order is removed from the query, or if no start address were specified for a transport, the home address of the vehicle is\n * assumed to be the starting point. If errors were encountered that could not be \"corrected\" (e.g., syntax errors, external service\n * errors), the request will fail.\n */\nexport interface ResultStatus {\n\n    /**\n     * @General Overall result of the optimization if successful - NO_ERRORS_RECORDED and result status 201 or\n     * ERRORS_RECORDED and result status 202\n     */\n    overall: 'NO_ERRORS_RECORDED' | 'ERRORS_RECORDED';\n    /**\n     * @General The problems that occurred during the optimization but could be mitigated.\n     * If such Mitigation Errors occur the service reponds with a reuslt und the status code 202.\n     */\n    errors?: MitigatedError[];\n    /**\n     * @General Standard messages like how much time different steps of the optimization have consumed.\n     */\n    messages?: string[];\n}\n\n/**\n * @General The problems that occurred during the optimization but could be mitigated.\n * If such Mitigation Errors occur the service reponds with a reuslt und the status code 202.\n */\nexport interface MitigatedError {\n    /**\n     * @General The request field that had to be adapted, e.g. \"transports[0].metadata.start\" if no start address was given for a tranpsort.\n     */\n    affectedField: string;\n    /**\n     * @General The detailed the description of the error,\n     * e.g. \"start point has to be equal to the address of the store referenced in the vehicle\"\n     */\n    errorDescription: string;\n    /**\n     * @Genral The detailed the description of the error mitigation,\n     * e.g. \"Start address has been set to the address of the store referenced in the vehicle\"\n     */\n    mitigationDescription: string;\n    /**\n     * @General If applicable the original value that had to be adapted,\n     * e.g. the old address that was replaced as part of the mitigation strategy. Can be empty depending on the error and/or mitigation.\n     */\n    original: any;\n}\n\n/**\n * @General The main result of the optimizazion. For the available vehicles/transports tours are created that are optimized for fitting\n * the load into the respective vehicles, for meeting as many as possible time requirements, and for having the shortest (quickest) overall\n * tour durations (in that order).\n */\nexport interface FpTour {\n    /**\n     * @General An estimation of the travel time of the tour in seconds - only the time travelled.\n     */\n    durationTravel: number;\n    /**\n     * @General An estimation of the non-travel time of this tour in seconds, e.g. on-site handling.\n     */\n    durationHandling: number;\n    /**\n     * @General The expected time and date when the tour will start.\n     * Usually equal to the earliestStartDate specified in the transportMetadata.\n     * @Format Expressed according to ISO 8601.\n     */\n    expectedTourStartDate: string;\n    /**\n     * @General The expected time and date when the tour will end.\n     * @Format Expressed according to ISO 8601.\n     */\n    expectedTourEndDate: string;\n    /**\n     * @General Length of the tour in meters. This value can only be set if \"ROUTING_SERVICE\" was chosen for \"geojsonCreation\".\n     */\n    routeLength?: number;\n    /**\n     * @General The sum of any load specified in the orders.\n     * @Example\n     * ``` js\n     * loadSum = {\n     *   weight: 123.1,\n     *   volume: 2005.0\n     * }\n     * ```\n     */\n    loadSum?: {[key: string]: number}\n    /**\n     * @General Overall number of Orders/TourItems contained in this tour.\n     */\n    size: number;\n    /**\n     * @General Total volume of all orders serviced by this tour\n     */\n    store: FpStore;\n    /**\n     * @General The vehicle used to travel this tour.\n     */\n    vehicle: FpVehicle;\n    /**\n     * @General Each Tour consists of multiple TourItems which each represent the servicing of one of the \"orders\".\n     */\n    tourItems: FpTourItem[];\n    /**\n     * @General The location from which the vehicle starts its tour.\n     */\n    tourStart: FpAddress;\n    /**\n     * @General One of the possible endDestinations defined in the TransportMetadata.\n     * Can also be empty if no endDestination for this tour's vehicle was defined.\n     */\n    tourEnd?: FpTourStop;\n\n    /**\n     * @General The FeatureCollection element can be optionally returned for debugging purposes. It contains the calculated tour including\n     * the routes between the individual targets formatted as GeoJSON. The start and end points of the individual routes are represented as\n     * Point and the routes between them as LineString. The data can be uploaded and visualized locally (e.g. with QGIS) or via Internet\n     * (e.g. with http://geojson.io). The geojsonCreation option in OptimizationMetadata can be used to specify if and how the geojson data\n     * is generated.\n     * @Format RFC 7946, https://tools.ietf.org/html/rfc7946\n     */\n    featureCollection: FeatureCollection<LineString>;\n}\n\n/**\n * @General Each Tour consists of multiple TourItems which each represent the servicing of one of the \"orders\".\n * Note: expectedArrival <= expectedStartVisit < expectedDeparture\n */\nexport interface FpTourItem {\n    /**\n     * @General Route distance from the last tour stop to this stop in meters.\n     * Distance is only set if \"ROUTING_SERVICE\" is chosen for \"geojsonCreation\".\n     */\n    distance?: number;\n    /**\n     * @General Time duration it takes from the latest tour stop to this stop in seconds.\n     */\n    duration: number;\n    /**\n     * @General Expected arrival date and time for this stop.\n     */\n    expectedArrival: string;\n    /**\n     * @General The order which will be serviced.\n     */\n    order: FpOrder;\n    /**\n     * @General Ordered index within the tour, e.g. the first element of the tour has index 0, the second has index 1, and so on.\n     */\n    index: number;\n    /**\n     * @General Expected departure date and time for this stop.\n     * @Format Expressed according to ISO 8601.\n     */\n    expectedDeparture: string;\n    /**\n     * @General Expected start of the visit. this can diverge from the expectedArrivalTime due to waiting for the next start of a visiting\n     * time window of the associated order. This waiting time is added to the travel costs (excluding the interruptions that occurre\n     * during that time).\n     * @Format Expressed according to ISO 8601.\n     */\n    expectedStartVisit: string;\n    /**\n     * @General Time in seconds that were still to spare from arrival until the deadline.\n     * This can be negative if the deadline was missed.\n     */\n    spareTime: number;\n\n    /**\n     * @General If interruptions defined in the vehicle occur during this part (tourItem) of the tour they are contained in this list.\n     * An interruption can only be during travel (type=INTERRUPT_TRAVEL) or before the start of the visit (type=INTERRUPT_WAITING).\n     */\n    interruptions?: {start: string, end: string, type: 'INTERRUPT_TRAVEL' | 'INTERRUPT_WAITING'}[]\n}\n\n/**\n * @General One of the possible endDestinations defined in the TransportMetadata.\n * Can also be empty if no endDestination for this tour's vehicle was defined.\n */\nexport interface FpTourStop {\n    /**\n     * @General Route distance from the last tour stop to this stop in meters.\n     * Distance is only set if \"ROUTING_SERVICE was\" chosen for \"geojsonCreation\".\n     */\n    distance?: number;\n    /**\n     * @General Time duration it takes from the latest tour stop to this stop in seconds.\n     */\n    duration: number;\n    /**\n     * @General Expected arrival date and time for this stop.\n     * @Format Expressed according to ISO 8601.\n     */\n    expectedArrival: string;\n    /**\n     * The address of the chosen endDestination as defined in the transportMetadata.\n     */\n    order: FpOrder;\n}\n","import { StatisticsItem } from '../types';\n\nexport interface StatisticsGeometryResultItem {\n  value: number\n}\n\nexport interface StatisticsGeometryResultStatistic {\n  [index: string]: StatisticsGeometryResultItem\n}\n\nexport class StatisticsGeometryResult {\n  readonly raw: any\n  readonly values: {\n    min?: StatisticsGeometryResultStatistic\n    max?: StatisticsGeometryResultStatistic\n    avg?: StatisticsGeometryResultStatistic\n    sum?: StatisticsGeometryResultStatistic\n    count?: StatisticsGeometryResultStatistic\n    stddev?: StatisticsGeometryResultStatistic\n    variance?: StatisticsGeometryResultStatistic\n  } = {}\n\n  constructor(result: any[], statistics: StatisticsItem[]) {\n    const statsticsMap: {[index: number]: string} = {}\n    statistics.forEach(statistic => {\n      statsticsMap[statistic.id] = statistic.name\n    })\n\n    this.raw = result\n    const values: any = this.values\n\n    for (let key in result) {\n      const row: any = result[key]\n      const aggregationKey = (row.aggregation || '').toLowerCase()\n      values[aggregationKey] = values[aggregationKey] || {}\n\n      const statistic = statsticsMap[row.statisticId]\n      values[aggregationKey][statistic] = {value: row.value}\n    }\n  }\n}\n","import { LatLngId, SRID} from '../../types';\nimport { TargomoClient } from '../targomoClient';\nimport { PolygonRequestOptions } from '../../types/options/polygonRequestOptions';\nimport {TravelRequestPayload} from './travelRequestPayload'\n\nexport interface PolygonSvgOptions extends PolygonRequestOptions {\n  serializer: 'json'\n}\n\nexport interface PolygonGeoJsonOptions extends PolygonRequestOptions {\n  serializer: 'geojson'\n}\n\nexport class PolygonPayloadOptions {\n  minPolygonHoleSize: number = 10000000\n  buffer: number = 50\n  simplify: number = 50\n  srid: SRID = SRID.SRID_4326\n\n  format?: string\n  quadrantSegments: number = 2\n\n  serializer: 'json' | 'geojson'\n  intersectionMode: 'average' | 'union' | 'intersection' | 'none' = 'union'\n  decimalPrecision: number = 6\n\n  values: number[]\n}\n\nexport class PolygonRequestPayload extends TravelRequestPayload {\n  polygon = new PolygonPayloadOptions()\n\n  constructor(client: TargomoClient, sources: LatLngId[], options: PolygonSvgOptions|PolygonGeoJsonOptions) {\n    super(<any>options)\n\n    this.sources = this.buildSourcesCfg(sources)\n    this.polygon.values = options.travelEdgeWeights\n    this.polygon.serializer = options.serializer\n    this.polygon.simplify = options.simplify\n    this.polygon.srid = options.srid\n    this.polygon.buffer = options.buffer\n    this.polygon.minPolygonHoleSize = options.minPolygonHoleSize\n    this.polygon.quadrantSegments = options.quadrantSegments\n    this.polygon.intersectionMode = options.intersectionMode\n    this.polygon.decimalPrecision = options.decimalPrecision\n  }\n}\n","\nimport * as geometry from '../geometry/projection'\nimport { PolygonData } from './responses/polygonSvgResult';\n\nexport interface ProjectedBoundsData {\n  southWest: ProjectedPointData\n  northEast: ProjectedPointData\n}\n\n/**\n *\n */\nexport class ProjectedBounds implements ProjectedBoundsData {\n  southWest: ProjectedPoint = new ProjectedPoint(Infinity, Infinity)\n  northEast: ProjectedPoint = new ProjectedPoint(-Infinity, -Infinity)\n\n  constructor(bounds?: {\n    southWest: {x: number, y: number}\n    northEast: {x: number, y: number}\n  }) {\n    if (bounds) {\n      this.southWest = new ProjectedPoint(bounds.southWest.x, bounds.southWest.y)\n      this.northEast = new ProjectedPoint(bounds.northEast.x, bounds.northEast.y)\n    }\n  }\n\n  expandPoint(x: number, y: number) {\n    this.southWest.x = Math.min(this.southWest.x, x)\n    this.northEast.x = Math.max(this.northEast.x, x)\n    this.southWest.y = Math.min(this.southWest.y, y)\n    this.northEast.y = Math.max(this.northEast.y, y)\n  }\n\n  expand(bounds: ProjectedBoundsData) {\n    this.expandPoint(bounds.northEast.x, bounds.northEast.y)\n    this.expandPoint(bounds.southWest.x, bounds.southWest.y)\n  }\n}\n\nexport interface ProjectedPointData {\n  x: number\n  y: number\n}\n\n/**\n *\n */\nexport class ProjectedPoint implements ProjectedPointData {\n  constructor(public x: number, public y: number) {}\n}\n\n/**\n *\n */\nexport class ProjectedLineString {\n  points: ProjectedPointData[]\n  bounds3857: ProjectedBounds = new ProjectedBounds()\n\n  constructor(coordinates: [number, number][]) {\n    this.points = coordinates.map(coordinate => {\n      this.bounds3857.expandPoint(coordinate[0], coordinate[1])\n      const pair = geometry.sphericalMercator.project({ lat: coordinate[0], lng: coordinate[1] })\n      return new ProjectedPoint(pair.x, pair.y)\n    })\n  }\n}\n\n/**\n *\n */\nexport class ProjectedPolygon {\n  travelTime: number\n  area: number\n  lineStrings: ProjectedLineString[]\n  bounds3857: ProjectedBounds = new ProjectedBounds()\n\n  constructor(data: PolygonData) {\n    this.travelTime = data.travelTime\n    this.area = data.area\n\n    this.lineStrings = [new ProjectedLineString(data.outerBoundary)]\n    this.bounds3857.expand(this.lineStrings[0].bounds3857)\n\n    if (data.innerBoundary) {\n      data.innerBoundary.forEach(innerBoundary => {\n        const lineString = new ProjectedLineString(innerBoundary)\n        this.lineStrings.push(lineString)\n        this.bounds3857.expand(lineString.bounds3857)\n      })\n    }\n  }\n}\n","import { TargomoClient } from './targomoClient'\nimport { LatLngId } from '../index';\nimport { PolygonRequestOptions } from '../types/options/polygonRequestOptions';\nimport { PolygonRequestPayload, PolygonGeoJsonOptions, PolygonSvgOptions } from './payload/polygonRequestPayload';\nimport { UrlUtil } from '../util/urlUtil';\nimport { requests} from '../util/requestUtil';\nimport { PolygonSvgResult, PolygonData } from '../types/responses/polygonSvgResult';\nimport { FeatureCollection, MultiPolygon } from 'geojson';\nimport { ProjectedPolygon, ProjectedBounds } from '../types/projectedPolygon';\nimport { webMercatorToLatLng, boundingBoxFromLocationArray } from '../geometry';\nimport { BoundingBox, LatLng } from '../types';\n\n\n/**\n * @Topic Polygons\n */\nexport class PolygonsClient {\n  constructor(private client: TargomoClient) {\n  }\n  /**\n   * Request geojson polygons for one or more sources from r360 service\n   * @param sources\n   * @param options\n   */\n  async fetch(sources: LatLngId[], options: PolygonGeoJsonOptions): Promise<FeatureCollection<MultiPolygon>>;\n\n\n  /**\n   * Request svg polygons for one or more sources from r360 service\n   * @param sources\n   * @param options\n   */\n  async fetch(sources: LatLngId[], options: PolygonSvgOptions): Promise<PolygonArray>;\n\n  async fetch(sources: LatLngId[], options: PolygonSvgOptions|PolygonGeoJsonOptions):\n    Promise<PolygonArray | FeatureCollection<MultiPolygon>> {\n      const cfg = new PolygonRequestPayload(this.client, sources, options)\n      const result = await this._executeFetch(sources, options, cfg);\n      if (options.serializer === 'json') {\n        // const boundedResults = (result as PolygonSvgResult[]).map((polygons: any) => new BoundedPolygonSvgResult(polygons))\n        const boundedPolys = PolygonArray.create(result, result.metadata);\n        return boundedPolys;\n      } else if (options.serializer === 'geojson') {\n        return result as FeatureCollection<MultiPolygon>;\n      }\n  }\n\n  private async _executeFetch(sources: LatLngId[], options: PolygonRequestOptions, cfg: PolygonRequestPayload): Promise<any> {\n\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .part(this.client.serviceUrl)\n      .version()\n      .part('/polygon')\n      .key()\n      .toString();\n\n    const result = await requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg);\n    result.metadata = options\n    return result\n  }\n}\n\n/**\n * Class to extend Array for polygons result to add maxBounds method to array results\n */\nexport class PolygonArray extends Array<PolygonSvgResult> {\n  private constructor(items?: Array<PolygonSvgResult>) {\n    super(...items)\n  }\n  static create(items: Array<PolygonSvgResult>, metadata?: any): PolygonArray {\n    const newProto = Object.create(PolygonArray.prototype);\n    (items as PolygonSvgResult[]).forEach((polygons: any) => newProto.push(polygons))\n    if (metadata) {\n      newProto.metadata = metadata;\n    }\n    return newProto;\n  }\n\n  getMaxBounds(): BoundingBox {\n    let boundsPoints: LatLng[] = []\n    this.forEach((svgPolygons: PolygonSvgResult) => {\n      let bounds3857: ProjectedBounds;\n      svgPolygons.polygons.forEach((polygonData: PolygonData) => {\n        const polygon = new ProjectedPolygon(polygonData)\n        if (bounds3857) {\n          bounds3857.expand(polygon.bounds3857)\n        } else {\n          bounds3857 = polygon.bounds3857\n        }\n      })\n\n      boundsPoints.push(webMercatorToLatLng(bounds3857.northEast, null));\n      boundsPoints.push(webMercatorToLatLng(bounds3857.southWest, null));\n    });\n    return boundingBoxFromLocationArray(boundsPoints);\n  }\n}\n","import { LatLngId} from '../../types'\nimport { TargomoClient } from '../targomoClient'\nimport { TimeRequestOptions } from '../../types/options'\nimport {TravelRequestPayload} from './travelRequestPayload'\n\nexport class TimeRequestPayload extends TravelRequestPayload {\n\n  constructor(client: TargomoClient, sources: LatLngId[], targets: LatLngId[], options: TimeRequestOptions) {\n    super(options)\n    this.sources = this.buildSourcesCfg(sources)\n    this.targets = this.buildTargetsCfg(targets)\n  }\n}\n","import { TargomoClient } from './targomoClient'\nimport { LatLngId, LatLngIdTravelTime, LatLngIdTravelMode, TimeResult, ReachabilityResult } from '../index';\nimport { requests} from '../util/requestUtil';\nimport { TimeRequestOptions } from '../types/options/timeRequestOptions';\nimport { TimeRequestPayload } from './payload/timeRequestPayload';\nimport { UrlUtil } from '../util/urlUtil';\n\n// TODO: decide on method names...or keep previous names\n/**\n * @Topic Reachability\n */\nexport class ReachabilityClient {\n  constructor(private client: TargomoClient) {\n  }\n\n  /**\n   *\n   * @param sources\n   * @param targets\n   * @param options\n   */\n  async individual(sources: LatLngIdTravelMode[], targets: LatLngId[], options: TimeRequestOptions): Promise<TimeResult[]> {\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .part(this.client.serviceUrl)\n      .version()\n      .part('/time')\n      .key()\n      .toString();\n\n    const cfg = new TimeRequestPayload(this.client, sources, targets, options)\n    return await requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg)\n  }\n\n\n  /**\n   * Makes a reachability request to the r360 services, and returns the raw results of the request\n   *\n   * @param sources\n   * @param targets\n   * @param options\n   */\n  async combined(sources: LatLngId[], targets: LatLngId[], options: TimeRequestOptions): Promise<ReachabilityResult[]> {\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .part(this.client.serviceUrl)\n      .version()\n      .part('/reachability')\n      .key()\n      .toString();\n\n    const cfg = new TimeRequestPayload(this.client, sources, targets, options)\n    // TODO: add timeout\n    return await requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg)\n  }\n\n  /**\n   * Makes a reachability request to the r360 services and returns the number of locations that are reachable within the given parameters\n   *\n   * @param sources\n   * @param targets\n   * @param options\n   */\n  async count(sources: LatLngId[], targets: LatLngId[], options: TimeRequestOptions): Promise<number> {\n    // TODO: sopmething like this was used somewhere think\n    // (maybe autoprop)....however since it is trivial...maybe we should not have it anymore\n    return (await this.locations(sources, targets, options)).length\n  }\n\n  /**\n   * Makes a reachability requests to the r360 services and returns the input targets decorated with the resulting travel time\n   *\n   * @param sources\n   * @param targets\n   * @param options\n   */\n  async locations<T extends LatLngIdTravelTime>(sources: LatLngId[],\n                                                            targets: T[],\n                                                            options: TimeRequestOptions): Promise<T[]> {\n    const map: any = {}\n    targets.forEach(place => map[String(place.id)] = -1)\n\n    const response: any[] = await this.combined(sources, targets, options)\n    response.forEach(target => {\n      const id = String(target.id)\n      if (!map[id]) {\n        console.warn('NOT FOUND', String(target.id))\n      } else {\n        if (target.travelTime > -1) {\n          if (map[id] > -1) {\n            map[id] = Math.min(map[id], target.travelTime)\n          } else {\n            map[id] = target.travelTime\n          }\n        }\n      }\n    })\n\n    return (<T[]>targets).filter(place => {\n      const id = String(place.id)\n      place.travelTime = map[id]\n      return map[id] > -1\n    })\n  }\n\n}\n","import { LatLngId} from '../../types'\nimport { TargomoClient } from '../targomoClient'\nimport { RouteRequestOptions } from '../../types/options'\nimport { TravelRequestPayload } from './travelRequestPayload';\n\nexport interface RouteCompactOptions extends RouteRequestOptions {\n  pathSerializer: 'compact'\n}\n\nexport interface RouteGeoJsonOptions extends RouteRequestOptions {\n  pathSerializer: 'geojson'\n}\n\nexport class RouteRequestPayload extends TravelRequestPayload {\n\n  pathSerializer?: 'compact' | 'geojson'\n\n  constructor(client: TargomoClient, sources: LatLngId[], targets: LatLngId[], options: RouteCompactOptions|RouteGeoJsonOptions) {\n    super(options)\n    this.sources = this.buildSourcesCfg(sources)\n    this.targets = this.buildTargetsCfg(targets)\n    this.pathSerializer = options.pathSerializer;\n\n    if (typeof options.recommendations === 'boolean') {\n      options.recommendations = options.recommendations ? 1 : 0\n    }\n    if (Number.isInteger(options.recommendations) && this.sources) {\n      this.sources.forEach((source: any) => {\n        if (source.tm != null) {\n          for (let mode in source.tm) {\n            source.tm[mode].recommendations = options.recommendations\n          }\n        }\n      })\n    }\n  }\n}\n","import { TargomoClient } from './targomoClient'\nimport { LatLngIdTravelMode, LatLngId } from '../index';\nimport { RouteRequestOptions } from '../types/options/routeRequestOptions';\nimport { Route } from '../types/responses/route';\nimport { requests } from '../util/requestUtil';\nimport { UrlUtil } from '../util/urlUtil';\nimport { RouteRequestPayload, RouteGeoJsonOptions, RouteCompactOptions } from './payload/routeRequestPayload';\nimport { FeatureCollection, LineString, Point } from 'geojson';\n\n/**\n * @Topic Routes\n */\nexport class RoutesClient {\n  constructor(private client: TargomoClient) {\n  }\n\n  async fetch(sources: LatLngIdTravelMode[], targets: LatLngId[], options: RouteGeoJsonOptions):\n    Promise<FeatureCollection<LineString|Point>[]>;\n\n  async fetch(sources: LatLngIdTravelMode[], targets: LatLngId[], options: RouteCompactOptions):\n    Promise<Route[]>;\n\n  async fetch(sources: LatLngIdTravelMode[], targets: LatLngId[], options: RouteGeoJsonOptions|RouteCompactOptions):\n    Promise<Route[] | FeatureCollection<LineString|Point>[]> {\n\n    const cfg = new RouteRequestPayload(this.client, sources, targets, options)\n    const result = await this._executeFetch(sources, targets, options, cfg);\n\n    if (!options.pathSerializer || options.pathSerializer === 'compact') {\n      return result.routes.map((meta: any) => {\n        return new Route(this.client, meta.travelTime, meta.segments, meta)\n      })\n    } else if (options.pathSerializer === 'geojson') {\n      return result.routes;\n    }\n  }\n\n  private async _executeFetch(sources: LatLngIdTravelMode[], targets: LatLngId[], options: RouteRequestOptions, cfg: RouteRequestPayload):\n    Promise<{routes: any}> {\n\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .part(this.client.serviceUrl)\n      .version()\n      .part('/route')\n      .key()\n      .toString();\n\n    const result = await requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg, {\n      // Headers are here because something needs to be fixed in the service endpoint\n      'Accept': 'application/json,application/javascript,*/*'\n    })\n\n    return result\n  }\n}\n\n","import { TargomoClient } from './targomoClient'\nimport { StatisticsGroupId, SimilarityCriteria, BoundingBox, UrlUtil } from '../index';\nimport { requests} from '../util/requestUtil';\n\n/**\n * @Topic Similarity\n */\nexport class SimilarityClient {\n  constructor(private client: TargomoClient) {\n  }\n\n\n  /**\n   *\n   */\n  async metadata(key: StatisticsGroupId): Promise<any[]> {\n\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.tilesUrl)\n      .part('similarity/meta/')\n      .version()\n      .part('/' + encodeURIComponent('' + key))\n      .key()\n      .toString();\n\n    return await requests(this.client).fetch(url)\n  }\n\n  /**\n   *\n   */\n  async fetch(group: StatisticsGroupId,\n    cell: number,\n    conditions: SimilarityCriteria[],\n    bounds: BoundingBox,\n    normalizeOnViewport: boolean): Promise<any> {\n\n  // TODO: have a \"Payload\" object\n    const boundsData = {\n      'west': bounds.southWest.lng,\n      'south': bounds.southWest.lat,\n      'east': bounds.northEast.lng,\n      'north': bounds.northEast.lat\n    }\n\n    const data = {\n      bounds: boundsData,\n      refCellId: cell,\n      scores: conditions.map(item => ({\n        source: item.source,\n        minutes: item.minutes,\n        factor: item.factor || 1\n      }))\n    }\n\n    const urlObject = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.tilesUrl)\n      .part('similarity/scores_cumulative/')\n      .version()\n      .part('/' + encodeURIComponent('' + group))\n      .key();\n    const url = normalizeOnViewport ? urlObject.params({normalizeOnViewport: !!normalizeOnViewport}).toString() : urlObject.toString();\n\n    return await requests(this.client).fetch(url, 'POST', data)\n  }\n}\n","import { LatLngId, TravelType } from '../../types';\nimport { StatisticsRequestOptions, StatisticsTravelRequestOptions } from '../../types/options/statisticsRequestOptions'\nimport { TargomoClient } from '../targomoClient';\n\nfunction isStatisticsRequestOptions(value: StatisticsRequestOptions | StatisticsTravelRequestOptions): value is StatisticsRequestOptions {\n  return (<any>value).statistics\n}\n\nexport class StatisticsRequestPayload {\n  statisticIds: number[]\n  statisticGroupId: number\n  inactiveSources: { id: string, x: number, y: number }[] = []\n  getClosestSources: boolean = false\n  serviceKey: string\n  serviceUrl: string\n  useCache: boolean\n  iFeelLucky: boolean\n  omitIndividualStatistics: boolean\n  sources: { id: string, x: number, y: number }[]\n  travelType: TravelType\n  edgeWeight: 'time' | 'distance'\n  maxEdgeWeight: number\n  frame: number\n  time: number\n  date: number\n  maxTransfers: number\n  maxWalkingTimeFromSource: number\n  avoidTransitRouteTypes: number[]\n  rushHour: boolean\n\n  constructor(client: TargomoClient, sources: LatLngId[], options: StatisticsRequestOptions | StatisticsTravelRequestOptions) {\n\n    this.serviceUrl = client.serviceUrl;\n    this.serviceKey = client.serviceKey;\n    this.useCache = options.useCache == undefined ? true : options.useCache\n    this.sources = sources.map(source => ({id: source.id, y: source.lat, x: source.lng}))\n    this.iFeelLucky = options.iFeelLucky;\n    this.travelType = options.travelType;\n    this.edgeWeight = options.edgeWeight;\n    this.maxEdgeWeight = options.maxEdgeWeight;\n    this.frame = options.transitFrameDuration;\n    this.time = options.transitFrameTime;\n    this.date = options.transitFrameDate;\n    this.maxTransfers = options.transitMaxTransfers;\n    this.maxWalkingTimeFromSource = options.transitMaxWalkingTimeFromSource;\n    this.avoidTransitRouteTypes = options.transitAvoidTransitRouteTypes;\n    this.rushHour = options.rushHour;\n\n    if (options.inactiveSources) {\n      this.inactiveSources = options.inactiveSources.map(source => ({id: source.id, y: source.lat, x: source.lng}))\n    }\n\n    let statisticsIndices: number[] = []\n\n    if (isStatisticsRequestOptions(options)) {\n      this.omitIndividualStatistics = options.omitIndividualStatistics\n      statisticsIndices = options.statistics.map(statistic => {\n        if (statistic instanceof Number || typeof statistic === 'number') {\n          return +statistic\n        } else {\n          return statistic.id\n        }\n      })\n    }\n\n    this.statisticGroupId = +options.statisticsGroup\n    this.statisticIds = statisticsIndices\n\n    if (options.closestSources) {\n      this.getClosestSources = true\n    }\n\n  }\n}\n","import { StatisticsGeometryRequestOptions } from '../../types/options/statisticsRequestOptions'\nimport { TargomoClient } from '../targomoClient';\n\nexport class StatisticsGeometryRequestPayload {\n  statisticIds: number[]\n  statisticGroupId: number\n  intersectionGeometry: {data: string, crs: number}\n\n  constructor(client: TargomoClient, geometry: string, options: StatisticsGeometryRequestOptions) {\n\n    let statisticsIndices: number[] = options.statistics.map(statistic => {\n      if (statistic instanceof Number || typeof statistic === 'number') {\n        return +statistic\n      } else {\n        return statistic.id\n      }\n    })\n\n    this.statisticGroupId = +options.statisticsGroup\n    this.statisticIds = statisticsIndices\n\n    this.intersectionGeometry = {\n      data: geometry,\n      crs: options.crs || 4326\n    }\n  }\n}\n","import { TargomoClient } from './targomoClient'\nimport {\n  LatLngId,\n  StatisticsList,\n  ReachableTile,\n  StatisticsGroupMeta,\n  StatisticsGroupId,\n  StatisticsItem,\n  StatisticsItemMeta,\n  StatisticsRequestOptions,\n  StatisticsTravelRequestOptions,\n  StatisticsGeometryRequestOptions,\n  StatisticsGroupEnsemble,\n  UrlUtil\n} from '../index';\nimport { StatisticsRequestPayload } from './payload/statisticsRequestPayload';\nimport { StatisticsResult } from '../types/responses/index';\nimport { requests } from '../util/requestUtil';\nimport { SimpleLRU } from '../util/cache';\nimport { StatisticsGeometryRequestPayload } from './payload/statisticsGeometryRequestPayload';\nimport { StatisticsGeometryResult } from '../types/responses/statisticsGeometryResult';\n\n/**\n * @Topic Statistics\n */\nexport class StatisticsClient {\n  private statisticsMetadataCache = new SimpleLRU<StatisticsGroupMeta>(200)\n  private statisticsEnsemblesCache = new SimpleLRU<{[id: string]: StatisticsGroupEnsemble}>(200)\n\n  constructor(private client: TargomoClient) {\n  }\n\n  /**\n   *\n   * @param sources\n   * @param options\n   */\n  async combined(sources: LatLngId[], // sources: LatLng[],\n    options: StatisticsRequestOptions): Promise<StatisticsList> {\n    const result = await this.dependent(sources, options)\n    return result && result.statistics\n  }\n\n  /**\n  * Make a statistics request to the r360 services\n  */\n  async individual(sources: LatLngId[], // sources: LatLng[],\n    options: StatisticsRequestOptions): Promise<{ [id: string]: StatisticsList }> {\n    const result = await this.dependent(sources, options)\n    return result && result.individualStatistics\n  }\n\n\n  /**\n  * Make a statistics request to the r360 services\n  */\n  async travelTimes(sources: LatLngId[], options: StatisticsTravelRequestOptions): Promise<ReachableTile> {\n    if (!sources.length) {\n      return null\n    }\n\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.statisticsUrl)\n      .part('traveltimes')\n      .params({\n        serviceUrl: this.client.serviceUrl\n      })\n      .toString();\n\n    return await requests(this.client, options).fetch(url, 'POST', new StatisticsRequestPayload(this.client, sources, options))\n  }\n\n  /**\n   *\n   * @param sources\n   * @param options\n   */\n  async dependent(sources: LatLngId[], // was LatLng[]\n    options: StatisticsRequestOptions): Promise<StatisticsResult> {\n\n    if (!sources.length) {\n      return null\n    }\n\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.statisticsUrl)\n      .part('charts/dependent')\n      .params({\n        serviceUrl: this.client.serviceUrl\n      })\n      .toString();\n\n    const result = await requests(this.client, options)\n      .fetch(url, 'POST', new StatisticsRequestPayload(this.client, sources, options))\n    return new StatisticsResult(result, options.statistics)\n  }\n\n\n  /**\n   *\n   * @param sources\n   * @param options\n   */\n  async geometry(geometry: string, options: StatisticsGeometryRequestOptions): Promise<StatisticsGeometryResult> {\n    if (!geometry) {\n      return null\n    }\n\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.statisticsUrl)\n      .part('values/geometry')\n      .params({\n        serviceUrl: this.client.serviceUrl\n      })\n      .toString();\n\n    const result = await requests(this.client, options)\n    .fetch(url, 'POST', new StatisticsGeometryRequestPayload(this.client, geometry, options))\n    return new StatisticsGeometryResult(result, options.statistics)\n  }\n\n  /**\n   *\n   * @param group\n   */\n  async metadata(group: StatisticsGroupMeta | StatisticsGroupId) {\n    const server = this.client.config.tilesUrl\n    const key = (typeof group == 'number') ? group : group.id\n    const cacheKey = server + '-' + key\n\n    return await this.statisticsMetadataCache.get(cacheKey, async () => {\n\n      const url = new UrlUtil.TargomoUrl(this.client)\n        .host(this.client.config.tilesUrl)\n        .part('statistics/meta/')\n        .version()\n        .part('/' + key + '')\n        .key()\n        .toString();\n\n      const result = await requests(this.client).fetch(url)\n      if (!result.name && result.names && result.names.en) {\n        result.name = result.names.en\n      }\n\n      if (result.stats && result.stats.length) {\n        result.stats.forEach((stat: any) => {\n          if (!stat.name && stat.names && stat.names.en) {\n            stat.name = stat.names.en\n          }\n        })\n      }\n\n      return result\n    })\n  }\n\n  /**\n   *\n   */\n  async metadataKey(group: StatisticsGroupMeta | StatisticsGroupId, statistic: StatisticsItem): Promise<StatisticsItemMeta> {\n    const endpoint = await this.metadata(group)\n\n    for (let attribute of endpoint.stats) {\n      if (statistic.id == attribute.statistic_id || (attribute.names && attribute.names.en == statistic.name)) {\n        return attribute\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Potentially decorate a layer route with excluded statistics.\n   */\n  tileRoute(group: StatisticsGroupMeta | StatisticsGroupId, include?: StatisticsItem[]) {\n    const key = (typeof group == 'number') ? group : group.id\n\n    const urlObject = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.tilesUrl)\n      .part('statistics/tiles/')\n      .version()\n      .part('/' + key + '/{z}/{x}/{y}.mvt')\n      .key();\n\n    return include && include.length > 0 ?\n      urlObject.params({columns: encodeURIComponent(include.map(row => +row.id).join(','))}).toString() :\n      urlObject.toString()\n\n  }\n\n  /**\n   *\n   * @param sources\n   * @param options\n   */\n  async ensembles(): Promise<{[id: string]: StatisticsGroupEnsemble}> {\n    const cacheKey = this.client.config.tilesUrl\n\n    return await this.statisticsEnsemblesCache.get(cacheKey, async () => {\n\n      const url = new UrlUtil.TargomoUrl(this.client)\n        .host(this.client.config.tilesUrl)\n        .part('ensemble/list/')\n        .version()\n        .key()\n        .toString();\n\n      const result = await requests(this.client).fetch(url, 'GET')\n\n      // FIXME: workaround for server results\n      for (let id in result) {\n        if (result[id]) {\n          const ensemble = result[id]\n          ensemble.id = +ensemble.id\n          if (ensemble.groups && ensemble.groups.length) {\n            ensemble.groups.forEach((group: any) => {\n              group.hierarchy = +group.hierarchy\n              group.id = +group.id\n            })\n          }\n        }\n      }\n\n      return result\n    })\n  }\n}\n","import { StatisticsRequestPayload } from './statisticsRequestPayload'\nimport {\n  LatLngId,\n  MultigraphRequestOptions,\n  MultigraphRequestAggregation,\n  MultigraphAggregationOptions,\n} from '../../types'\nimport { TargomoClient } from '../targomoClient'\n\nexport class StatefulMultigraphRequestPayload extends StatisticsRequestPayload {\n  multiGraphPreAggregationPipeline: {\n    [pipelineName: string]: MultigraphAggregationOptions\n  }\n\n  multiGraphReferencedStatisticIds: {\n    [parameterName: string]: number\n  }\n\n  multiGraphAggregationType: MultigraphRequestAggregation\n  multiGraphAggregationIgnoreOutliers: boolean\n  multiGraphAggregationOutlierPenalty: number\n  multiGraphAggregationMinSourcesRatio: number\n  multiGraphAggregationMinSourcesCount: number\n  multiGraphAggregationMaxResultValueRatio: number\n  multiGraphAggregationMaxResultValue: number\n  multiGraphAggregationFilterValuesForSourceOrigins: string[]\n  multiGraphAggregationMathExpression: string\n  multiGraphAggregationGravitationExponent: number\n  multiGraphAggregationPostAggregationFactor: number\n  multiGraphAggregationInputParameters: {\n    [parameterName: string]: {\n      inputFactor?: number\n      gravitationAttractionStrength?: number\n      gravitationPositiveInfluence?: number\n    }\n  }\n\n  multiGraphSerializationFormat: 'geojson' | 'json' | 'mvt'\n  multiGraphSerializationDecimalPrecision: number\n  multiGraphSerializationMaxGeometryCount: number\n\n  multiGraphDomainType: 'edge' | 'node' | 'statistic_geometry'\n  multiGraphDomainEdgeAggregationType: 'min' | 'max' | 'mean'\n  multiGraphDomainStatisticGroupId: number\n\n  multiGraphLayerType: 'identity' | 'tile' | 'hexagon' | 'custom_geometries'\n  multiGraphLayerGeometryDetailPerTile: number\n  multiGraphLayerMinGeometryDetailLevel: number\n  multiGraphLayerMaxGeometryDetailLevel: number\n  multiGraphLayerGeometryDetailLevel: number\n  multiGraphLayerCustomGeometryMergeAggregation: 'max' | 'mean' | 'min' | 'sum'\n\n  constructor(client: TargomoClient, sources: LatLngId[], options: MultigraphRequestOptions) {\n    super(client, sources, <any>options)\n\n    // This request only works if only recognized attributes are sent\n    delete this.inactiveSources\n    delete this.statisticGroupId\n    delete this.statisticIds\n    delete this.getClosestSources\n    delete this.useCache\n\n    if (options) {\n      if (options.multigraph.preAggregationPipeline) {\n        this.multiGraphPreAggregationPipeline = options.multigraph.preAggregationPipeline\n      }\n\n      if (options.multigraph.referencedStatisticIds) {\n        this.multiGraphReferencedStatisticIds = options.multigraph.referencedStatisticIds\n      }\n\n      if (options.multigraph.aggregation) {\n        this.multiGraphAggregationType = options.multigraph.aggregation.type || null\n        this.multiGraphAggregationIgnoreOutliers = options.multigraph.aggregation.ignoreOutliers || null\n        this.multiGraphAggregationOutlierPenalty = options.multigraph.aggregation.outlierPenalty || null\n        this.multiGraphAggregationMinSourcesRatio = options.multigraph.aggregation.minSourcesRatio || null\n        this.multiGraphAggregationMinSourcesCount = options.multigraph.aggregation.minSourcesCount || null\n        this.multiGraphAggregationMaxResultValueRatio = options.multigraph.aggregation.maxResultValueRatio || null\n        this.multiGraphAggregationMaxResultValue = options.multigraph.aggregation.maxResultValue || null\n        this.multiGraphAggregationFilterValuesForSourceOrigins =\n          options.multigraph.aggregation.filterValuesForSourceOrigins || null\n        this.multiGraphAggregationInputParameters = options.multigraph.aggregation.aggregationInputParameters || null\n        this.multiGraphAggregationMathExpression = options.multigraph.aggregation.mathExpression || null\n        this.multiGraphAggregationGravitationExponent = options.multigraph.aggregation.gravitationExponent || null\n        this.multiGraphAggregationPostAggregationFactor = options.multigraph.aggregation.postAggregationFactor || null\n      }\n\n      this.multiGraphSerializationFormat = options.multigraph.serialization.format\n      this.multiGraphSerializationDecimalPrecision = options.multigraph.serialization.decimalPrecision\n      this.multiGraphSerializationMaxGeometryCount = options.multigraph.serialization.maxGeometryCount\n\n      this.multiGraphDomainType = options.multigraph.domain.type\n      this.multiGraphDomainEdgeAggregationType = options.multigraph.domain.edgeAggregationType\n      this.multiGraphDomainStatisticGroupId = options.multigraph.domain.statisticGroupId\n\n      if (options.multigraph.layer) {\n        this.multiGraphLayerType = options.multigraph.layer.type\n        this.multiGraphLayerGeometryDetailPerTile = options.multigraph.layer.geometryDetailPerTile\n        this.multiGraphLayerMinGeometryDetailLevel = options.multigraph.layer.minGeometryDetailLevel\n        this.multiGraphLayerMaxGeometryDetailLevel = options.multigraph.layer.maxGeometryDetailLevel\n        this.multiGraphLayerGeometryDetailLevel = options.multigraph.layer.geometryDetailLevel\n        this.multiGraphLayerCustomGeometryMergeAggregation = options.multigraph.layer.customGeometryMergeAggregation\n      }\n    }\n  }\n}\n","import { TargomoClient } from './targomoClient'\nimport { LatLngId, MultigraphRequestOptions, MultigraphInfo, BoundingBox } from '../index'\nimport { UrlUtil } from '../util/urlUtil'\nimport { requests } from '../util/requestUtil'\nimport { StatefulMultigraphRequestPayload } from './payload/statefulMultigraphRequestPayload'\n\n/**\n * @Topic Stateful Multigraph\n */\nexport class StatefulMultigraphClient {\n  constructor(private client: TargomoClient) {}\n\n  /**\n   * Creates a new multigraph tile set for the given sources and parameters.\n   * Returns an id for the given aggregation to be used in subsequent mvt requests.\n   *\n   * @param sources\n   * @param options\n   */\n  async create(sources: LatLngId[], options: MultigraphRequestOptions): Promise<string> {\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.statisticsUrl)\n      .part('multigraph')\n      .key()\n      .params({ serviceUrl: this.client.serviceUrl })\n      .toString()\n\n    const cfg = new StatefulMultigraphRequestPayload(this.client, sources, options)\n\n    const result = await requests(this.client, options).fetchCachedData(\n      options.useClientCache,\n      url,\n      'POST-RAW',\n      JSON.stringify(cfg),\n      { Accept: 'text/plain' }\n    )\n    return result\n  }\n\n  /**\n   * Runs a \"monolith\" multigraph request for the given sources and parameters.\n   * This performs the usual routing and then performs a global aggregation\n   * into a single value per layer.\n   *\n   * @param sources\n   * @param options\n   */\n  async monolith(sources: LatLngId[], options: MultigraphRequestOptions): Promise<string> {\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.statisticsUrl)\n      .part('multigraph/monolith')\n      .key()\n      .params({ serviceUrl: this.client.serviceUrl })\n      .toString()\n\n    const cfg = new StatefulMultigraphRequestPayload(this.client, sources, options)\n\n    const result = await requests(this.client, options).fetchCachedData(options.useClientCache, url, 'POST', cfg, {\n      Accept: 'application/json',\n    })\n    return result\n  }\n\n  /**\n   * Returns Info about the current State of the multigraph calculation\n   *\n   * **Multigraph Lifecycle**\n   * 1. CREATED\n   * 2. ROUTING\n   * 3. MERGING\n   * 4. AGGREGATING\n   * 5. COMPLETED / FAILED\n   *\n   * @param multigraphId UUID of the multigraph\n   */\n  async info(multigraphId: string): Promise<MultigraphInfo> {\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.statisticsUrl)\n      .part('multigraph/' + multigraphId)\n      .key()\n      .params({ serviceUrl: this.client.serviceUrl })\n      .toString()\n\n    const result = await requests(this.client).fetch(url, 'GET')\n    if (result.boundingBoxNorthEast && result.boundingBoxSouthWest) {\n      result.boundingBox = <BoundingBox>{\n        northEast: {\n          lat: result.boundingBoxNorthEast.y,\n          lng: result.boundingBoxNorthEast.x,\n        },\n        southWest: {\n          lat: result.boundingBoxSouthWest.y,\n          lng: result.boundingBoxSouthWest.x,\n        },\n      }\n      delete result.boundingBoxNorthEast\n      delete result.boundingBoxSouthWest\n    }\n    return result\n  }\n\n  /**\n   * Redo Multigraph with UUID `multigraphId`\n   *\n   * @param multigraphId\n   */\n  async redo(multigraphId: string): Promise<void> {\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.statisticsUrl)\n      .part('multigraph/' + multigraphId + '/update')\n      .key()\n      .params({ serviceUrl: this.client.serviceUrl })\n      .toString()\n\n    const result = await requests(this.client).fetch(url, 'PATCH')\n    return result\n  }\n\n  getTiledMultigraphUrl(multigraphId: string, format: 'geojson' | 'json' | 'mvt'): string {\n    return new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.statisticsUrl)\n      .part('multigraph/' + multigraphId + '/{z}/{x}/{y}.' + format)\n      .key()\n      .params({ serviceUrl: this.client.serviceUrl })\n      .toString()\n  }\n}\n","import { FpResult } from './../types/responses/FleetResult';\nimport { FpRequestOptions } from './../types/options/fleetRequestOptions';\nimport { FpTransport } from './../types/types';\nimport { TargomoClient } from './targomoClient'\nimport { requests } from '../util/requestUtil';\nimport { FpRequestPayload } from './payload/fleetsRequestPayload';\nimport { FpStore, FpOrder } from '../types';\nimport { UrlUtil } from '../util/urlUtil';\n\n\n/**\n * @Topic Fleetplanner\n * @General This is the entry point for the Fleetplanner service.\n * The Fleetplanner service enables the configurable calculation of\n * efficient routing for multi-vehicle, multi-destination delivery scenarios.\n *\n * This service solves the Vehicle Routing Problem(VRP) which is similar to the traveling salesman problem. The difference between the two\n * problems, is that the VRP concerns multiple vehicles; a fleet of vehicles.\n * The VRP is about finding the optimal combination of routes for all of the vehicles.\n *\n * The VRP can be extended with additional factors that make the problem more complex. For example, deadlines can\n * be introduced. Every location has a deadline. In an optimal scenario, all the deadlines should be met. However, it is\n * not always possible to meet all deadlines with the number of vehicles that are available. In that case, the goal of the\n * VRP is to either meet as many deadlines, or to optimize the total sum of expired deadline times.\n *\n * Another way the VRP can be extended is by introducing weight and volumes to the orders that need to be delivered and having\n * vehicles with a maximum load weight and volume capacity.\n *\n * More in-depth/detailed information about the Fleetplanner service can be found at https://docs.targomo.com/fleetplanner/\n*/\nexport class FleetsClient {\n  constructor(private client: TargomoClient) {\n  }\n\n  /**\n   * @General Start a new request to compute optimized routes with the provided information.\n   * @Performance Depending on the options, the execution time of this call can vary significantly.\n   * This function makes a http POST request to the Targomo REST service for the Fleetplanner.\n   * Every call to this function will be recorded based on your API key.\n   * All your usage statistics are accessible on https://account.targomo.com/statistics.\n   * @Exceptions This function can return the same exceptions as described on https://docs.targomo.com/fleetplanner/\n   * @Example\n   * ``` js\n   * const stores = [{ uuid: '1', address: { lat: 52.474257, lng: 13.378094 } }];\n   * const orders = [{ storeUuid: '1', address: { lat: 52.4, lng: 13.4 } },\n   *                 { storeUuid: '1', address: { lat: 52.6, lng: 13.6 } },\n   *                 { storeUuid: '1', address: { lat: 52.6, lng: 13.3 } }];\n   * const transports = [{ vehicle: { storeUuid: '1', maxVolume: 100, maxWeight: 100 } }];\n   * const options = { optimizationAlgorithm: 'CONSTRAINT_SATISFACTION', maxEdgeWeight: 3000, travelType: 'car' }\n   * targomoClient.fleets.fetch(stores, orders, transports, options).then(result => {\n   *     console.log(result.tours);\n   * });\n   * ```\n   *\n   * @Param stores\n   * The stores, or otherwise called 'depots' from which their respective vehicles start their routes.\n   * A store has a relation with zero or more orders, and zero or more vehicles.\n   * @Param orders\n   * The orders that need to be serviced by a vehicle from the store which is concerns this order.\n   * An order has a relation with one store.\n   * ##### Performance\n   * The amount of orders has a significant on the time it takes to optimize the routes.\n   * When using the default settings for optimizationTime and unimprovedWaitingTime in combination with more than 100 orders,\n   * you can expect the results to be less optimized.\n   * In this case, the algorithm doesn't have enough time to completely finish the optimization for this amount of orders.\n   * Raise the optimizationTime option when sending a request with a high amount of orders.\n   * @Param transports\n   * The transports (vehicles). Each of which are assigned to a certain store.\n   * @Param options\n   * ##### Performance\n   * Various different options within this options object can have a significant noticable impact on the request duration.\n   */\n  async fetch(stores: FpStore[], orders: FpOrder[], transports: FpTransport[], options: FpRequestOptions): Promise<FpResult> {\n\n    const url = new UrlUtil.TargomoUrl(this.client)\n      .host(this.client.config.fleetsUrl)\n      .version()\n      .part('/api/key-auth/optimizations')\n      .key()\n      .toString();\n\n    const cfg = this._createPayload(this.client, stores, orders, transports, options);\n\n    const result = await requests(this.client, options).fetch(url, 'POST', cfg);\n\n    return result;\n  }\n\n\n  private _createPayload(\n    client: TargomoClient,\n    stores: FpStore[],\n    orders: FpOrder[],\n    transports: FpTransport[],\n    options: FpRequestOptions) {\n    const payload: FpRequestPayload = {\n      optimizationTime: options.optimizationTime,\n      optimizationAlgorithm: options.optimizationAlgorithm,\n      optimizationMetadata: {\n        costMatrixSource: options.costMatrixSource,\n        geojsonCreation: options.geojsonCreation,\n        unimprovedWaitingTime: options.unimprovedWaitingTime,\n        filterOrdersWithMissedDeadline: options.filterOrdersWithMissedDeadline,\n        filterOrdersOutsideOfValidWorkingHours: options.filterOrdersOutsideOfValidWorkingHours,\n        prohibitFilteringOfOrdersWithDeadlinesEarlierEqualsThan: options.prohibitFilteringOfOrdersWithDeadlinesEarlierEqualsThan,\n        secondsToPenaltyRatioForDeadlineMissed: options.secondsToPenaltyRatioForDeadlineMissed,\n        secondsToPenaltyRatioForOutOfWorkingHours: options.secondsToPenaltyRatioForOutOfWorkingHours,\n        timeConstraintPenaltyToTravelCostRatio: options.timeConstraintPenaltyToTravelCostRatio,\n        longestTourPenaltyFactor: options.longestTourPenaltyFactor,\n        nonParallelOrdersByTags: options.nonParallelOrdersByTags,\n        travelOptions: {\n          travelType: options.travelType,\n          serviceKey: client.serviceKey,\n          serviceUrl: client.serviceUrl,\n          travelTimeFactors: options.travelTimeFactors,\n          fallbackServiceUrl: '',\n          edgeWeight: options.edgeWeight,\n          maxEdgeWeight: options.maxEdgeWeight,\n          elevation: options.elevation,\n          rushHour: options.rushHour\n        }\n      },\n      stores: stores,\n      transports: transports,\n      orders: orders\n    }\n    return payload;\n  }\n}\n","import { TargomoClient } from './targomoClient'\nimport { UrlUtil } from '../util';\n/**\n * @Topic Basemaps\n * @General This is the entry point for using the basemaps provided by Targomo.\n * @Alternative If you wish to use our basemaps with Leaflet. Please take a look at the targomo-js-extensions library.\n * We have a Leaflet extension for using our basemaps in that library.\n*/\nexport class BasemapsClient {\n\n    /**\n     * @General A lookup list of all the basemap names that we provide.\n     * Soon we will have a code example in which you can see what the different basemaps look like.\n     * @Alternative Use the basemapNames getter if you want to get a list of keys which you can use to get the GLStyleURL.\n    */\n    readonly basemapsLookup: { [name: string]: string } = {\n        'Bright': 'osm-bright-gl-style',\n        'Light': 'positron-gl-style',\n        'Light No-Labels': 'positron-nolabels-gl-style',\n        'Dark': 'dark-matter-gl-style',\n        'Dark No-Labels': 'dark-matter-nolabels-gl-style',\n        'Gray': 'gray-gl-style',\n        'Gray No-Labels': 'gray-nolabels-gl-style',\n        'Light blue': 'blueberry-gl-style',\n        'Dark blue': 'fiord-color-gl-style',\n        'Dark blue No-Labels': 'fiord-color-nolabels-gl-style',\n        'Basic': 'klokantech-basic-gl-style',\n        'Toner': 'toner-gl-style',\n    }\n\n\n    constructor(private client: TargomoClient) {\n    }\n\n    /**\n     * @Format Note that the basemap names start with a capital letter.\n     * @Return A list of basemap names which can be used to pass as a parameter in the getGLStyleURL method.\n    */\n    get basemapNames(): string[] {\n        return Object.keys(this.basemapsLookup)\n    }\n\n\n    /**\n     * @General Get a GL style URL which can be used in Mapbox.\n     * @Exceptions This method can throw the error \"valid style name required to access Targomo basemap\".\n     * This error is thrown when the passed basremapName does not exist in basemapsLookup.\n     * Make sure that you get the basemapName with the basemapNames accessor when this error is thrown.\n     * @Example\n     * ``` js\n     * const basemaps = targomoClient.basemaps;\n     * const basemapNames = basemaps.basemapNames;\n     * const name = basemapNames[0];\n     * const styleURL = basemaps.getStyleURL(name);\n     * yourMapboxMap.setStyle(styleUrl);\n     * ```\n     * @Return Url for mapbox-gl style.\n     * @Param basemapName\n     * A string of valid basemap name (which you can get from the basemapNames accessor)\n    */\n    getGLStyleURL(basemapName: string): string {\n        if (!basemapName || !this.basemapsLookup[basemapName]) {\n            throw new Error('valid style name required to access Targomo basemap');\n        }\n        return new UrlUtil.TargomoUrl(this.client)\n            .host(this.client.config.basemapsUrl)\n            .part(this.basemapsLookup[basemapName] + '.json')\n            .params({key: this.client.serviceKey})\n            .toString();\n    }\n}\n","import { requests } from '../util/requestUtil'\n\nimport { PointsOfInterestClient } from './pointsOfInterest'\nimport { StatisticsClient } from './statistics'\nimport { ReachabilityClient } from './reachability'\nimport { OptimizationsClient } from './optimizations'\nimport { GeocodeEsriClient } from './geocode'\nimport { GeocodePhotonClient } from './geocodePhoton'\nimport { PolygonsClient } from './polygons'\nimport { RoutesClient } from './routes'\nimport { SimilarityClient } from './similarity'\nimport { BenchmarksClient } from './benchmarks'\nimport { ClientConfig, ClientOptions } from './clientConfig'\nimport { StatefulMultigraphClient } from './statefulMultigraph';\nimport { FleetsClient } from './fleets';\nimport { MultigraphClient } from './multigraph';\nimport { BasemapsClient } from './basemaps';\nimport { UrlUtil } from '..';\n\n/**\n * @Topic Geocoding\n */\nexport class GeocodingClients {\n  constructor(\n    readonly esri: GeocodeEsriClient,\n    readonly photon: GeocodePhotonClient\n  ) { }\n}\n\nexport class TargomoClient {\n\n  readonly serviceUrl: string\n\n  readonly pois: PointsOfInterestClient\n  readonly statistics: StatisticsClient\n  readonly reachability: ReachabilityClient\n  readonly optimizations: OptimizationsClient\n  readonly geocoding: GeocodingClients\n\n  readonly polygons: PolygonsClient\n  readonly routes: RoutesClient\n  readonly similarity: SimilarityClient\n  readonly benchmarks: BenchmarksClient\n  readonly statefulMultigraph: StatefulMultigraphClient\n  readonly multigraph: MultigraphClient\n  readonly fleets: FleetsClient\n\n  readonly basemaps: BasemapsClient\n\n  readonly config: ClientConfig\n\n  /**\n   * Create a new Targomo client\n   * @param region Service region name or full service URL. See: https://developers.route360.net/availability/\n   * @param serviceKey Your targomo service key\n   * @param additionalOptions additional options, defaults will be used if not provided\n   */\n  constructor(region: string, public serviceKey: string, options?: ClientOptions) {\n\n    if (!region) {\n      throw new TypeError('Region parameter is missing');\n    }\n\n    this.config = new ClientConfig(options)\n\n    if (!region.includes('http') && !region.includes('localhost') && !region.includes('/')) {\n      this.serviceUrl = 'https://api.targomo.com/' + region + '/'\n    } else {\n      this.serviceUrl = region\n    }\n\n    this.pois = new PointsOfInterestClient(this)\n    this.statistics = new StatisticsClient(this)\n    this.reachability = new ReachabilityClient(this)\n    this.optimizations = new OptimizationsClient(this)\n\n    this.geocoding = new GeocodingClients(\n      new GeocodeEsriClient(),\n      new GeocodePhotonClient(this)\n    )\n\n    this.polygons = new PolygonsClient(this)\n    this.routes = new RoutesClient(this)\n    this.similarity = new SimilarityClient(this)\n    this.benchmarks = new BenchmarksClient(this)\n    this.statefulMultigraph = new StatefulMultigraphClient(this)\n    this.multigraph = new MultigraphClient(this)\n    this.basemaps = new BasemapsClient(this);\n    this.fleets = new FleetsClient(this);\n  }\n\n  /**\n   * Extracts the endpoint part from the serviceUrl (for example `germany`)\n   */\n  get endpoint() {\n    const items = this.serviceUrl.split('/').filter(item => !!item)\n    return items[items.length - 1]\n  }\n\n\n  /**\n   *\n   */\n  async metadata() {\n\n    const url = new UrlUtil.TargomoUrl(this)\n      .part(this.serviceUrl)\n      .version()\n      .part('/metadata/network')\n      .key()\n      .toString();\n\n    return await requests(this).fetch(url)\n  }\n}\n","export * from './api'\nexport * from './types'\nexport * from './util'\n\nimport * as geometryModule from './geometry'\nexport const geometry = geometryModule // NOTE: this does not export types, however we have none in there for now\n"],"names":["self","fetch","support","Symbol","Blob","e","viewClasses","isDataView","obj","DataView","prototype","isPrototypeOf","isArrayBufferView","ArrayBuffer","isView","indexOf","Object","toString","call","Headers","append","name","value","normalizeName","normalizeValue","oldValue","this","map","get","has","hasOwnProperty","set","forEach","callback","thisArg","keys","items","push","iteratorFor","values","entries","iterator","methods","Request","clone","body","_bodyInit","Body","Response","status","statusText","headers","url","error","response","type","redirectStatuses","redirect","RangeError","location","input","init","Promise","resolve","reject","request","xhr","XMLHttpRequest","onload","rawHeaders","options","getAllResponseHeaders","replace","split","line","parts","key","shift","trim","join","responseURL","responseText","onerror","TypeError","ontimeout","open","method","credentials","withCredentials","responseType","setRequestHeader","send","polyfill","String","test","toLowerCase","next","done","undefined","Array","isArray","header","getOwnPropertyNames","consumed","bodyUsed","fileReaderReady","reader","result","readBlobAsArrayBuffer","blob","FileReader","promise","readAsArrayBuffer","bufferClone","buf","slice","view","Uint8Array","byteLength","buffer","_initBody","_bodyText","_bodyBlob","FormData","_bodyFormData","URLSearchParams","_bodyArrayBuffer","Error","rejected","arrayBuffer","then","text","readAsText","chars","length","i","fromCharCode","readArrayBufferAsText","formData","decode","json","JSON","parse","upcased","mode","toUpperCase","referrer","form","bytes","decodeURIComponent","bodyInit","ok","assign","previous","capacity","SimpleLRU","factory","found","oldest","newest","_a","entry","SimpleLRUEntry","size","current","SimpleCache","keyString","stringify","CACHE","console","log","RequestsUtil","payload","requestMethod","requestHeaders","requestOptions","_e","debug","_c","_b","logBody","responseBody","responseValue","data","start","end","lastIndexOf","substring","_d","warn","cache","_this","fetchData","client","config","UrlUtil","BenchmarksClient","group","conditions","bounds","boundsData","west","southWest","lng","south","lat","east","northEast","north","benchmarks","item","source","minEnd","minStart","factor","TargomoUrl","host","tilesUrl","part","version","encodeURIComponent","requests","substr","v","param","firstParamPlaced","params","serviceKey","GeocodeEsriClient","query","center","language","country","magicKey","singleLine","f","countryCode","maxLocations","jsonResult","candidates","y","x","description","address","suggestionsCount","maxSuggestions","suggestions","Match_addr","city","City","CountryCode","Loc_name","region","Region","subregion","Subregion","zip","Postal","GeocodePhotonClient","photonGeocoderUrl","q","limit","features","feature","index","array","properties","osm_key","splice","osm_id","buildPlaceDescription","texts","middle","filter","fields","address1","address2","title","meta1","meta2","full","tslib_1.__extends","BaseRequestOptions","_super","transitFrameDateTime","date","transitFrameDate","Date","getFullYear","getMonth","getDate","transitFrameTime","getHours","getMinutes","TravelRequestPayload","targets","original","id","sources","tm","travelType","car","rushHour","walk","walkSpeed","bike","bikeSpeed","transit","frame","time","duration","transitFrameDuration","maxTransfers","transitMaxTransfers","TravelRequestOptions","buildSourcesCfg","buildTargetsCfg","multigraph","MultigraphClient","serviceUrl","cfg","MultigraphRequestPayload","format","objectCache","cfgUuid","uuid","email","sendMail","callbackUrl","pointsPerSolution","maxSolutions","edgeWeight","maxEdgeWeight","statisticGroupId","statisticGroup","statistic","Number","statisticId","sourcesObject","raw","maxPossibleValue","solutions","simulationResults","simulationResult","sourcePoints","point","optimal","startTime","endTime","maxValue","numberOfDesiredPoints","OptimizationsClient","statisticsUrl","OptimizationRequestPayload","optimizationId","simulationId","OptimizationResult","osmTypes","OSMLatLng","lon","tags","StatisticsGroups","PointsOfInterestClient","overpassUrl","elements","parseOSMLocation","categories","boundingBox","tag","category","box","asQueryElement","queryRaw","poiUrl","POIRequestPayload","SRID","MultigraphRequestAggregation","MultigraphRequestLayer","total","sphericalMercator","class_1","latlng","d","Math","PI","sin","max","min","R","atan","exp","EARTH_RADIUS_KM","RADIANS","from","to","fromLat","fromLng","toLat","toLng","acos","cos","distance","latRadians","deltaLat","deltaLong","locations","reduce","acc","val","distanceKm","locationsWithinDistanceInclusive","some","calculateDistance","elevation","projection.sphericalMercator","unproject","MultigraphStatus","bBox","speed","locationsWithinDistance","round","getSpeed","boundingBoxResult","Infinity","project","segment","points","travelTime","warning","elevationGain","transitSegment","startName","startname","endName","endname","geometry.webMercatorToLatLng","isTransit","routeType","routeShortName","routeLongName","departureTime","arrivalTime","tripHeadSign","segments","meta","routeSegments","targetHeight","sourceHeight","sourceId","targetId","transfers","reverse","routeSegment","RouteSegment","concat","source_id","target_id","elevationDifferences","calculateElevationDifferences","uphillMeter","downhillMeter","totalElevationDifference","abs","calculateDepartureTime","calculateArrivalTime","calculateElevationGain","Route","isFinite","previousHeight","statistics","statisticsGroup","statistics_1","_i","StatisticValues","individualStatistics","dataToStatisticgroup","statsticsMap","row","aggregationKey","aggregation","SRID_4326","PolygonPayloadOptions","polygon","travelEdgeWeights","serializer","simplify","srid","minPolygonHoleSize","quadrantSegments","intersectionMode","decimalPrecision","ProjectedPoint","ProjectedBounds","expandPoint","coordinates","coordinate","bounds3857","pair","geometry.sphericalMercator","area","lineStrings","ProjectedLineString","outerBoundary","expand","innerBoundary","lineString","PolygonsClient","PolygonRequestPayload","_executeFetch","PolygonArray","create","metadata","fetchCachedData","useClientCache","newProto","polygons","boundsPoints","svgPolygons","polygonData","ProjectedPolygon","webMercatorToLatLng","boundingBoxFromLocationArray","ReachabilityClient","TimeRequestPayload","place","combined","target","pathSerializer","recommendations","isInteger","RoutesClient","RouteRequestPayload","routes","Accept","SimilarityClient","cell","normalizeOnViewport","refCellId","scores","minutes","urlObject","useCache","iFeelLucky","maxWalkingTimeFromSource","transitMaxWalkingTimeFromSource","avoidTransitRouteTypes","transitAvoidTransitRouteTypes","inactiveSources","statisticsIndices","omitIndividualStatistics","statisticIds","closestSources","getClosestSources","geometry","intersectionGeometry","crs","StatisticsClient","dependent","StatisticsRequestPayload","StatisticsResult","StatisticsGeometryRequestPayload","StatisticsGeometryResult","server","cacheKey","statisticsMetadataCache","names","en","stats","stat","endpoint","attribute","statistic_id","include","columns","statisticsEnsemblesCache","ensemble","groups","hierarchy","preAggregationPipeline","multiGraphPreAggregationPipeline","referencedStatisticIds","multiGraphReferencedStatisticIds","multiGraphAggregationType","multiGraphAggregationIgnoreOutliers","ignoreOutliers","multiGraphAggregationOutlierPenalty","outlierPenalty","multiGraphAggregationMinSourcesRatio","minSourcesRatio","multiGraphAggregationMinSourcesCount","minSourcesCount","multiGraphAggregationMaxResultValueRatio","maxResultValueRatio","multiGraphAggregationMaxResultValue","maxResultValue","multiGraphAggregationFilterValuesForSourceOrigins","filterValuesForSourceOrigins","multiGraphAggregationInputParameters","aggregationInputParameters","multiGraphAggregationMathExpression","mathExpression","multiGraphAggregationGravitationExponent","gravitationExponent","multiGraphAggregationPostAggregationFactor","postAggregationFactor","multiGraphSerializationFormat","serialization","multiGraphSerializationDecimalPrecision","multiGraphSerializationMaxGeometryCount","maxGeometryCount","multiGraphDomainType","domain","multiGraphDomainEdgeAggregationType","edgeAggregationType","multiGraphDomainStatisticGroupId","layer","multiGraphLayerType","multiGraphLayerGeometryDetailPerTile","geometryDetailPerTile","multiGraphLayerMinGeometryDetailLevel","minGeometryDetailLevel","multiGraphLayerMaxGeometryDetailLevel","maxGeometryDetailLevel","multiGraphLayerGeometryDetailLevel","geometryDetailLevel","multiGraphLayerCustomGeometryMergeAggregation","customGeometryMergeAggregation","StatefulMultigraphClient","StatefulMultigraphRequestPayload","multigraphId","boundingBoxNorthEast","boundingBoxSouthWest","FleetsClient","stores","orders","transports","fleetsUrl","_createPayload","optimizationTime","optimizationAlgorithm","optimizationMetadata","costMatrixSource","geojsonCreation","unimprovedWaitingTime","filterOrdersWithMissedDeadline","filterOrdersOutsideOfValidWorkingHours","prohibitFilteringOfOrdersWithDeadlinesEarlierEqualsThan","secondsToPenaltyRatioForDeadlineMissed","secondsToPenaltyRatioForOutOfWorkingHours","timeConstraintPenaltyToTravelCostRatio","longestTourPenaltyFactor","nonParallelOrdersByTags","travelOptions","travelTimeFactors","fallbackServiceUrl","Bright","Light","Light No-Labels","Dark","Dark No-Labels","Gray","Gray No-Labels","Light blue","Dark blue","Dark blue No-Labels","Basic","Toner","BasemapsClient","basemapsLookup","basemapName","basemapsUrl","esri","photon","ClientConfig","includes","pois","reachability","optimizations","geocoding","GeocodingClients","similarity","statefulMultigraph","basemaps","fleets","TargomoClient","geometryModule"],"mappings":"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"}