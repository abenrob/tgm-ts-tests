export interface Cache<T> {
    get(key: string, factory?: () => Promise<T>): Promise<T>;
}
/**
 * Extremely simple LRU (to avoid includinng another library)...However when more functionality is needed then an existing library is better
 */
export declare class SimpleLRU<T> implements Cache<T> {
    private capacity;
    private map;
    private size;
    private newest;
    private oldest;
    constructor(capacity?: number);
    /**
     * If a value for a given key is contained in the cache then return that value
     * otherwise create/store and return a new value, by calling the given `factory` function
     *
     * @param key
     * @param factory
     */
    get(key: string, factory?: () => Promise<T>): Promise<T>;
}
/**
 * Even simpler unlimited cache
 */
export declare class SimpleCache<T> implements Cache<T> {
    private map;
    get(key: any, factory?: () => Promise<T>): Promise<T>;
}
