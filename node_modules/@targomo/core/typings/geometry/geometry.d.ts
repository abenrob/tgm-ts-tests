import { LatLng, BoundingBox, TravelType } from './../types/index';
/**
 * Return whether a lat/lng point is contained within a bounding box
 */
export declare function contains(bBox: BoundingBox, point: LatLng): boolean;
/**
 * Returns the distance in kilometers between two lat/lng points
 */
export declare function calculateDistance(from: LatLng, to: LatLng): number;
/**
 *
 * Creates a bounding box around a point
 *
 * @param from
 * @param distance distance in km
 */
export declare function boundingBox(from: LatLng, distance: number): BoundingBox;
/**
 * Give a list of locations return only those that are in proximity (predefined based on given TravelOptions)
 * to any location in the  `from` list
 * The use of this is to reduce the inputs to reachability and other requests (pre-filtering out remote targets) for perfromance reasons
 *
 * @param locations  The list to be filtered
 * @param from  results will be in proximity to these
 * @param options traveloptions (affect the distance around the `from` list that will be considered)
 */
export declare function locationsWithinTravelOptions<T extends LatLng>(locations: T[], from: LatLng | LatLng[], options: {
    maxEdgeWeight: number;
    edgeWeight: 'time' | 'distance';
    travelType: TravelType;
}): T[];
/**
 * Creates a bounding box around a location, with parametres about the distance calculated (based on predefined internal logic)
 * from a give TravelOptions
 *
 * @param from
 * @param options
 */
export declare function boundingBoxWithinTravelOptions<T extends LatLng>(from: T, options: {
    maxEdgeWeight: number;
    edgeWeight: 'time' | 'distance';
    travelType: TravelType;
}): BoundingBox;
/**
 * Create a bounding box from an Array of latlng locations
 *
 * @param locations location array to get the bbox from
 */
export declare function boundingBoxFromLocationArray<T extends LatLng>(locations: T[]): BoundingBox;
/**
 * Creates a bounding box around a list location, with parameters about the distance calculated * (based on predefined internal logic)
 * from a give TravelOptions.
 * The bounding box returned will be the maximum bounding box that will include all bounding boxes generated for each location
 *
 * @param sources
 * @param options
 */
export declare function boundingBoxListWithinTravelOptions(sources: LatLng[], options: {
    maxEdgeWeight: number;
    edgeWeight: 'time' | 'distance';
    travelType: TravelType;
}): BoundingBox;
/**
 * Given a list of locations return only those that are within `distanceKm` to any location in the
 * `from` list, and which are not included in the `from` locations
 *
 * @param locations
 * @param from
 * @param distanceKm
 */
export declare function locationsWithinDistance<T extends LatLng>(locations: T[], from: LatLng | LatLng[], distanceKm: number): T[];
/**
 * Given a list of locations return only those that are within `distanceKm` to any location in the  `from` list
 *
 * @param locations
 * @param from
 * @param distanceKm
 */
export declare function locationsWithinDistanceInclusive<T extends LatLng>(locations: T[], from: LatLng | LatLng[], distanceKm: number): T[];
/**
 *
 * @param point
 * @param elevation
 */
export declare function webMercatorToLatLng(point: {
    x: number;
    y: number;
}, elevation: number): LatLng;
/**
 *
 * @param latlng
 */
export declare function latLngToWebMercator(latlng: LatLng): {
    x: number;
    y: number; /**
     * Some reusable functions that deal with lat/lng gemoetry calculations
     */
};
